#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MyCharacter

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AbilitySlots_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass MyCharacter.MyCharacter_C
// 0x0098 (0x03B0 - 0x0318)
class AMyCharacter_C : public APawn
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x0318(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class UAudioComponent*                        MAudioComponent;                                   // 0x0320(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UCapsuleComponent*                      Capsule;                                           // 0x0328(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UActorSequenceComponent*                DisappearSequence;                                 // 0x0330(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UActorSequenceComponent*                AppearSequence;                                    // 0x0338(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USpotLightComponent*                    MLight;                                            // 0x0340(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UWidgetComponent*                       HealthBar;                                         // 0x0348(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0350(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0358(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	bool                                          HasAction;                                         // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_248C[0x7];                                     // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMyAbilityBP_C*>                 MAbilities;                                        // 0x0368(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	int32                                         MaxLife;                                           // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         Life;                                              // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         AttackRange;                                       // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         MoveRange;                                         // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          NewVar;                                            // 0x0388(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          HasToPlayDamageAnim;                               // 0x0389(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Hastoplaydieanim;                                  // 0x038A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsWalking;                                         // 0x038B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          HasToPlayAttackAnim;                               // 0x038C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsSummoning;                                       // 0x038D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          HasDienAnim;                                       // 0x038E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          SetTMPDieAnim;                                     // 0x038F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          PreviewingAttack;                                  // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Clickable;                                         // 0x0391(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_248D[0x6];                                     // 0x0392(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MLogName;                                          // 0x0398(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash)
	bool                                          MEnemyHasToPlaySpawn;                              // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsActing;                                          // 0x03A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void ContinueAction(EAbilitySlots AbilityIdx);
	void Die();
	void DieAndDelete();
	void ExecuteUbergraph_MyCharacter(int32 EntryPoint);
	void Get_Clicked();
	void GetDeselected();
	void GetReady();
	void GetSelected();
	void Idle();
	void PreDisplayTarget(const struct FVector& Target, EAbilitySlots Whichability);
	void ReceiveBeginPlay();
	void ReceiveDamage(int32 Damage, class AActor* Attacker);
	void ReceiveTick(float DeltaSeconds);
	void Remove_from_Grid();
	void RotateTowards(const struct FVector& A);
	void SetAbilityArray();
	void UpdateAbilityCooldowns();
	void UpdateHealthBar();
	void UseAbility(EAbilitySlots AbilityIdx, const struct FVector& AbilityTarget);
	void ValidateTarget(const struct FVector& Target, EAbilitySlots Which_ability, bool* Return);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"MyCharacter_C">();
	}
	static class AMyCharacter_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMyCharacter_C>();
	}
};
static_assert(alignof(AMyCharacter_C) == 0x000008, "Wrong alignment on AMyCharacter_C");
static_assert(sizeof(AMyCharacter_C) == 0x0003B0, "Wrong size on AMyCharacter_C");
static_assert(offsetof(AMyCharacter_C, UberGraphFrame) == 0x000318, "Member 'AMyCharacter_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, MAudioComponent) == 0x000320, "Member 'AMyCharacter_C::MAudioComponent' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, Capsule) == 0x000328, "Member 'AMyCharacter_C::Capsule' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, DisappearSequence) == 0x000330, "Member 'AMyCharacter_C::DisappearSequence' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, AppearSequence) == 0x000338, "Member 'AMyCharacter_C::AppearSequence' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, MLight) == 0x000340, "Member 'AMyCharacter_C::MLight' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, HealthBar) == 0x000348, "Member 'AMyCharacter_C::HealthBar' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, SkeletalMesh) == 0x000350, "Member 'AMyCharacter_C::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, DefaultSceneRoot) == 0x000358, "Member 'AMyCharacter_C::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, HasAction) == 0x000360, "Member 'AMyCharacter_C::HasAction' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, MAbilities) == 0x000368, "Member 'AMyCharacter_C::MAbilities' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, MaxLife) == 0x000378, "Member 'AMyCharacter_C::MaxLife' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, Life) == 0x00037C, "Member 'AMyCharacter_C::Life' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, AttackRange) == 0x000380, "Member 'AMyCharacter_C::AttackRange' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, MoveRange) == 0x000384, "Member 'AMyCharacter_C::MoveRange' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, NewVar) == 0x000388, "Member 'AMyCharacter_C::NewVar' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, HasToPlayDamageAnim) == 0x000389, "Member 'AMyCharacter_C::HasToPlayDamageAnim' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, Hastoplaydieanim) == 0x00038A, "Member 'AMyCharacter_C::Hastoplaydieanim' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, IsWalking) == 0x00038B, "Member 'AMyCharacter_C::IsWalking' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, HasToPlayAttackAnim) == 0x00038C, "Member 'AMyCharacter_C::HasToPlayAttackAnim' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, IsSummoning) == 0x00038D, "Member 'AMyCharacter_C::IsSummoning' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, HasDienAnim) == 0x00038E, "Member 'AMyCharacter_C::HasDienAnim' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, SetTMPDieAnim) == 0x00038F, "Member 'AMyCharacter_C::SetTMPDieAnim' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, PreviewingAttack) == 0x000390, "Member 'AMyCharacter_C::PreviewingAttack' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, Clickable) == 0x000391, "Member 'AMyCharacter_C::Clickable' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, MLogName) == 0x000398, "Member 'AMyCharacter_C::MLogName' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, MEnemyHasToPlaySpawn) == 0x0003A8, "Member 'AMyCharacter_C::MEnemyHasToPlaySpawn' has a wrong offset!");
static_assert(offsetof(AMyCharacter_C, IsActing) == 0x0003A9, "Member 'AMyCharacter_C::IsActing' has a wrong offset!");

}

