#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: HardwareMonAndCompare

#include "Basic.hpp"

#include "HardwareMonAndCompare_classes.hpp"
#include "HardwareMonAndCompare_parameters.hpp"


namespace SDK
{

// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.addBytesToFileAndCloseIt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<uint8>&                    Bytes                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFileFunctionsHardwareMonAndCompare::addBytesToFileAndCloseIt(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath, const TArray<uint8>& Bytes, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "addBytesToFileAndCloseIt");

	Params::FileFunctionsHardwareMonAndCompare_addBytesToFileAndCloseIt Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);
	Parms.Bytes = std::move(Bytes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (success != nullptr)
		*success = Parms.success;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.base64StringToBytes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    base64String                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<uint8> UFileFunctionsHardwareMonAndCompare::base64StringToBytes(const class FString& base64String, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "base64StringToBytes");

	Params::FileFunctionsHardwareMonAndCompare_base64StringToBytes Parms{};

	Parms.base64String = std::move(base64String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (success != nullptr)
		*success = Parms.success;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.base64StringToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString*                          String                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    base64String                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFileFunctionsHardwareMonAndCompare::base64StringToString(class FString* String, const class FString& base64String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "base64StringToString");

	Params::FileFunctionsHardwareMonAndCompare_base64StringToString Parms{};

	Parms.base64String = std::move(base64String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (String != nullptr)
		*String = std::move(Parms.String);
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.bytesToBase64String
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<uint8>&                    Bytes                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FString*                          base64String                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFileFunctionsHardwareMonAndCompare::bytesToBase64String(const TArray<uint8>& Bytes, class FString* base64String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "bytesToBase64String");

	Params::FileFunctionsHardwareMonAndCompare_bytesToBase64String Parms{};

	Parms.Bytes = std::move(Bytes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (base64String != nullptr)
		*base64String = std::move(Parms.base64String);
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.createDirectory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFileFunctionsHardwareMonAndCompare::createDirectory(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "createDirectory");

	Params::FileFunctionsHardwareMonAndCompare_createDirectory Parms{};

	Parms.directoryType = directoryType;
	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.decryptMessageWithAES
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    encryptedBase64Message                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    keyIn256Bit                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFileFunctionsHardwareMonAndCompare::decryptMessageWithAES(const class FString& encryptedBase64Message, const class FString& keyIn256Bit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "decryptMessageWithAES");

	Params::FileFunctionsHardwareMonAndCompare_decryptMessageWithAES Parms{};

	Parms.encryptedBase64Message = std::move(encryptedBase64Message);
	Parms.keyIn256Bit = std::move(keyIn256Bit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.deleteDirectory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFileFunctionsHardwareMonAndCompare::deleteDirectory(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "deleteDirectory");

	Params::FileFunctionsHardwareMonAndCompare_deleteDirectory Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.deleteFile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFileFunctionsHardwareMonAndCompare::deleteFile(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "deleteFile");

	Params::FileFunctionsHardwareMonAndCompare_deleteFile Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.deleteFileAbsolutePath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFileFunctionsHardwareMonAndCompare::deleteFileAbsolutePath(const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "deleteFileAbsolutePath");

	Params::FileFunctionsHardwareMonAndCompare_deleteFileAbsolutePath Parms{};

	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.directoryExists
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFileFunctionsHardwareMonAndCompare::directoryExists(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "directoryExists");

	Params::FileFunctionsHardwareMonAndCompare_directoryExists Parms{};

	Parms.directoryType = directoryType;
	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.encryptMessageWithAES
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    keyIn256Bit                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFileFunctionsHardwareMonAndCompare::encryptMessageWithAES(const class FString& Message, const class FString& keyIn256Bit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "encryptMessageWithAES");

	Params::FileFunctionsHardwareMonAndCompare_encryptMessageWithAES Parms{};

	Parms.Message = std::move(Message);
	Parms.keyIn256Bit = std::move(keyIn256Bit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.fileExists
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFileFunctionsHardwareMonAndCompare::fileExists(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "fileExists");

	Params::FileFunctionsHardwareMonAndCompare_fileExists Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.fileExistsAbsolutePath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFileFunctionsHardwareMonAndCompare::fileExistsAbsolutePath(const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "fileExistsAbsolutePath");

	Params::FileFunctionsHardwareMonAndCompare_fileExistsAbsolutePath Parms{};

	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.fileSize
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UFileFunctionsHardwareMonAndCompare::fileSize(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "fileSize");

	Params::FileFunctionsHardwareMonAndCompare_fileSize Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.fileSizeAbsolutePath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UFileFunctionsHardwareMonAndCompare::fileSizeAbsolutePath(const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "fileSizeAbsolutePath");

	Params::FileFunctionsHardwareMonAndCompare_fileSizeAbsolutePath Parms{};

	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.fileToBase64String
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          base64String                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          Filename                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFileFunctionsHardwareMonAndCompare::fileToBase64String(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath, bool* success, class FString* base64String, class FString* Filename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "fileToBase64String");

	Params::FileFunctionsHardwareMonAndCompare_fileToBase64String Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (success != nullptr)
		*success = Parms.success;

	if (base64String != nullptr)
		*base64String = std::move(Parms.base64String);

	if (Filename != nullptr)
		*Filename = std::move(Parms.Filename);
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.getAccessTimeStamp
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UFileFunctionsHardwareMonAndCompare::getAccessTimeStamp(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "getAccessTimeStamp");

	Params::FileFunctionsHardwareMonAndCompare_getAccessTimeStamp Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.getAllFilesFromDirectory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  Count                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>*                  files                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FString>*                  filePaths                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// const class FString&                    FileType                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFileFunctionsHardwareMonAndCompare::getAllFilesFromDirectory(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath, int32* Count, TArray<class FString>* files, TArray<class FString>* filePaths, const class FString& FileType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "getAllFilesFromDirectory");

	Params::FileFunctionsHardwareMonAndCompare_getAllFilesFromDirectory Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);
	Parms.FileType = std::move(FileType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Count != nullptr)
		*Count = Parms.Count;

	if (files != nullptr)
		*files = std::move(Parms.files);

	if (filePaths != nullptr)
		*filePaths = std::move(Parms.filePaths);
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.getFileFunctionsHardwareMonAndCompareTarget
// (Final, Native, Static, Public)
// Parameters:
// class UFileFunctionsHardwareMonAndCompare*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFileFunctionsHardwareMonAndCompare* UFileFunctionsHardwareMonAndCompare::getFileFunctionsHardwareMonAndCompareTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "getFileFunctionsHardwareMonAndCompareTarget");

	Params::FileFunctionsHardwareMonAndCompare_getFileFunctionsHardwareMonAndCompareTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.getFilenameOnDisk
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFileFunctionsHardwareMonAndCompare::getFilenameOnDisk(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "getFilenameOnDisk");

	Params::FileFunctionsHardwareMonAndCompare_getFilenameOnDisk Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.getMD5FromFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          MD5                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFileFunctionsHardwareMonAndCompare::getMD5FromFile(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath, bool* success, class FString* MD5)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "getMD5FromFile");

	Params::FileFunctionsHardwareMonAndCompare_getMD5FromFile Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (success != nullptr)
		*success = Parms.success;

	if (MD5 != nullptr)
		*MD5 = std::move(Parms.MD5);
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.getMD5FromFileAbsolutePath
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          MD5                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFileFunctionsHardwareMonAndCompare::getMD5FromFileAbsolutePath(const class FString& FilePath, bool* success, class FString* MD5)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "getMD5FromFileAbsolutePath");

	Params::FileFunctionsHardwareMonAndCompare_getMD5FromFileAbsolutePath Parms{};

	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (success != nullptr)
		*success = Parms.success;

	if (MD5 != nullptr)
		*MD5 = std::move(Parms.MD5);
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.getTimeStamp
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UFileFunctionsHardwareMonAndCompare::getTimeStamp(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "getTimeStamp");

	Params::FileFunctionsHardwareMonAndCompare_getTimeStamp Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.int64ToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFileFunctionsHardwareMonAndCompare::int64ToString(int64 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "int64ToString");

	Params::FileFunctionsHardwareMonAndCompare_int64ToString Parms{};

	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.isReadOnly
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFileFunctionsHardwareMonAndCompare::isReadOnly(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "isReadOnly");

	Params::FileFunctionsHardwareMonAndCompare_isReadOnly Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.moveFile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryTypeTo                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    filePathTo                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryTypeFrom                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    filePathFrom                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFileFunctionsHardwareMonAndCompare::moveFile(EFileFunctionsHardwareMonAndCompareDirectoryType directoryTypeTo, const class FString& filePathTo, EFileFunctionsHardwareMonAndCompareDirectoryType directoryTypeFrom, const class FString& filePathFrom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "moveFile");

	Params::FileFunctionsHardwareMonAndCompare_moveFile Parms{};

	Parms.directoryTypeTo = directoryTypeTo;
	Parms.filePathTo = std::move(filePathTo);
	Parms.directoryTypeFrom = directoryTypeFrom;
	Parms.filePathFrom = std::move(filePathFrom);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.readBytesFromFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<uint8> UFileFunctionsHardwareMonAndCompare::readBytesFromFile(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "readBytesFromFile");

	Params::FileFunctionsHardwareMonAndCompare_readBytesFromFile Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (success != nullptr)
		*success = Parms.success;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.readStringFromFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          Data                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFileFunctionsHardwareMonAndCompare::readStringFromFile(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath, bool* success, class FString* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "readStringFromFile");

	Params::FileFunctionsHardwareMonAndCompare_readStringFromFile Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (success != nullptr)
		*success = Parms.success;

	if (Data != nullptr)
		*Data = std::move(Parms.Data);
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.setReadOnly
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewReadOnlyValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFileFunctionsHardwareMonAndCompare::setReadOnly(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath, bool bNewReadOnlyValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "setReadOnly");

	Params::FileFunctionsHardwareMonAndCompare_setReadOnly Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);
	Parms.bNewReadOnlyValue = bNewReadOnlyValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.setTimeStamp
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDateTime&                 DateTime                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFileFunctionsHardwareMonAndCompare::setTimeStamp(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath, const struct FDateTime& DateTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "setTimeStamp");

	Params::FileFunctionsHardwareMonAndCompare_setTimeStamp Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);
	Parms.DateTime = std::move(DateTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.stringToBase64String
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          base64String                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFileFunctionsHardwareMonAndCompare::stringToBase64String(const class FString& String, class FString* base64String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "stringToBase64String");

	Params::FileFunctionsHardwareMonAndCompare_stringToBase64String Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (base64String != nullptr)
		*base64String = std::move(Parms.base64String);
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.writeBytesToFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<uint8>&                    Bytes                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFileFunctionsHardwareMonAndCompare::writeBytesToFile(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& FilePath, const TArray<uint8>& Bytes, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "writeBytesToFile");

	Params::FileFunctionsHardwareMonAndCompare_writeBytesToFile Parms{};

	Parms.directoryType = directoryType;
	Parms.FilePath = std::move(FilePath);
	Parms.Bytes = std::move(Bytes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (success != nullptr)
		*success = Parms.success;
}


// Function HardwareMonAndCompare.FileFunctionsHardwareMonAndCompare.writeStringToFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EFileFunctionsHardwareMonAndCompareDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Data                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFileFunctionsHardwareMonAndCompareEncodingOptionsfileEncoding                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFileFunctionsHardwareMonAndCompare::writeStringToFile(EFileFunctionsHardwareMonAndCompareDirectoryType directoryType, const class FString& Data, const class FString& FilePath, EFileFunctionsHardwareMonAndCompareEncodingOptions fileEncoding, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FileFunctionsHardwareMonAndCompare", "writeStringToFile");

	Params::FileFunctionsHardwareMonAndCompare_writeStringToFile Parms{};

	Parms.directoryType = directoryType;
	Parms.Data = std::move(Data);
	Parms.FilePath = std::move(FilePath);
	Parms.fileEncoding = fileEncoding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (success != nullptr)
		*success = Parms.success;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.breakCPUStruct
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FCPUListStruct&            cpuStruct                                              (Parm, NativeAccessSpecifierPublic)
// class FString*                          Name_0                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          score                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          clock                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          cores                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareBPLibrary::breakCPUStruct(const struct FCPUListStruct& cpuStruct, class FString* Name_0, class FString* score, class FString* clock, class FString* cores)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "breakCPUStruct");

	Params::HardwareMonAndCompareBPLibrary_breakCPUStruct Parms{};

	Parms.cpuStruct = std::move(cpuStruct);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);

	if (score != nullptr)
		*score = std::move(Parms.score);

	if (clock != nullptr)
		*clock = std::move(Parms.clock);

	if (cores != nullptr)
		*cores = std::move(Parms.cores);
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.breakDriveInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSDriveInfo&               driveInfo                                              (Parm, NativeAccessSpecifierPublic)
// class FString*                          Name_0                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64*                                  totalBytes                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64*                                  freeBytes                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  totalMegabyte                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  freeMegabyte                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  totalGigabyte                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  freeGigabyte                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareBPLibrary::breakDriveInfo(const struct FSDriveInfo& driveInfo, class FString* Name_0, int64* totalBytes, int64* freeBytes, int32* totalMegabyte, int32* freeMegabyte, int32* totalGigabyte, int32* freeGigabyte)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "breakDriveInfo");

	Params::HardwareMonAndCompareBPLibrary_breakDriveInfo Parms{};

	Parms.driveInfo = std::move(driveInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);

	if (totalBytes != nullptr)
		*totalBytes = Parms.totalBytes;

	if (freeBytes != nullptr)
		*freeBytes = Parms.freeBytes;

	if (totalMegabyte != nullptr)
		*totalMegabyte = Parms.totalMegabyte;

	if (freeMegabyte != nullptr)
		*freeMegabyte = Parms.freeMegabyte;

	if (totalGigabyte != nullptr)
		*totalGigabyte = Parms.totalGigabyte;

	if (freeGigabyte != nullptr)
		*freeGigabyte = Parms.freeGigabyte;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.breakGPUStruct
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGPUListStruct&            gpuStruct                                              (Parm, NativeAccessSpecifierPublic)
// class FString*                          Name_0                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          score                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareBPLibrary::breakGPUStruct(const struct FGPUListStruct& gpuStruct, class FString* Name_0, class FString* score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "breakGPUStruct");

	Params::HardwareMonAndCompareBPLibrary_breakGPUStruct Parms{};

	Parms.gpuStruct = std::move(gpuStruct);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);

	if (score != nullptr)
		*score = std::move(Parms.score);
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getCPUInfoFromList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    cpuName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          Name_0                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  score                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          defaultClock                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  cores                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareBPLibrary::getCPUInfoFromList(const class FString& cpuName, bool* found, class FString* Name_0, float* score, class FString* defaultClock, int32* cores)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getCPUInfoFromList");

	Params::HardwareMonAndCompareBPLibrary_getCPUInfoFromList Parms{};

	Parms.cpuName = std::move(cpuName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (found != nullptr)
		*found = Parms.found;

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);

	if (score != nullptr)
		*score = Parms.score;

	if (defaultClock != nullptr)
		*defaultClock = std::move(Parms.defaultClock);

	if (cores != nullptr)
		*cores = Parms.cores;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getCPUInfoFromListPure
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    cpuName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          Name_0                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  score                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          defaultClock                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  cores                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareBPLibrary::getCPUInfoFromListPure(const class FString& cpuName, bool* found, class FString* Name_0, float* score, class FString* defaultClock, int32* cores)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getCPUInfoFromListPure");

	Params::HardwareMonAndCompareBPLibrary_getCPUInfoFromListPure Parms{};

	Parms.cpuName = std::move(cpuName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (found != nullptr)
		*found = Parms.found;

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);

	if (score != nullptr)
		*score = Parms.score;

	if (defaultClock != nullptr)
		*defaultClock = std::move(Parms.defaultClock);

	if (cores != nullptr)
		*cores = Parms.cores;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getCPUList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<struct FCPUListStruct>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCPUListStruct> UHardwareMonAndCompareBPLibrary::getCPUList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getCPUList");

	Params::HardwareMonAndCompareBPLibrary_getCPUList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getCPUListPure
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<struct FCPUListStruct>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCPUListStruct> UHardwareMonAndCompareBPLibrary::getCPUListPure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getCPUListPure");

	Params::HardwareMonAndCompareBPLibrary_getCPUListPure Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getCPUUsage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TMap<int32, int32>                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<int32, int32> UHardwareMonAndCompareBPLibrary::getCPUUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getCPUUsage");

	Params::HardwareMonAndCompareBPLibrary_getCPUUsage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getDriveInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FSDriveInfo>*             driveInfo                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareBPLibrary::getDriveInfo(TArray<struct FSDriveInfo>* driveInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getDriveInfo");

	Params::HardwareMonAndCompareBPLibrary_getDriveInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (driveInfo != nullptr)
		*driveInfo = std::move(Parms.driveInfo);
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getDriveInfoPure
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FSDriveInfo>*             driveInfo                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareBPLibrary::getDriveInfoPure(TArray<struct FSDriveInfo>* driveInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getDriveInfoPure");

	Params::HardwareMonAndCompareBPLibrary_getDriveInfoPure Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (driveInfo != nullptr)
		*driveInfo = std::move(Parms.driveInfo);
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getFullHardwareInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TMap<class FString, class FString>      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FString, class FString> UHardwareMonAndCompareBPLibrary::getFullHardwareInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getFullHardwareInfo");

	Params::HardwareMonAndCompareBPLibrary_getFullHardwareInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getGPUInfoFromList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    gpuName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          Name_0                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  score                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareBPLibrary::getGPUInfoFromList(const class FString& gpuName, bool* found, class FString* Name_0, float* score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getGPUInfoFromList");

	Params::HardwareMonAndCompareBPLibrary_getGPUInfoFromList Parms{};

	Parms.gpuName = std::move(gpuName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (found != nullptr)
		*found = Parms.found;

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);

	if (score != nullptr)
		*score = Parms.score;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getGPUInfoFromListPure
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    gpuName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          Name_0                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  score                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareBPLibrary::getGPUInfoFromListPure(const class FString& gpuName, bool* found, class FString* Name_0, float* score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getGPUInfoFromListPure");

	Params::HardwareMonAndCompareBPLibrary_getGPUInfoFromListPure Parms{};

	Parms.gpuName = std::move(gpuName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (found != nullptr)
		*found = Parms.found;

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);

	if (score != nullptr)
		*score = Parms.score;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getGPUList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<struct FGPUListStruct>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGPUListStruct> UHardwareMonAndCompareBPLibrary::getGPUList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getGPUList");

	Params::HardwareMonAndCompareBPLibrary_getGPUList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getGPUListPure
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<struct FGPUListStruct>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGPUListStruct> UHardwareMonAndCompareBPLibrary::getGPUListPure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getGPUListPure");

	Params::HardwareMonAndCompareBPLibrary_getGPUListPure Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getGPUUsage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHardwareMonAndCompareBPLibrary::getGPUUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getGPUUsage");

	Params::HardwareMonAndCompareBPLibrary_getGPUUsage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getHardwareInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EHardwareInfo                           part                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UHardwareMonAndCompareBPLibrary::getHardwareInfo(EHardwareInfo part)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getHardwareInfo");

	Params::HardwareMonAndCompareBPLibrary_getHardwareInfo Parms{};

	Parms.part = part;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getHardwareInfoPure
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EHardwareInfo                           part                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UHardwareMonAndCompareBPLibrary::getHardwareInfoPure(EHardwareInfo part)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getHardwareInfoPure");

	Params::HardwareMonAndCompareBPLibrary_getHardwareInfoPure Parms{};

	Parms.part = part;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getHardwareMonAndCompareLib
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UHardwareMonAndCompareBPLibrary*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHardwareMonAndCompareBPLibrary* UHardwareMonAndCompareBPLibrary::getHardwareMonAndCompareLib()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getHardwareMonAndCompareLib");

	Params::HardwareMonAndCompareBPLibrary_getHardwareMonAndCompareLib Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getRamFreeByte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UHardwareMonAndCompareBPLibrary::getRamFreeByte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getRamFreeByte");

	Params::HardwareMonAndCompareBPLibrary_getRamFreeByte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getRamFreeGigabyte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHardwareMonAndCompareBPLibrary::getRamFreeGigabyte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getRamFreeGigabyte");

	Params::HardwareMonAndCompareBPLibrary_getRamFreeGigabyte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getRamFreeMegabyte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHardwareMonAndCompareBPLibrary::getRamFreeMegabyte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getRamFreeMegabyte");

	Params::HardwareMonAndCompareBPLibrary_getRamFreeMegabyte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getRamTotalByte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UHardwareMonAndCompareBPLibrary::getRamTotalByte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getRamTotalByte");

	Params::HardwareMonAndCompareBPLibrary_getRamTotalByte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getRamTotalGigabyte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHardwareMonAndCompareBPLibrary::getRamTotalGigabyte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getRamTotalGigabyte");

	Params::HardwareMonAndCompareBPLibrary_getRamTotalGigabyte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getRamTotalMegabyte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHardwareMonAndCompareBPLibrary::getRamTotalMegabyte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getRamTotalMegabyte");

	Params::HardwareMonAndCompareBPLibrary_getRamTotalMegabyte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getRamUsedByte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UHardwareMonAndCompareBPLibrary::getRamUsedByte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getRamUsedByte");

	Params::HardwareMonAndCompareBPLibrary_getRamUsedByte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getRamUsedGigabyte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHardwareMonAndCompareBPLibrary::getRamUsedGigabyte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getRamUsedGigabyte");

	Params::HardwareMonAndCompareBPLibrary_getRamUsedGigabyte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getRamUsedMegabyte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHardwareMonAndCompareBPLibrary::getRamUsedMegabyte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getRamUsedMegabyte");

	Params::HardwareMonAndCompareBPLibrary_getRamUsedMegabyte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getVramFreeByte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UHardwareMonAndCompareBPLibrary::getVramFreeByte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getVramFreeByte");

	Params::HardwareMonAndCompareBPLibrary_getVramFreeByte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getVramFreeGigabyte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHardwareMonAndCompareBPLibrary::getVramFreeGigabyte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getVramFreeGigabyte");

	Params::HardwareMonAndCompareBPLibrary_getVramFreeGigabyte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getVramFreeMegabyte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHardwareMonAndCompareBPLibrary::getVramFreeMegabyte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getVramFreeMegabyte");

	Params::HardwareMonAndCompareBPLibrary_getVramFreeMegabyte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getVramTotalByte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UHardwareMonAndCompareBPLibrary::getVramTotalByte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getVramTotalByte");

	Params::HardwareMonAndCompareBPLibrary_getVramTotalByte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getVramTotalGigabyte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHardwareMonAndCompareBPLibrary::getVramTotalGigabyte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getVramTotalGigabyte");

	Params::HardwareMonAndCompareBPLibrary_getVramTotalGigabyte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getVramTotalMegabyte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHardwareMonAndCompareBPLibrary::getVramTotalMegabyte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getVramTotalMegabyte");

	Params::HardwareMonAndCompareBPLibrary_getVramTotalMegabyte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getVramUsedByte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UHardwareMonAndCompareBPLibrary::getVramUsedByte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getVramUsedByte");

	Params::HardwareMonAndCompareBPLibrary_getVramUsedByte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getVramUsedGigabyte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHardwareMonAndCompareBPLibrary::getVramUsedGigabyte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getVramUsedGigabyte");

	Params::HardwareMonAndCompareBPLibrary_getVramUsedGigabyte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.getVramUsedMegabyte
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHardwareMonAndCompareBPLibrary::getVramUsedMegabyte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "getVramUsedMegabyte");

	Params::HardwareMonAndCompareBPLibrary_getVramUsedMegabyte Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.launchProcess
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          internalProcessID                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    executableFile                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHardwareMonAndCompareProcessDirectoryTypedirectoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Parameters                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    inHidden                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHardwareMonAndCompareProcessObject*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHardwareMonAndCompareProcessObject* UHardwareMonAndCompareBPLibrary::launchProcess(bool* success, class FString* internalProcessID, const class FString& executableFile, EHardwareMonAndCompareProcessDirectoryType directoryType, const class FString& Parameters, bool inHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "launchProcess");

	Params::HardwareMonAndCompareBPLibrary_launchProcess Parms{};

	Parms.executableFile = std::move(executableFile);
	Parms.directoryType = directoryType;
	Parms.Parameters = std::move(Parameters);
	Parms.inHidden = inHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (success != nullptr)
		*success = Parms.success;

	if (internalProcessID != nullptr)
		*internalProcessID = std::move(Parms.internalProcessID);

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.openFileDialog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EHardwareMonAndCompareFilaDialogType    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHardwareMonAndCompareFilaDialogInitDirTypeinitialDirectoryType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    initialDirectory                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHardwareMonAndCompareBPLibrary*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHardwareMonAndCompareBPLibrary* UHardwareMonAndCompareBPLibrary::openFileDialog(EHardwareMonAndCompareFilaDialogType Type, EHardwareMonAndCompareFilaDialogInitDirType initialDirectoryType, const class FString& initialDirectory, const class FString& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "openFileDialog");

	Params::HardwareMonAndCompareBPLibrary_openFileDialog Parms{};

	Parms.Type = Type;
	Parms.initialDirectoryType = initialDirectoryType;
	Parms.initialDirectory = std::move(initialDirectory);
	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.startCPU_GPUUsageReader
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UHardwareMonAndCompareBPLibrary*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHardwareMonAndCompareBPLibrary* UHardwareMonAndCompareBPLibrary::startCPU_GPUUsageReader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "startCPU_GPUUsageReader");

	Params::HardwareMonAndCompareBPLibrary_startCPU_GPUUsageReader Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.stopAllProcesses
// (Final, Native, Static, Public, BlueprintCallable)

void UHardwareMonAndCompareBPLibrary::stopAllProcesses()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "stopAllProcesses");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.stopCPU_GPUUsageReader
// (Final, Native, Static, Public, BlueprintCallable)

void UHardwareMonAndCompareBPLibrary::stopCPU_GPUUsageReader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "stopCPU_GPUUsageReader");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.stopProcess
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    internalProcessID                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareBPLibrary::stopProcess(bool* success, const class FString& internalProcessID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HardwareMonAndCompareBPLibrary", "stopProcess");

	Params::HardwareMonAndCompareBPLibrary_stopProcess Parms{};

	Parms.internalProcessID = std::move(internalProcessID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (success != nullptr)
		*success = Parms.success;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.fileDialogEventDelegate
// (Final, Native, Public)
// Parameters:
// const class FString&                    absoluteDir                                            (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareBPLibrary::fileDialogEventDelegate(const class FString& absoluteDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HardwareMonAndCompareBPLibrary", "fileDialogEventDelegate");

	Params::HardwareMonAndCompareBPLibrary_fileDialogEventDelegate Parms{};

	Parms.absoluteDir = std::move(absoluteDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.powershellProcessEventCPUThread
// (Final, Native, Private)
// Parameters:
// const class FString&                    Data                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareBPLibrary::powershellProcessEventCPUThread(const class FString& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HardwareMonAndCompareBPLibrary", "powershellProcessEventCPUThread");

	Params::HardwareMonAndCompareBPLibrary_powershellProcessEventCPUThread Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.powershellProcessEventFileDialogThread
// (Final, Native, Private)
// Parameters:
// const class FString&                    Data                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareBPLibrary::powershellProcessEventFileDialogThread(const class FString& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HardwareMonAndCompareBPLibrary", "powershellProcessEventFileDialogThread");

	Params::HardwareMonAndCompareBPLibrary_powershellProcessEventFileDialogThread Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.powershellProcessEventGPUThread
// (Final, Native, Private)
// Parameters:
// const class FString&                    Data                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareBPLibrary::powershellProcessEventGPUThread(const class FString& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HardwareMonAndCompareBPLibrary", "powershellProcessEventGPUThread");

	Params::HardwareMonAndCompareBPLibrary_powershellProcessEventGPUThread Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.startCPU_GPUUsageReaderEventDelegate
// (Final, Native, Public)

void UHardwareMonAndCompareBPLibrary::startCPU_GPUUsageReaderEventDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HardwareMonAndCompareBPLibrary", "startCPU_GPUUsageReaderEventDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareBPLibrary.tickEventDelegate
// (Final, Native, Public)
// Parameters:
// const float                             FrameTime                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareBPLibrary::tickEventDelegate(const float FrameTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HardwareMonAndCompareBPLibrary", "tickEventDelegate");

	Params::HardwareMonAndCompareBPLibrary_tickEventDelegate Parms{};

	Parms.FrameTime = FrameTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareGraphWidget.RefreshGraph
// (Final, Native, Public, BlueprintCallable)

void UHardwareMonAndCompareGraphWidget::RefreshGraph()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HardwareMonAndCompareGraphWidget", "RefreshGraph");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareGraphWidget.tickEventDelegate
// (Final, Native, Public)
// Parameters:
// float                                   FrameTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareGraphWidget::tickEventDelegate(float FrameTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HardwareMonAndCompareGraphWidget", "tickEventDelegate");

	Params::HardwareMonAndCompareGraphWidget_tickEventDelegate Parms{};

	Parms.FrameTime = FrameTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareProcessObject.HardwareMonitorProcessEvent
// (Final, Native, Public)
// Parameters:
// const class FString&                    internalProcessID                                      (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Output                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareProcessObject::HardwareMonitorProcessEvent(const class FString& internalProcessID, const class FString& Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HardwareMonAndCompareProcessObject", "HardwareMonitorProcessEvent");

	Params::HardwareMonAndCompareProcessObject_HardwareMonitorProcessEvent Parms{};

	Parms.internalProcessID = std::move(internalProcessID);
	Parms.Output = std::move(Output);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareProcessObject.processOutput
// (Final, Native, Public)
// Parameters:
// const class FString&                    Data                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareProcessObject::processOutput(const class FString& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HardwareMonAndCompareProcessObject", "processOutput");

	Params::HardwareMonAndCompareProcessObject_processOutput Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HardwareMonAndCompare.HardwareMonAndCompareWidget.tickEventDelegate
// (Final, Native, Public)
// Parameters:
// float                                   FrameTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHardwareMonAndCompareWidget::tickEventDelegate(float FrameTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HardwareMonAndCompareWidget", "tickEventDelegate");

	Params::HardwareMonAndCompareWidget_tickEventDelegate Parms{};

	Parms.FrameTime = FrameTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

