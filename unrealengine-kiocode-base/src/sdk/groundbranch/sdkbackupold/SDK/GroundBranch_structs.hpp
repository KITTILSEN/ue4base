#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GroundBranch

#include "Basic.hpp"

#include "ControlRig_structs.hpp"
#include "InputCore_structs.hpp"
#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "PhysicsCore_structs.hpp"


namespace SDK
{

// Enum GroundBranch.EAIGoCodes
// NumValues: 0x0006
enum class EAIGoCodes : uint8
{
	None                                     = 0,
	Alpha                                    = 1,
	Bravo                                    = 2,
	Charlie                                  = 3,
	Delta                                    = 4,
	EAIGoCodes_MAX                           = 5,
};

// Enum GroundBranch.EAIRulesEngage
// NumValues: 0x0007
enum class EAIRulesEngage : uint8
{
	Hold                                     = 0,
	Advance                                  = 1,
	ForceAdvance                             = 2,
	Assault                                  = 3,
	Suppress                                 = 4,
	Recon                                    = 5,
	MAX                                      = 6,
};

// Enum GroundBranch.EGBAICommands
// NumValues: 0x0008
enum class EGBAICommands : uint8
{
	Hold                                     = 0,
	MoveTo                                   = 1,
	TakeCover                                = 2,
	FallIn                                   = 3,
	ActiveCombat                             = 4,
	PassiveCombat                            = 5,
	Breach                                   = 6,
	EGBAICommands_MAX                        = 7,
};

// Enum GroundBranch.EGBAIUsableActorState
// NumValues: 0x0007
enum class EGBAIUsableActorState : uint8
{
	NotUsing                                 = 0,
	WaitingToUse                             = 1,
	PreparingToUse                           = 2,
	Using                                    = 3,
	EndingUse                                = 4,
	Finished                                 = 5,
	EGBAIUsableActorState_MAX                = 6,
};

// Enum GroundBranch.EGBAIEquippedType
// NumValues: 0x0008
enum class EGBAIEquippedType : uint8
{
	None                                     = 0,
	Melee                                    = 1,
	Primary                                  = 2,
	Sidearm                                  = 3,
	Grenade                                  = 4,
	Equipment                                = 5,
	Other                                    = 6,
	EGBAIEquippedType_MAX                    = 7,
};

// Enum GroundBranch.EGBSuppressionLevel
// NumValues: 0x0005
enum class EGBSuppressionLevel : uint8
{
	None                                     = 0,
	Light                                    = 1,
	Medium                                   = 2,
	Heavy                                    = 3,
	EGBSuppressionLevel_MAX                  = 4,
};

// Enum GroundBranch.EGBGuardPointType
// NumValues: 0x0005
enum class EGBGuardPointType : uint8
{
	Generic                                  = 0,
	ActionAnimation                          = 1,
	GuardingWindow                           = 2,
	GuardingDoor                             = 3,
	EGBGuardPointType_MAX                    = 4,
};

// Enum GroundBranch.EGBAIState
// NumValues: 0x0008
enum class EGBAIState : uint8
{
	Idle                                     = 0,
	Patrol                                   = 1,
	Guard                                    = 2,
	Search                                   = 3,
	Attack                                   = 4,
	Flee                                     = 5,
	FollowLeader                             = 6,
	EGBAIState_MAX                           = 7,
};

// Enum GroundBranch.EGBAmmoPouchModularity
// NumValues: 0x0004
enum class EGBAmmoPouchModularity : uint8
{
	None                                     = 0,
	Small                                    = 1,
	Large                                    = 2,
	EGBAmmoPouchModularity_MAX               = 3,
};

// Enum GroundBranch.EGBInvItemTagsCheckType
// NumValues: 0x0006
enum class EGBInvItemTagsCheckType : uint8
{
	HasAllExact                              = 0,
	HasAll                                   = 1,
	HasAnyExact                              = 2,
	HasAny                                   = 3,
	None                                     = 4,
	EGBInvItemTagsCheckType_MAX              = 5,
};

// Enum GroundBranch.EGBDeathState
// NumValues: 0x0004
enum class EGBDeathState : uint8
{
	NotDead                                  = 0,
	DeathStarted                             = 1,
	DeathFinished                            = 2,
	EGBDeathState_MAX                        = 3,
};

// Enum GroundBranch.EGBCustomMovementMode
// NumValues: 0x0005
enum class EGBCustomMovementMode : uint8
{
	CUSTOMMOVE_None                          = 0,
	CUSTOMMOVE_Ladder                        = 1,
	CUSTOMMOVE_Mantle                        = 2,
	CUSTOMMOVE_Bracing                       = 3,
	CUSTOMMOVE_MAX                           = 4,
};

// Enum GroundBranch.EGBAnimRootYawOffsetMode
// NumValues: 0x0004
enum class EGBAnimRootYawOffsetMode : uint8
{
	BlendOut                                 = 0,
	Hold                                     = 1,
	Accumulate                               = 2,
	EGBAnimRootYawOffsetMode_MAX             = 3,
};

// Enum GroundBranch.EGBAnimDirection
// NumValues: 0x0009
enum class EGBAnimDirection : uint8
{
	Forward                                  = 0,
	ForwardLeft                              = 1,
	ForwardRight                             = 2,
	Backward                                 = 3,
	BackwardLeft                             = 4,
	BackwardRight                            = 5,
	Left                                     = 6,
	Right                                    = 7,
	EGBAnimDirection_MAX                     = 8,
};

// Enum GroundBranch.EGBAnimCoverStatus
// NumValues: 0x0005
enum class EGBAnimCoverStatus : uint8
{
	InCover                                  = 0,
	OutOfCover                               = 1,
	GoingIntoCover                           = 2,
	GoingOutOfCover                          = 3,
	EGBAnimCoverStatus_MAX                   = 4,
};

// Enum GroundBranch.EGBAnimCoverType
// NumValues: 0x0006
enum class EGBAnimCoverType : uint8
{
	LeftStanding                             = 0,
	LeftCrouching                            = 1,
	RightStanding                            = 2,
	RightCrouching                           = 3,
	PopUp                                    = 4,
	EGBAnimCoverType_MAX                     = 5,
};

// Enum GroundBranch.ETakeHitFlags
// NumValues: 0x0003
enum class ETakeHitFlags : uint8
{
	None                                     = 0,
	Exit                                     = 1,
	ETakeHitFlags_MAX                        = 2,
};

// Enum GroundBranch.EGBWeaponPosition
// NumValues: 0x0007
enum class EGBWeaponPosition : uint8
{
	Ready                                    = 0,
	Engaged                                  = 1,
	LowReady                                 = 2,
	HighReady                                = 3,
	ObstructedLow                            = 4,
	ObstructedHigh                           = 5,
	EGBWeaponPosition_MAX                    = 6,
};

// Enum GroundBranch.EGrenadeSwitch
// NumValues: 0x0003
enum class EGrenadeSwitch : uint8
{
	PrevItem                                 = 0,
	EmptyHands                               = 1,
	EGrenadeSwitch_MAX                       = 2,
};

// Enum GroundBranch.EHandsRequired
// NumValues: 0x0006
enum class EHandsRequired : uint8
{
	Both                                     = 0,
	Main                                     = 1,
	Off                                      = 2,
	Left                                     = 3,
	Right                                    = 4,
	EHandsRequired_MAX                       = 5,
};

// Enum GroundBranch.EGBInputId
// NumValues: 0x0021
enum class EGBInputId : uint8
{
	None                                     = 0,
	Jump                                     = 1,
	Crouch                                   = 2,
	Prone                                    = 3,
	Run                                      = 4,
	Sprint                                   = 5,
	UseMainHand                              = 6,
	UseOffHand                               = 7,
	FreeLook                                 = 8,
	LeanLeft                                 = 9,
	LeanRight                                = 10,
	Interact                                 = 11,
	Focus                                    = 12,
	NextPos                                  = 13,
	PrevPos                                  = 14,
	Reload                                   = 15,
	ChangeFiringMode                         = 16,
	FirearmAttachment                        = 17,
	MissionIntel                             = 18,
	IncreaseSightMagnification               = 19,
	DecreaseSightMagnification               = 20,
	IncreaseReticleBrightnessLevel           = 21,
	DecreaseReticleBrightnessLevel           = 22,
	CycleReticleColour                       = 23,
	ToggleNightVision                        = 24,
	Drop                                     = 25,
	IRLightSource                            = 26,
	LightSource                              = 27,
	Laser                                    = 28,
	ChangeLaserMode                          = 29,
	CommandMenu                              = 30,
	ChangeIRLightSourceMode                  = 31,
	EGBInputId_MAX                           = 32,
};

// Enum GroundBranch.EHand
// NumValues: 0x0006
enum class EHand : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Main                                     = 2,
	Off                                      = 3,
	Unknown                                  = 4,
	EHand_MAX                                = 5,
};

// Enum GroundBranch.ESeason
// NumValues: 0x0006
enum class ESeason : uint8
{
	Spring                                   = 0,
	Summer                                   = 1,
	Autumn                                   = 2,
	Winter                                   = 3,
	Count                                    = 4,
	ESeason_MAX                              = 5,
};

// Enum GroundBranch.EGBMessageDialogType
// NumValues: 0x0004
enum class EGBMessageDialogType : uint8
{
	Ok                                       = 0,
	OkCancel                                 = 1,
	YesNo                                    = 2,
	EGBMessageDialogType_MAX                 = 3,
};

// Enum GroundBranch.EGBAdjoiningDoorBehaviour
// NumValues: 0x0005
enum class EGBAdjoiningDoorBehaviour : uint8
{
	None                                     = 0,
	OpenClose                                = 1,
	OpenOnly                                 = 2,
	TogglePhysics                            = 3,
	EGBAdjoiningDoorBehaviour_MAX            = 4,
};

// Enum GroundBranch.EGBPlayerRelativeSwingDir
// NumValues: 0x0004
enum class EGBPlayerRelativeSwingDir : uint8
{
	Unknown                                  = 0,
	Open                                     = 1,
	Close                                    = 2,
	EGBPlayerRelativeSwingDir_MAX            = 3,
};

// Enum GroundBranch.EGBDoorSwingDirection
// NumValues: 0x0003
enum class EGBDoorSwingDirection : uint8
{
	CounterClockWise                         = 0,
	ClockWise                                = 1,
	EGBDoorSwingDirection_MAX                = 2,
};

// Enum GroundBranch.ESearchFix
// NumValues: 0x0005
enum class ESearchFix : uint8
{
	Underscore                               = 0,
	Prefix                                   = 1,
	Suffix                                   = 2,
	None                                     = 3,
	ESearchFix_MAX                           = 4,
};

// Enum GroundBranch.EGBResurrectResult
// NumValues: 0x0004
enum class EGBResurrectResult : uint8
{
	Invalid                                  = 0,
	Failed                                   = 1,
	Succeeded                                = 2,
	EGBResurrectResult_MAX                   = 3,
};

// Enum GroundBranch.EGBResurrectType
// NumValues: 0x0004
enum class EGBResurrectType : uint8
{
	InSitu                                   = 0,
	NearestPlayer                            = 1,
	AtInvoker                                = 2,
	EGBResurrectType_MAX                     = 3,
};

// Enum GroundBranch.EGBMatchType
// NumValues: 0x0008
enum class EGBMatchType : uint8
{
	Continuous                               = 0,
	BestOf                                   = 1,
	FirstTo                                  = 2,
	Play                                     = 3,
	PlayUntilWin                             = 4,
	TimeLimit                                = 5,
	Invalid                                  = 6,
	EGBMatchType_MAX                         = 7,
};

// Enum GroundBranch.EGBGameModeType
// NumValues: 0x0007
enum class EGBGameModeType : uint8
{
	Unknown                                  = 0,
	Training                                 = 1,
	PvE                                      = 2,
	PvP                                      = 3,
	PvP_FFA                                  = 4,
	Mission                                  = 5,
	EGBGameModeType_MAX                      = 6,
};

// Enum GroundBranch.EWatchConfigFlags
// NumValues: 0x0006
enum class EWatchConfigFlags : uint8
{
	bNoFlags                                 = 0,
	bDisplayBearing                          = 1,
	bDisplayDistance                         = 2,
	bDisplayUpDown                           = 4,
	bMeasure2D                               = 8,
	EWatchConfigFlags_MAX                    = 9,
};

// Enum GroundBranch.EWatchMode
// NumValues: 0x0004
enum class EWatchMode : uint8
{
	Time                                     = 0,
	ObjectiveFinder                          = 1,
	IntelRetrieval                           = 2,
	EWatchMode_MAX                           = 3,
};

// Enum GroundBranch.EPlayerSortBy
// NumValues: 0x0005
enum class EPlayerSortBy : uint8
{
	Skip                                     = 0,
	Random                                   = 1,
	Name                                     = 2,
	Lives                                    = 3,
	EPlayerSortBy_MAX                        = 4,
};

// Enum GroundBranch.EGBGameObjectiveType
// NumValues: 0x0003
enum class EGBGameObjectiveType : uint8
{
	Primary                                  = 0,
	Secondary                                = 1,
	EGBGameObjectiveType_MAX                 = 2,
};

// Enum GroundBranch.EBPInputEvent
// NumValues: 0x0006
enum class EBPInputEvent : uint8
{
	Pressed                                  = 0,
	Released                                 = 1,
	Repeat                                   = 2,
	DoubleClick                              = 3,
	Axis                                     = 4,
	MAX                                      = 5,
};

// Enum GroundBranch.EGBInvItemPickupShape
// NumValues: 0x0004
enum class EGBInvItemPickupShape : uint8
{
	Box                                      = 0,
	Sphere                                   = 1,
	Capsule                                  = 2,
	EGBInvItemPickupShape_MAX                = 3,
};

// Enum GroundBranch.EGBEncodeDecodeKitResult
// NumValues: 0x0004
enum class EGBEncodeDecodeKitResult : uint8
{
	Failed                                   = 0,
	Skipped                                  = 1,
	Succeeded                                = 2,
	EGBEncodeDecodeKitResult_MAX             = 3,
};

// Enum GroundBranch.EGBAutoBalanceType
// NumValues: 0x0005
enum class EGBAutoBalanceType : uint8
{
	None                                     = 0,
	LightTouch                               = 1,
	Aggressive                               = 2,
	Always                                   = 3,
	EGBAutoBalanceType_MAX                   = 4,
};

// Enum GroundBranch.EGBMissionObjectiveStatusUpdateType
// NumValues: 0x0004
enum class EGBMissionObjectiveStatusUpdateType : uint8
{
	StatusChanged                            = 0,
	TimedEvent                               = 1,
	SubObjectiveCompleted                    = 2,
	EGBMissionObjectiveStatusUpdateType_MAX  = 3,
};

// Enum GroundBranch.EGBMissionObjectiveStatus
// NumValues: 0x0006
enum class EGBMissionObjectiveStatus : uint8
{
	Inactive                                 = 0,
	Active                                   = 1,
	PartiallyComplete                        = 2,
	Failed                                   = 3,
	Completed                                = 4,
	EGBMissionObjectiveStatus_MAX            = 5,
};

// Enum GroundBranch.EGBOperatorSpecialisation
// NumValues: 0x0005
enum class EGBOperatorSpecialisation : uint8
{
	Assault                                  = 0,
	Marksman                                 = 1,
	Breacher                                 = 2,
	AutomaticGunner                          = 3,
	EGBOperatorSpecialisation_MAX            = 4,
};

// Enum GroundBranch.EGBDefaultFirearmPosition
// NumValues: 0x0005
enum class EGBDefaultFirearmPosition : uint8
{
	LowReady                                 = 0,
	HighReady                                = 1,
	Ready                                    = 2,
	Engaged                                  = 3,
	EGBDefaultFirearmPosition_MAX            = 4,
};

// Enum GroundBranch.EGBProneYawLimitHandling
// NumValues: 0x0004
enum class EGBProneYawLimitHandling : uint8
{
	HardLimit                                = 0,
	SoftLimit                                = 1,
	TransitionToView                         = 2,
	EGBProneYawLimitHandling_MAX             = 3,
};

// Enum GroundBranch.EAlertLevel
// NumValues: 0x0005
enum class EAlertLevel : uint8
{
	NoAlert                                  = 0,
	DefenderInRange                          = 1,
	AttackerInRange                          = 2,
	AttackerCapturing                        = 3,
	EAlertLevel_MAX                          = 4,
};

// Enum GroundBranch.EReadyRoomStatus
// NumValues: 0x0004
enum class EReadyRoomStatus : uint8
{
	Unknown                                  = 0,
	InReadyRoom                              = 1,
	InPlayArea                               = 2,
	EReadyRoomStatus_MAX                     = 3,
};

// Enum GroundBranch.ERailMountValidation
// NumValues: 0x0006
enum class ERailMountValidation : uint8
{
	Ok                                       = 0,
	AcrossTooManyRails                       = 1,
	NotEnoughMountPoints                     = 2,
	TooFarBack                               = 3,
	TooFarForward                            = 4,
	Max                                      = 5,
};

// Enum GroundBranch.EGBIntelSearchType
// NumValues: 0x0003
enum class EGBIntelSearchType : uint8
{
	Drawers                                  = 0,
	Device                                   = 1,
	EGBIntelSearchType_MAX                   = 2,
};

// Enum GroundBranch.ESightType
// NumValues: 0x0007
enum class ESightType : uint8
{
	FailSafe                                 = 0,
	IronSight                                = 1,
	RedDot                                   = 2,
	Optical                                  = 3,
	PostModifier                             = 4,
	PreModifier                              = 5,
	ESightType_MAX                           = 6,
};

// Enum GroundBranch.EGBTimeSpanBlendType
// NumValues: 0x0004
enum class EGBTimeSpanBlendType : uint8
{
	Normal                                   = 0,
	Linear                                   = 1,
	Hard                                     = 2,
	EGBTimeSpanBlendType_MAX                 = 3,
};

// Enum GroundBranch.EGroundCoverType
// NumValues: 0x0004
enum class EGroundCoverType : uint8
{
	Dry                                      = 0,
	Wet                                      = 1,
	Snowy                                    = 2,
	EGroundCoverType_MAX                     = 3,
};

// Enum GroundBranch.EMissionTimeLabel
// NumValues: 0x0013
enum class EMissionTimeLabel : uint8
{
	PreDawn                                  = 0,
	Sunrise                                  = 1,
	PostSunrise                              = 2,
	EarlyMorning                             = 3,
	MidMorning                               = 4,
	LateMorning                              = 5,
	Midday                                   = 6,
	EarlyAfternoon                           = 7,
	MidAfternoon                             = 8,
	LateAfternoon                            = 9,
	PreSunset                                = 10,
	Sunset                                   = 11,
	PostSunset                               = 12,
	Evening                                  = 13,
	LateEvening                              = 14,
	Midnight                                 = 15,
	EarlyHours                               = 16,
	Custom                                   = 17,
	EMissionTimeLabel_MAX                    = 18,
};

// Enum GroundBranch.EGBPlayerInteractionStatus
// NumValues: 0x0004
enum class EGBPlayerInteractionStatus : uint8
{
	None                                     = 0,
	ControllingOther                         = 1,
	ControlledByOther                        = 2,
	EGBPlayerInteractionStatus_MAX           = 3,
};

// Enum GroundBranch.EGBPlayerStance
// NumValues: 0x0004
enum class EGBPlayerStance : uint8
{
	Upright                                  = 0,
	Crouched                                 = 1,
	Prone                                    = 2,
	EGBPlayerStance_MAX                      = 3,
};

// Enum GroundBranch.EReadyStatus
// NumValues: 0x0004
enum class EReadyStatus : uint8
{
	NotReady                                 = 0,
	WaitingToReadyUp                         = 1,
	DeclaredReady                            = 2,
	EReadyStatus_MAX                         = 3,
};

// Enum GroundBranch.ETeamElement
// NumValues: 0x0005
enum class ETeamElement : uint8
{
	Alpha                                    = 0,
	Bravo                                    = 1,
	Charlie                                  = 2,
	Delta                                    = 3,
	ETeamElement_MAX                         = 4,
};

// Enum GroundBranch.EGBLocalisedGameplayTagFormat
// NumValues: 0x0006
enum class EGBLocalisedGameplayTagFormat : uint8
{
	AsWritten                                = 0,
	AllUpper                                 = 1,
	AllLower                                 = 2,
	CapitaliseFirst                          = 3,
	CapitaliseAll                            = 4,
	EGBLocalisedGameplayTagFormat_MAX        = 5,
};

// Enum GroundBranch.EVOIPType
// NumValues: 0x0005
enum class EVOIPType : uint8
{
	None                                     = 0,
	GlobalVoice                              = 1,
	LocalVoice                               = 2,
	Radio                                    = 3,
	EVOIPType_MAX                            = 4,
};

// Enum GroundBranch.ESpeedUnit
// NumValues: 0x000D
enum class ESpeedUnit : uint8
{
	CentimeterPerSecond                      = 0,
	FootPerSecond                            = 1,
	MeterPerSecond                           = 2,
	MeterPerMinute                           = 3,
	KilometerPerSecond                       = 4,
	KilometerPerMinute                       = 5,
	KilometerPerHour                         = 6,
	MilePerHour                              = 7,
	Knot                                     = 8,
	Mach                                     = 9,
	SpeedOfLight                             = 10,
	YardPerSecond                            = 11,
	ESpeedUnit_MAX                           = 12,
};

// ScriptStruct GroundBranch.GBAbilityTagRelationship
// 0x0088 (0x0088 - 0x0000)
struct FGBAbilityTagRelationship final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilityTagsToBlock;                                // 0x0008(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilityTagsToCancel;                               // 0x0028(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ActivationRequiredTags;                            // 0x0048(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ActivationBlockedTags;                             // 0x0068(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBAbilityTagRelationship) == 0x000008, "Wrong alignment on FGBAbilityTagRelationship");
static_assert(sizeof(FGBAbilityTagRelationship) == 0x000088, "Wrong size on FGBAbilityTagRelationship");
static_assert(offsetof(FGBAbilityTagRelationship, AbilityTag) == 0x000000, "Member 'FGBAbilityTagRelationship::AbilityTag' has a wrong offset!");
static_assert(offsetof(FGBAbilityTagRelationship, AbilityTagsToBlock) == 0x000008, "Member 'FGBAbilityTagRelationship::AbilityTagsToBlock' has a wrong offset!");
static_assert(offsetof(FGBAbilityTagRelationship, AbilityTagsToCancel) == 0x000028, "Member 'FGBAbilityTagRelationship::AbilityTagsToCancel' has a wrong offset!");
static_assert(offsetof(FGBAbilityTagRelationship, ActivationRequiredTags) == 0x000048, "Member 'FGBAbilityTagRelationship::ActivationRequiredTags' has a wrong offset!");
static_assert(offsetof(FGBAbilityTagRelationship, ActivationBlockedTags) == 0x000068, "Member 'FGBAbilityTagRelationship::ActivationBlockedTags' has a wrong offset!");

// ScriptStruct GroundBranch.GBRecoilData
// 0x0018 (0x0018 - 0x0000)
struct FGBRecoilData final
{
public:
	float                                         MinPitch;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitch;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinYaw;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYaw;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseTime;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryTime;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBRecoilData) == 0x000004, "Wrong alignment on FGBRecoilData");
static_assert(sizeof(FGBRecoilData) == 0x000018, "Wrong size on FGBRecoilData");
static_assert(offsetof(FGBRecoilData, MinPitch) == 0x000000, "Member 'FGBRecoilData::MinPitch' has a wrong offset!");
static_assert(offsetof(FGBRecoilData, MaxPitch) == 0x000004, "Member 'FGBRecoilData::MaxPitch' has a wrong offset!");
static_assert(offsetof(FGBRecoilData, MinYaw) == 0x000008, "Member 'FGBRecoilData::MinYaw' has a wrong offset!");
static_assert(offsetof(FGBRecoilData, MaxYaw) == 0x00000C, "Member 'FGBRecoilData::MaxYaw' has a wrong offset!");
static_assert(offsetof(FGBRecoilData, ImpulseTime) == 0x000010, "Member 'FGBRecoilData::ImpulseTime' has a wrong offset!");
static_assert(offsetof(FGBRecoilData, RecoveryTime) == 0x000014, "Member 'FGBRecoilData::RecoveryTime' has a wrong offset!");

// ScriptStruct GroundBranch.TakeHitInfo
// 0x0038 (0x0038 - 0x0000)
struct FTakeHitInfo final
{
public:
	int32                                         Damage;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0004(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    RelHitLocation;                                    // 0x000C(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Momentum;                                          // 0x0018(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ShotDirPitch;                                      // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ShotDirYaw;                                        // 0x0031(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Count;                                             // 0x0032(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HitFlags;                                          // 0x0033(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTakeHitInfo) == 0x000008, "Wrong alignment on FTakeHitInfo");
static_assert(sizeof(FTakeHitInfo) == 0x000038, "Wrong size on FTakeHitInfo");
static_assert(offsetof(FTakeHitInfo, Damage) == 0x000000, "Member 'FTakeHitInfo::Damage' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, BoneName) == 0x000004, "Member 'FTakeHitInfo::BoneName' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, RelHitLocation) == 0x00000C, "Member 'FTakeHitInfo::RelHitLocation' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, Momentum) == 0x000018, "Member 'FTakeHitInfo::Momentum' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, DamageType) == 0x000028, "Member 'FTakeHitInfo::DamageType' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, ShotDirPitch) == 0x000030, "Member 'FTakeHitInfo::ShotDirPitch' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, ShotDirYaw) == 0x000031, "Member 'FTakeHitInfo::ShotDirYaw' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, Count) == 0x000032, "Member 'FTakeHitInfo::Count' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, HitFlags) == 0x000033, "Member 'FTakeHitInfo::HitFlags' has a wrong offset!");

// ScriptStruct GroundBranch.CharRestrictions
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FCharRestrictions final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharRestrictions) == 0x000008, "Wrong alignment on FCharRestrictions");
static_assert(sizeof(FCharRestrictions) == 0x000030, "Wrong size on FCharRestrictions");

// ScriptStruct GroundBranch.AIMoveCommand
// 0x0018 (0x0018 - 0x0000)
struct FAIMoveCommand final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x0008(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIGoCodes                                    GoCode;                                            // 0x0014(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIMoveCommand) == 0x000008, "Wrong alignment on FAIMoveCommand");
static_assert(sizeof(FAIMoveCommand) == 0x000018, "Wrong size on FAIMoveCommand");
static_assert(offsetof(FAIMoveCommand, TargetActor) == 0x000000, "Member 'FAIMoveCommand::TargetActor' has a wrong offset!");
static_assert(offsetof(FAIMoveCommand, TargetLocation) == 0x000008, "Member 'FAIMoveCommand::TargetLocation' has a wrong offset!");
static_assert(offsetof(FAIMoveCommand, GoCode) == 0x000014, "Member 'FAIMoveCommand::GoCode' has a wrong offset!");

// ScriptStruct GroundBranch.GBGameplayTagEventHandle
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FGBGameplayTagEventHandle final
{
public:
	TWeakObjectPtr<class UObject>                 Target;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBGameplayTagEventHandle) == 0x000008, "Wrong alignment on FGBGameplayTagEventHandle");
static_assert(sizeof(FGBGameplayTagEventHandle) == 0x000018, "Wrong size on FGBGameplayTagEventHandle");
static_assert(offsetof(FGBGameplayTagEventHandle, Target) == 0x000000, "Member 'FGBGameplayTagEventHandle::Target' has a wrong offset!");
static_assert(offsetof(FGBGameplayTagEventHandle, Tag) == 0x000008, "Member 'FGBGameplayTagEventHandle::Tag' has a wrong offset!");

// ScriptStruct GroundBranch.GBTeamInfo
// 0x0018 (0x0018 - 0x0000)
struct FGBTeamInfo final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlayerLoadoutName;                                 // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeamRole;                                          // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBTeamInfo) == 0x000004, "Wrong alignment on FGBTeamInfo");
static_assert(sizeof(FGBTeamInfo) == 0x000018, "Wrong size on FGBTeamInfo");
static_assert(offsetof(FGBTeamInfo, Name) == 0x000000, "Member 'FGBTeamInfo::Name' has a wrong offset!");
static_assert(offsetof(FGBTeamInfo, PlayerLoadoutName) == 0x000008, "Member 'FGBTeamInfo::PlayerLoadoutName' has a wrong offset!");
static_assert(offsetof(FGBTeamInfo, TeamRole) == 0x000010, "Member 'FGBTeamInfo::TeamRole' has a wrong offset!");

// ScriptStruct GroundBranch.GBRadialMenuOption
// 0x0020 (0x0020 - 0x0000)
struct FGBRadialMenuOption final
{
public:
	class FText                                   DisplayText;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBRadialMenuOption) == 0x000008, "Wrong alignment on FGBRadialMenuOption");
static_assert(sizeof(FGBRadialMenuOption) == 0x000020, "Wrong size on FGBRadialMenuOption");
static_assert(offsetof(FGBRadialMenuOption, DisplayText) == 0x000000, "Member 'FGBRadialMenuOption::DisplayText' has a wrong offset!");
static_assert(offsetof(FGBRadialMenuOption, Icon) == 0x000018, "Member 'FGBRadialMenuOption::Icon' has a wrong offset!");

// ScriptStruct GroundBranch.AIBark
// 0x0010 (0x0010 - 0x0000)
struct FAIBark final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIBark) == 0x000004, "Wrong alignment on FAIBark");
static_assert(sizeof(FAIBark) == 0x000010, "Wrong size on FAIBark");
static_assert(offsetof(FAIBark, Key) == 0x000000, "Member 'FAIBark::Key' has a wrong offset!");
static_assert(offsetof(FAIBark, Priority) == 0x000008, "Member 'FAIBark::Priority' has a wrong offset!");
static_assert(offsetof(FAIBark, Timeout) == 0x00000C, "Member 'FAIBark::Timeout' has a wrong offset!");

// ScriptStruct GroundBranch.AITargetData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FAITargetData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAITargetData) == 0x000008, "Wrong alignment on FAITargetData");
static_assert(sizeof(FAITargetData) == 0x000018, "Wrong size on FAITargetData");

// ScriptStruct GroundBranch.GBNonAIListenerDetails
// 0x0030 (0x0030 - 0x0000)
struct FGBNonAIListenerDetails final
{
public:
	class AActor*                                 RegisteredActor;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FVector& NoiseOrigin, float Loudness)> OnNonAIListenerAlert;         // 0x0008(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ThresholdSoundIntensity;                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetriggerDelay;                                    // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastTriggerTime;                                   // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastSoundIntensity;                                // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggeredYet;                                     // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBNonAIListenerDetails) == 0x000008, "Wrong alignment on FGBNonAIListenerDetails");
static_assert(sizeof(FGBNonAIListenerDetails) == 0x000030, "Wrong size on FGBNonAIListenerDetails");
static_assert(offsetof(FGBNonAIListenerDetails, RegisteredActor) == 0x000000, "Member 'FGBNonAIListenerDetails::RegisteredActor' has a wrong offset!");
static_assert(offsetof(FGBNonAIListenerDetails, OnNonAIListenerAlert) == 0x000008, "Member 'FGBNonAIListenerDetails::OnNonAIListenerAlert' has a wrong offset!");
static_assert(offsetof(FGBNonAIListenerDetails, ThresholdSoundIntensity) == 0x000018, "Member 'FGBNonAIListenerDetails::ThresholdSoundIntensity' has a wrong offset!");
static_assert(offsetof(FGBNonAIListenerDetails, RetriggerDelay) == 0x00001C, "Member 'FGBNonAIListenerDetails::RetriggerDelay' has a wrong offset!");
static_assert(offsetof(FGBNonAIListenerDetails, LastTriggerTime) == 0x000020, "Member 'FGBNonAIListenerDetails::LastTriggerTime' has a wrong offset!");
static_assert(offsetof(FGBNonAIListenerDetails, LastSoundIntensity) == 0x000024, "Member 'FGBNonAIListenerDetails::LastSoundIntensity' has a wrong offset!");
static_assert(offsetof(FGBNonAIListenerDetails, bTriggeredYet) == 0x000028, "Member 'FGBNonAIListenerDetails::bTriggeredYet' has a wrong offset!");

// ScriptStruct GroundBranch.GBAINoiseEvent
// 0x0030 (0x0030 - 0x0000)
struct FGBAINoiseEvent final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NoiseLocation;                                     // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AudioSignalRadius;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Instigator;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBAINoiseEvent) == 0x000008, "Wrong alignment on FGBAINoiseEvent");
static_assert(sizeof(FGBAINoiseEvent) == 0x000030, "Wrong size on FGBAINoiseEvent");
static_assert(offsetof(FGBAINoiseEvent, NoiseLocation) == 0x000004, "Member 'FGBAINoiseEvent::NoiseLocation' has a wrong offset!");
static_assert(offsetof(FGBAINoiseEvent, AudioSignalRadius) == 0x000010, "Member 'FGBAINoiseEvent::AudioSignalRadius' has a wrong offset!");
static_assert(offsetof(FGBAINoiseEvent, Instigator) == 0x000018, "Member 'FGBAINoiseEvent::Instigator' has a wrong offset!");
static_assert(offsetof(FGBAINoiseEvent, Tag) == 0x000020, "Member 'FGBAINoiseEvent::Tag' has a wrong offset!");

// ScriptStruct GroundBranch.GBAISightEvent
// 0x0024 (0x0024 - 0x0000)
struct FGBAISightEvent final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ObserverId;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TargetId;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SightLocation;                                     // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x4];                                       // 0x0020(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBAISightEvent) == 0x000004, "Wrong alignment on FGBAISightEvent");
static_assert(sizeof(FGBAISightEvent) == 0x000024, "Wrong size on FGBAISightEvent");
static_assert(offsetof(FGBAISightEvent, ObserverId) == 0x000004, "Member 'FGBAISightEvent::ObserverId' has a wrong offset!");
static_assert(offsetof(FGBAISightEvent, TargetId) == 0x000008, "Member 'FGBAISightEvent::TargetId' has a wrong offset!");
static_assert(offsetof(FGBAISightEvent, SightLocation) == 0x00000C, "Member 'FGBAISightEvent::SightLocation' has a wrong offset!");
static_assert(offsetof(FGBAISightEvent, Tag) == 0x000018, "Member 'FGBAISightEvent::Tag' has a wrong offset!");

// ScriptStruct GroundBranch.GBBarkInfo
// 0x0010 (0x0010 - 0x0000)
struct FGBBarkInfo final
{
public:
	class FName                                   Type;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chance;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBBarkInfo) == 0x000004, "Wrong alignment on FGBBarkInfo");
static_assert(sizeof(FGBBarkInfo) == 0x000010, "Wrong size on FGBBarkInfo");
static_assert(offsetof(FGBBarkInfo, Type) == 0x000000, "Member 'FGBBarkInfo::Type' has a wrong offset!");
static_assert(offsetof(FGBBarkInfo, Chance) == 0x000008, "Member 'FGBBarkInfo::Chance' has a wrong offset!");
static_assert(offsetof(FGBBarkInfo, Timeout) == 0x00000C, "Member 'FGBBarkInfo::Timeout' has a wrong offset!");

// ScriptStruct GroundBranch.GBAISettingsInfo
// 0x0078 (0x0078 - 0x0000)
struct FGBAISettingsInfo final
{
public:
	int32                                         SkillLevel;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTurnRate;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSprintTurnRate;                                 // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuppressionRecoveryRate;                           // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnTargetThreshold;                                 // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimErrorUpdateInterval;                            // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeOnTarget;                                   // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeDeviation;                                  // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceForPenalty;                             // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceForPenalty;                             // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceDeviation;                              // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddedMissDeviation;                                // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialMissTargetThreshold;                        // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CenterOfMassBone;                                  // 0x0034(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactionTimeBase;                                  // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactionTimeRandom;                                // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSemiAutoBurst;                                  // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinFullAutoBurst;                                  // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFullAutoBurst;                                  // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDelayBetweenBursts;                             // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDelayBetweenBursts;                             // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanChance;                                        // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGBBarkInfo>                    BarkInfos;                                         // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TracerFrequency;                                   // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MuzzleFlashProbability;                            // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBAISettingsInfo) == 0x000008, "Wrong alignment on FGBAISettingsInfo");
static_assert(sizeof(FGBAISettingsInfo) == 0x000078, "Wrong size on FGBAISettingsInfo");
static_assert(offsetof(FGBAISettingsInfo, SkillLevel) == 0x000000, "Member 'FGBAISettingsInfo::SkillLevel' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, MaxTurnRate) == 0x000004, "Member 'FGBAISettingsInfo::MaxTurnRate' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, MaxSprintTurnRate) == 0x000008, "Member 'FGBAISettingsInfo::MaxSprintTurnRate' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, SuppressionRecoveryRate) == 0x00000C, "Member 'FGBAISettingsInfo::SuppressionRecoveryRate' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, OnTargetThreshold) == 0x000010, "Member 'FGBAISettingsInfo::OnTargetThreshold' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, AimErrorUpdateInterval) == 0x000014, "Member 'FGBAISettingsInfo::AimErrorUpdateInterval' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, MaxTimeOnTarget) == 0x000018, "Member 'FGBAISettingsInfo::MaxTimeOnTarget' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, MaxTimeDeviation) == 0x00001C, "Member 'FGBAISettingsInfo::MaxTimeDeviation' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, MinDistanceForPenalty) == 0x000020, "Member 'FGBAISettingsInfo::MinDistanceForPenalty' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, MaxDistanceForPenalty) == 0x000024, "Member 'FGBAISettingsInfo::MaxDistanceForPenalty' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, MaxDistanceDeviation) == 0x000028, "Member 'FGBAISettingsInfo::MaxDistanceDeviation' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, AddedMissDeviation) == 0x00002C, "Member 'FGBAISettingsInfo::AddedMissDeviation' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, InitialMissTargetThreshold) == 0x000030, "Member 'FGBAISettingsInfo::InitialMissTargetThreshold' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, CenterOfMassBone) == 0x000034, "Member 'FGBAISettingsInfo::CenterOfMassBone' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, ReactionTimeBase) == 0x00003C, "Member 'FGBAISettingsInfo::ReactionTimeBase' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, ReactionTimeRandom) == 0x000040, "Member 'FGBAISettingsInfo::ReactionTimeRandom' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, MaxSemiAutoBurst) == 0x000044, "Member 'FGBAISettingsInfo::MaxSemiAutoBurst' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, MinFullAutoBurst) == 0x000048, "Member 'FGBAISettingsInfo::MinFullAutoBurst' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, MaxFullAutoBurst) == 0x00004C, "Member 'FGBAISettingsInfo::MaxFullAutoBurst' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, MinDelayBetweenBursts) == 0x000050, "Member 'FGBAISettingsInfo::MinDelayBetweenBursts' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, MaxDelayBetweenBursts) == 0x000054, "Member 'FGBAISettingsInfo::MaxDelayBetweenBursts' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, LeanChance) == 0x000058, "Member 'FGBAISettingsInfo::LeanChance' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, BarkInfos) == 0x000060, "Member 'FGBAISettingsInfo::BarkInfos' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, TracerFrequency) == 0x000070, "Member 'FGBAISettingsInfo::TracerFrequency' has a wrong offset!");
static_assert(offsetof(FGBAISettingsInfo, MuzzleFlashProbability) == 0x000074, "Member 'FGBAISettingsInfo::MuzzleFlashProbability' has a wrong offset!");

// ScriptStruct GroundBranch.GBSquadGuardPoint
// 0x0060 (0x0060 - 0x0000)
struct FGBSquadGuardPoint final
{
public:
	class AGBAIGuardPoint*                        GuardPoint;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x58];                                       // 0x0008(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBSquadGuardPoint) == 0x000008, "Wrong alignment on FGBSquadGuardPoint");
static_assert(sizeof(FGBSquadGuardPoint) == 0x000060, "Wrong size on FGBSquadGuardPoint");
static_assert(offsetof(FGBSquadGuardPoint, GuardPoint) == 0x000000, "Member 'FGBSquadGuardPoint::GuardPoint' has a wrong offset!");

// ScriptStruct GroundBranch.KyAISettings
// 0x0064 (0x0064 - 0x0000)
struct FKyAISettings final
{
public:
	int32                                         SkillLevel;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTurnRate;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSprintTurnRate;                                 // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeadLookRate;                                   // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuppressionRecoveryRate;                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnTargetThreshold;                                 // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilCompensationSkill;                           // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimErrorUpdateInterval;                            // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeliberateMissTime;                                // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeliberateMissBlendOutTime;                        // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeliberateMissDistanceThreshold;                   // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactionTimeBase;                                  // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactionTimeRandom;                                // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleHearingThreshold;                              // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlertHearingThreshold;                             // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleAffiliationSightThreshold;                     // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlertAffiliationSightThreshold;                    // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleSuspicionSightThreshold;                       // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlertSuspicionSightThreshold;                      // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSemiAutoBurst;                                  // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinFullAutoBurst;                                  // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFullAutoBurst;                                  // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDelayBetweenBursts;                             // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDelayBetweenBursts;                             // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanChance;                                        // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKyAISettings) == 0x000004, "Wrong alignment on FKyAISettings");
static_assert(sizeof(FKyAISettings) == 0x000064, "Wrong size on FKyAISettings");
static_assert(offsetof(FKyAISettings, SkillLevel) == 0x000000, "Member 'FKyAISettings::SkillLevel' has a wrong offset!");
static_assert(offsetof(FKyAISettings, MaxTurnRate) == 0x000004, "Member 'FKyAISettings::MaxTurnRate' has a wrong offset!");
static_assert(offsetof(FKyAISettings, MaxSprintTurnRate) == 0x000008, "Member 'FKyAISettings::MaxSprintTurnRate' has a wrong offset!");
static_assert(offsetof(FKyAISettings, MaxHeadLookRate) == 0x00000C, "Member 'FKyAISettings::MaxHeadLookRate' has a wrong offset!");
static_assert(offsetof(FKyAISettings, SuppressionRecoveryRate) == 0x000010, "Member 'FKyAISettings::SuppressionRecoveryRate' has a wrong offset!");
static_assert(offsetof(FKyAISettings, OnTargetThreshold) == 0x000014, "Member 'FKyAISettings::OnTargetThreshold' has a wrong offset!");
static_assert(offsetof(FKyAISettings, RecoilCompensationSkill) == 0x000018, "Member 'FKyAISettings::RecoilCompensationSkill' has a wrong offset!");
static_assert(offsetof(FKyAISettings, AimErrorUpdateInterval) == 0x00001C, "Member 'FKyAISettings::AimErrorUpdateInterval' has a wrong offset!");
static_assert(offsetof(FKyAISettings, DeliberateMissTime) == 0x000020, "Member 'FKyAISettings::DeliberateMissTime' has a wrong offset!");
static_assert(offsetof(FKyAISettings, DeliberateMissBlendOutTime) == 0x000024, "Member 'FKyAISettings::DeliberateMissBlendOutTime' has a wrong offset!");
static_assert(offsetof(FKyAISettings, DeliberateMissDistanceThreshold) == 0x000028, "Member 'FKyAISettings::DeliberateMissDistanceThreshold' has a wrong offset!");
static_assert(offsetof(FKyAISettings, ReactionTimeBase) == 0x00002C, "Member 'FKyAISettings::ReactionTimeBase' has a wrong offset!");
static_assert(offsetof(FKyAISettings, ReactionTimeRandom) == 0x000030, "Member 'FKyAISettings::ReactionTimeRandom' has a wrong offset!");
static_assert(offsetof(FKyAISettings, IdleHearingThreshold) == 0x000034, "Member 'FKyAISettings::IdleHearingThreshold' has a wrong offset!");
static_assert(offsetof(FKyAISettings, AlertHearingThreshold) == 0x000038, "Member 'FKyAISettings::AlertHearingThreshold' has a wrong offset!");
static_assert(offsetof(FKyAISettings, IdleAffiliationSightThreshold) == 0x00003C, "Member 'FKyAISettings::IdleAffiliationSightThreshold' has a wrong offset!");
static_assert(offsetof(FKyAISettings, AlertAffiliationSightThreshold) == 0x000040, "Member 'FKyAISettings::AlertAffiliationSightThreshold' has a wrong offset!");
static_assert(offsetof(FKyAISettings, IdleSuspicionSightThreshold) == 0x000044, "Member 'FKyAISettings::IdleSuspicionSightThreshold' has a wrong offset!");
static_assert(offsetof(FKyAISettings, AlertSuspicionSightThreshold) == 0x000048, "Member 'FKyAISettings::AlertSuspicionSightThreshold' has a wrong offset!");
static_assert(offsetof(FKyAISettings, MaxSemiAutoBurst) == 0x00004C, "Member 'FKyAISettings::MaxSemiAutoBurst' has a wrong offset!");
static_assert(offsetof(FKyAISettings, MinFullAutoBurst) == 0x000050, "Member 'FKyAISettings::MinFullAutoBurst' has a wrong offset!");
static_assert(offsetof(FKyAISettings, MaxFullAutoBurst) == 0x000054, "Member 'FKyAISettings::MaxFullAutoBurst' has a wrong offset!");
static_assert(offsetof(FKyAISettings, MinDelayBetweenBursts) == 0x000058, "Member 'FKyAISettings::MinDelayBetweenBursts' has a wrong offset!");
static_assert(offsetof(FKyAISettings, MaxDelayBetweenBursts) == 0x00005C, "Member 'FKyAISettings::MaxDelayBetweenBursts' has a wrong offset!");
static_assert(offsetof(FKyAISettings, LeanChance) == 0x000060, "Member 'FKyAISettings::LeanChance' has a wrong offset!");

// ScriptStruct GroundBranch.KyAICapabilities
// 0x0002 (0x0002 - 0x0000)
struct FKyAICapabilities final
{
public:
	bool                                          bCanDetectFlashlights;                             // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDetectIRLaser;                                 // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKyAICapabilities) == 0x000001, "Wrong alignment on FKyAICapabilities");
static_assert(sizeof(FKyAICapabilities) == 0x000002, "Wrong size on FKyAICapabilities");
static_assert(offsetof(FKyAICapabilities, bCanDetectFlashlights) == 0x000000, "Member 'FKyAICapabilities::bCanDetectFlashlights' has a wrong offset!");
static_assert(offsetof(FKyAICapabilities, bCanDetectIRLaser) == 0x000001, "Member 'FKyAICapabilities::bCanDetectIRLaser' has a wrong offset!");

// ScriptStruct GroundBranch.GBConstraintLimitData
// 0x0010 (0x0010 - 0x0000)
struct FGBConstraintLimitData final
{
public:
	float                                         LimitSwing1Value;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitSwing2Value;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitTwistValue;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAngularConstraintMotion                      Swing1LockState;                                   // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAngularConstraintMotion                      Swing2LockState;                                   // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAngularConstraintMotion                      TwistLockState;                                    // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBConstraintLimitData) == 0x000004, "Wrong alignment on FGBConstraintLimitData");
static_assert(sizeof(FGBConstraintLimitData) == 0x000010, "Wrong size on FGBConstraintLimitData");
static_assert(offsetof(FGBConstraintLimitData, LimitSwing1Value) == 0x000000, "Member 'FGBConstraintLimitData::LimitSwing1Value' has a wrong offset!");
static_assert(offsetof(FGBConstraintLimitData, LimitSwing2Value) == 0x000004, "Member 'FGBConstraintLimitData::LimitSwing2Value' has a wrong offset!");
static_assert(offsetof(FGBConstraintLimitData, LimitTwistValue) == 0x000008, "Member 'FGBConstraintLimitData::LimitTwistValue' has a wrong offset!");
static_assert(offsetof(FGBConstraintLimitData, Swing1LockState) == 0x00000C, "Member 'FGBConstraintLimitData::Swing1LockState' has a wrong offset!");
static_assert(offsetof(FGBConstraintLimitData, Swing2LockState) == 0x00000D, "Member 'FGBConstraintLimitData::Swing2LockState' has a wrong offset!");
static_assert(offsetof(FGBConstraintLimitData, TwistLockState) == 0x00000E, "Member 'FGBConstraintLimitData::TwistLockState' has a wrong offset!");

// ScriptStruct GroundBranch.GBDummyStruct
// 0x0001 (0x0001 - 0x0000)
struct FGBDummyStruct final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBDummyStruct) == 0x000001, "Wrong alignment on FGBDummyStruct");
static_assert(sizeof(FGBDummyStruct) == 0x000001, "Wrong size on FGBDummyStruct");

// ScriptStruct GroundBranch.GBKitFieldPrimaryAssetType
// 0x0018 (0x0018 - 0x0000)
struct FGBKitFieldPrimaryAssetType final
{
public:
	class FString                                 KitField;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetType                      PrimaryAssetType;                                  // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBKitFieldPrimaryAssetType) == 0x000008, "Wrong alignment on FGBKitFieldPrimaryAssetType");
static_assert(sizeof(FGBKitFieldPrimaryAssetType) == 0x000018, "Wrong size on FGBKitFieldPrimaryAssetType");
static_assert(offsetof(FGBKitFieldPrimaryAssetType, KitField) == 0x000000, "Member 'FGBKitFieldPrimaryAssetType::KitField' has a wrong offset!");
static_assert(offsetof(FGBKitFieldPrimaryAssetType, PrimaryAssetType) == 0x000010, "Member 'FGBKitFieldPrimaryAssetType::PrimaryAssetType' has a wrong offset!");

// ScriptStruct GroundBranch.BenchmarkInfo
// 0x00C8 (0x00C8 - 0x0000)
struct FBenchmarkInfo final
{
public:
	class FString                                 LevelName;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadTime;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LevelAI;                                           // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelTime;                                         // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelNameReadable;                                 // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelAIReadable;                                   // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelTimeReadable;                                 // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BuildConfig;                                       // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BuildNumber;                                       // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Changelist;                                        // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 cpuName;                                           // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CPUCores;                                          // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CPUCoresLogical;                                   // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 gpuName;                                           // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRAM;                                            // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxVRAM;                                           // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              DateTime;                                          // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBenchmarkInfo) == 0x000008, "Wrong alignment on FBenchmarkInfo");
static_assert(sizeof(FBenchmarkInfo) == 0x0000C8, "Wrong size on FBenchmarkInfo");
static_assert(offsetof(FBenchmarkInfo, LevelName) == 0x000000, "Member 'FBenchmarkInfo::LevelName' has a wrong offset!");
static_assert(offsetof(FBenchmarkInfo, LoadTime) == 0x000010, "Member 'FBenchmarkInfo::LoadTime' has a wrong offset!");
static_assert(offsetof(FBenchmarkInfo, LevelAI) == 0x000018, "Member 'FBenchmarkInfo::LevelAI' has a wrong offset!");
static_assert(offsetof(FBenchmarkInfo, LevelTime) == 0x000028, "Member 'FBenchmarkInfo::LevelTime' has a wrong offset!");
static_assert(offsetof(FBenchmarkInfo, LevelNameReadable) == 0x000038, "Member 'FBenchmarkInfo::LevelNameReadable' has a wrong offset!");
static_assert(offsetof(FBenchmarkInfo, LevelAIReadable) == 0x000048, "Member 'FBenchmarkInfo::LevelAIReadable' has a wrong offset!");
static_assert(offsetof(FBenchmarkInfo, LevelTimeReadable) == 0x000058, "Member 'FBenchmarkInfo::LevelTimeReadable' has a wrong offset!");
static_assert(offsetof(FBenchmarkInfo, BuildConfig) == 0x000068, "Member 'FBenchmarkInfo::BuildConfig' has a wrong offset!");
static_assert(offsetof(FBenchmarkInfo, BuildNumber) == 0x000078, "Member 'FBenchmarkInfo::BuildNumber' has a wrong offset!");
static_assert(offsetof(FBenchmarkInfo, Changelist) == 0x000088, "Member 'FBenchmarkInfo::Changelist' has a wrong offset!");
static_assert(offsetof(FBenchmarkInfo, cpuName) == 0x000090, "Member 'FBenchmarkInfo::cpuName' has a wrong offset!");
static_assert(offsetof(FBenchmarkInfo, CPUCores) == 0x0000A0, "Member 'FBenchmarkInfo::CPUCores' has a wrong offset!");
static_assert(offsetof(FBenchmarkInfo, CPUCoresLogical) == 0x0000A4, "Member 'FBenchmarkInfo::CPUCoresLogical' has a wrong offset!");
static_assert(offsetof(FBenchmarkInfo, gpuName) == 0x0000A8, "Member 'FBenchmarkInfo::gpuName' has a wrong offset!");
static_assert(offsetof(FBenchmarkInfo, MaxRAM) == 0x0000B8, "Member 'FBenchmarkInfo::MaxRAM' has a wrong offset!");
static_assert(offsetof(FBenchmarkInfo, MaxVRAM) == 0x0000BC, "Member 'FBenchmarkInfo::MaxVRAM' has a wrong offset!");
static_assert(offsetof(FBenchmarkInfo, DateTime) == 0x0000C0, "Member 'FBenchmarkInfo::DateTime' has a wrong offset!");

// ScriptStruct GroundBranch.BenchmarkStat
// 0x0020 (0x0020 - 0x0000)
struct FBenchmarkStat final
{
public:
	int32                                         Average;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Total;                                             // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBenchmarkStat) == 0x000008, "Wrong alignment on FBenchmarkStat");
static_assert(sizeof(FBenchmarkStat) == 0x000020, "Wrong size on FBenchmarkStat");
static_assert(offsetof(FBenchmarkStat, Average) == 0x000000, "Member 'FBenchmarkStat::Average' has a wrong offset!");
static_assert(offsetof(FBenchmarkStat, Min) == 0x000004, "Member 'FBenchmarkStat::Min' has a wrong offset!");
static_assert(offsetof(FBenchmarkStat, Max) == 0x000008, "Member 'FBenchmarkStat::Max' has a wrong offset!");
static_assert(offsetof(FBenchmarkStat, Total) == 0x000010, "Member 'FBenchmarkStat::Total' has a wrong offset!");
static_assert(offsetof(FBenchmarkStat, Count) == 0x000018, "Member 'FBenchmarkStat::Count' has a wrong offset!");

// ScriptStruct GroundBranch.BenchmarkStatFloat
// 0x0014 (0x0014 - 0x0000)
struct FBenchmarkStatFloat final
{
public:
	float                                         Average;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Total;                                             // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBenchmarkStatFloat) == 0x000004, "Wrong alignment on FBenchmarkStatFloat");
static_assert(sizeof(FBenchmarkStatFloat) == 0x000014, "Wrong size on FBenchmarkStatFloat");
static_assert(offsetof(FBenchmarkStatFloat, Average) == 0x000000, "Member 'FBenchmarkStatFloat::Average' has a wrong offset!");
static_assert(offsetof(FBenchmarkStatFloat, Min) == 0x000004, "Member 'FBenchmarkStatFloat::Min' has a wrong offset!");
static_assert(offsetof(FBenchmarkStatFloat, Max) == 0x000008, "Member 'FBenchmarkStatFloat::Max' has a wrong offset!");
static_assert(offsetof(FBenchmarkStatFloat, Total) == 0x00000C, "Member 'FBenchmarkStatFloat::Total' has a wrong offset!");
static_assert(offsetof(FBenchmarkStatFloat, Count) == 0x000010, "Member 'FBenchmarkStatFloat::Count' has a wrong offset!");

// ScriptStruct GroundBranch.BenchmarkFrameData
// 0x0088 (0x0088 - 0x0000)
struct FBenchmarkFrameData final
{
public:
	float                                         Runtime;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrameIndex;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FPS;                                               // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MS;                                                // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameMS;                                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GPUMS;                                             // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawMS;                                            // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DrawCalls;                                         // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FoliageTriangles;                                  // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StaticMeshTriangles;                               // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            UsageCPUByCore;                                    // 0x0028(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	int32                                         UsageCPU;                                          // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsageGPU;                                          // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsageRAM;                                          // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsageVRAM;                                         // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBenchmarkFrameData) == 0x000008, "Wrong alignment on FBenchmarkFrameData");
static_assert(sizeof(FBenchmarkFrameData) == 0x000088, "Wrong size on FBenchmarkFrameData");
static_assert(offsetof(FBenchmarkFrameData, Runtime) == 0x000000, "Member 'FBenchmarkFrameData::Runtime' has a wrong offset!");
static_assert(offsetof(FBenchmarkFrameData, FrameIndex) == 0x000004, "Member 'FBenchmarkFrameData::FrameIndex' has a wrong offset!");
static_assert(offsetof(FBenchmarkFrameData, FPS) == 0x000008, "Member 'FBenchmarkFrameData::FPS' has a wrong offset!");
static_assert(offsetof(FBenchmarkFrameData, MS) == 0x00000C, "Member 'FBenchmarkFrameData::MS' has a wrong offset!");
static_assert(offsetof(FBenchmarkFrameData, GameMS) == 0x000010, "Member 'FBenchmarkFrameData::GameMS' has a wrong offset!");
static_assert(offsetof(FBenchmarkFrameData, GPUMS) == 0x000014, "Member 'FBenchmarkFrameData::GPUMS' has a wrong offset!");
static_assert(offsetof(FBenchmarkFrameData, DrawMS) == 0x000018, "Member 'FBenchmarkFrameData::DrawMS' has a wrong offset!");
static_assert(offsetof(FBenchmarkFrameData, DrawCalls) == 0x00001C, "Member 'FBenchmarkFrameData::DrawCalls' has a wrong offset!");
static_assert(offsetof(FBenchmarkFrameData, FoliageTriangles) == 0x000020, "Member 'FBenchmarkFrameData::FoliageTriangles' has a wrong offset!");
static_assert(offsetof(FBenchmarkFrameData, StaticMeshTriangles) == 0x000024, "Member 'FBenchmarkFrameData::StaticMeshTriangles' has a wrong offset!");
static_assert(offsetof(FBenchmarkFrameData, UsageCPUByCore) == 0x000028, "Member 'FBenchmarkFrameData::UsageCPUByCore' has a wrong offset!");
static_assert(offsetof(FBenchmarkFrameData, UsageCPU) == 0x000078, "Member 'FBenchmarkFrameData::UsageCPU' has a wrong offset!");
static_assert(offsetof(FBenchmarkFrameData, UsageGPU) == 0x00007C, "Member 'FBenchmarkFrameData::UsageGPU' has a wrong offset!");
static_assert(offsetof(FBenchmarkFrameData, UsageRAM) == 0x000080, "Member 'FBenchmarkFrameData::UsageRAM' has a wrong offset!");
static_assert(offsetof(FBenchmarkFrameData, UsageVRAM) == 0x000084, "Member 'FBenchmarkFrameData::UsageVRAM' has a wrong offset!");

// ScriptStruct GroundBranch.BenchmarkData
// 0x01E0 (0x01E0 - 0x0000)
struct FBenchmarkData final
{
public:
	class FString                                 Source;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Runtime;                                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBenchmarkStat                         Percentile99;                                      // 0x0018(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FBenchmarkStat                         Percentile95;                                      // 0x0038(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FBenchmarkStat                         FPS;                                               // 0x0058(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FBenchmarkStatFloat                    MS;                                                // 0x0078(0x0014)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FBenchmarkStatFloat                    GameMS;                                            // 0x008C(0x0014)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FBenchmarkStatFloat                    GPUMS;                                             // 0x00A0(0x0014)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FBenchmarkStatFloat                    DrawsMS;                                           // 0x00B4(0x0014)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FBenchmarkStat                         DrawCalls;                                         // 0x00C8(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FBenchmarkStat                         FoliageTriangles;                                  // 0x00E8(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FBenchmarkStat                         StaticMeshTriangles;                               // 0x0108(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         TotalHitchCount;                                   // 0x0128(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalGameThreadBoundHitchCount;                    // 0x012C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalRenderThreadBoundHitchCount;                  // 0x0130(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalRHIThreadBoundHitchCount;                     // 0x0134(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalGPUBoundHitchCount;                           // 0x0138(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetFrameRatePct;                                // 0x013C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBenchmarkStat                         CPU;                                               // 0x0140(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FBenchmarkStat                         GPU;                                               // 0x0160(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FBenchmarkStat                         RAM;                                               // 0x0180(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FBenchmarkStat                         VRAM;                                              // 0x01A0(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBenchmarkFrameData>            Frames;                                            // 0x01C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 FPSSorted;                                         // 0x01D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBenchmarkData) == 0x000008, "Wrong alignment on FBenchmarkData");
static_assert(sizeof(FBenchmarkData) == 0x0001E0, "Wrong size on FBenchmarkData");
static_assert(offsetof(FBenchmarkData, Source) == 0x000000, "Member 'FBenchmarkData::Source' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, Runtime) == 0x000010, "Member 'FBenchmarkData::Runtime' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, Percentile99) == 0x000018, "Member 'FBenchmarkData::Percentile99' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, Percentile95) == 0x000038, "Member 'FBenchmarkData::Percentile95' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, FPS) == 0x000058, "Member 'FBenchmarkData::FPS' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, MS) == 0x000078, "Member 'FBenchmarkData::MS' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, GameMS) == 0x00008C, "Member 'FBenchmarkData::GameMS' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, GPUMS) == 0x0000A0, "Member 'FBenchmarkData::GPUMS' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, DrawsMS) == 0x0000B4, "Member 'FBenchmarkData::DrawsMS' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, DrawCalls) == 0x0000C8, "Member 'FBenchmarkData::DrawCalls' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, FoliageTriangles) == 0x0000E8, "Member 'FBenchmarkData::FoliageTriangles' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, StaticMeshTriangles) == 0x000108, "Member 'FBenchmarkData::StaticMeshTriangles' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, TotalHitchCount) == 0x000128, "Member 'FBenchmarkData::TotalHitchCount' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, TotalGameThreadBoundHitchCount) == 0x00012C, "Member 'FBenchmarkData::TotalGameThreadBoundHitchCount' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, TotalRenderThreadBoundHitchCount) == 0x000130, "Member 'FBenchmarkData::TotalRenderThreadBoundHitchCount' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, TotalRHIThreadBoundHitchCount) == 0x000134, "Member 'FBenchmarkData::TotalRHIThreadBoundHitchCount' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, TotalGPUBoundHitchCount) == 0x000138, "Member 'FBenchmarkData::TotalGPUBoundHitchCount' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, TargetFrameRatePct) == 0x00013C, "Member 'FBenchmarkData::TargetFrameRatePct' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, CPU) == 0x000140, "Member 'FBenchmarkData::CPU' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, GPU) == 0x000160, "Member 'FBenchmarkData::GPU' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, RAM) == 0x000180, "Member 'FBenchmarkData::RAM' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, VRAM) == 0x0001A0, "Member 'FBenchmarkData::VRAM' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, Frames) == 0x0001C0, "Member 'FBenchmarkData::Frames' has a wrong offset!");
static_assert(offsetof(FBenchmarkData, FPSSorted) == 0x0001D0, "Member 'FBenchmarkData::FPSSorted' has a wrong offset!");

// ScriptStruct GroundBranch.BenchmarkResults
// 0x02B8 (0x02B8 - 0x0000)
struct FBenchmarkResults final
{
public:
	struct FBenchmarkInfo                         Info;                                              // 0x0000(0x00C8)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FBenchmarkData                         SequenceData;                                      // 0x00C8(0x01E0)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TArray<struct FBenchmarkData>                 HotspotDatas;                                      // 0x02A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBenchmarkResults) == 0x000008, "Wrong alignment on FBenchmarkResults");
static_assert(sizeof(FBenchmarkResults) == 0x0002B8, "Wrong size on FBenchmarkResults");
static_assert(offsetof(FBenchmarkResults, Info) == 0x000000, "Member 'FBenchmarkResults::Info' has a wrong offset!");
static_assert(offsetof(FBenchmarkResults, SequenceData) == 0x0000C8, "Member 'FBenchmarkResults::SequenceData' has a wrong offset!");
static_assert(offsetof(FBenchmarkResults, HotspotDatas) == 0x0002A8, "Member 'FBenchmarkResults::HotspotDatas' has a wrong offset!");

// ScriptStruct GroundBranch.RepBulletMovement
// 0x0018 (0x0018 - 0x0000)
struct FRepBulletMovement final
{
public:
	struct FVector_NetQuantize100                 LinearVelocity;                                    // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 Location;                                          // 0x000C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRepBulletMovement) == 0x000004, "Wrong alignment on FRepBulletMovement");
static_assert(sizeof(FRepBulletMovement) == 0x000018, "Wrong size on FRepBulletMovement");
static_assert(offsetof(FRepBulletMovement, LinearVelocity) == 0x000000, "Member 'FRepBulletMovement::LinearVelocity' has a wrong offset!");
static_assert(offsetof(FRepBulletMovement, Location) == 0x00000C, "Member 'FRepBulletMovement::Location' has a wrong offset!");

// ScriptStruct GroundBranch.GBMissionCompletionDetails
// 0x0014 (0x0014 - 0x0000)
struct FGBMissionCompletionDetails final
{
public:
	class FName                                   HotspotCodename;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MissionSequenceNumber;                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinglePlayerCompletion;                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoopCompletion;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBMissionCompletionDetails) == 0x000004, "Wrong alignment on FGBMissionCompletionDetails");
static_assert(sizeof(FGBMissionCompletionDetails) == 0x000014, "Wrong size on FGBMissionCompletionDetails");
static_assert(offsetof(FGBMissionCompletionDetails, HotspotCodename) == 0x000000, "Member 'FGBMissionCompletionDetails::HotspotCodename' has a wrong offset!");
static_assert(offsetof(FGBMissionCompletionDetails, MissionSequenceNumber) == 0x000008, "Member 'FGBMissionCompletionDetails::MissionSequenceNumber' has a wrong offset!");
static_assert(offsetof(FGBMissionCompletionDetails, SinglePlayerCompletion) == 0x00000C, "Member 'FGBMissionCompletionDetails::SinglePlayerCompletion' has a wrong offset!");
static_assert(offsetof(FGBMissionCompletionDetails, CoopCompletion) == 0x000010, "Member 'FGBMissionCompletionDetails::CoopCompletion' has a wrong offset!");

// ScriptStruct GroundBranch.GBCharVoiceInfo
// 0x0014 (0x0014 - 0x0000)
struct FGBCharVoiceInfo final
{
public:
	struct FPrimaryAssetId                        CharVoiceDataId;                                   // 0x0000(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         VoiceActorIndex;                                   // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBCharVoiceInfo) == 0x000004, "Wrong alignment on FGBCharVoiceInfo");
static_assert(sizeof(FGBCharVoiceInfo) == 0x000014, "Wrong size on FGBCharVoiceInfo");
static_assert(offsetof(FGBCharVoiceInfo, CharVoiceDataId) == 0x000000, "Member 'FGBCharVoiceInfo::CharVoiceDataId' has a wrong offset!");
static_assert(offsetof(FGBCharVoiceInfo, VoiceActorIndex) == 0x000010, "Member 'FGBCharVoiceInfo::VoiceActorIndex' has a wrong offset!");

// ScriptStruct GroundBranch.EmoteInfo
// 0x0014 (0x0014 - 0x0000)
struct FEmoteInfo final
{
public:
	struct FPrimaryAssetId                        CharEmoteId;                                       // 0x0000(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnsureRep;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmoteInfo) == 0x000004, "Wrong alignment on FEmoteInfo");
static_assert(sizeof(FEmoteInfo) == 0x000014, "Wrong size on FEmoteInfo");
static_assert(offsetof(FEmoteInfo, CharEmoteId) == 0x000000, "Member 'FEmoteInfo::CharEmoteId' has a wrong offset!");
static_assert(offsetof(FEmoteInfo, EnsureRep) == 0x000010, "Member 'FEmoteInfo::EnsureRep' has a wrong offset!");

// ScriptStruct GroundBranch.ExternalWound
// 0x0020 (0x0020 - 0x0000)
struct FExternalWound final
{
public:
	class FName                                   AttachBoneName;                                    // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    RelativeLocation;                                  // 0x0008(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RelativePitch;                                     // 0x0014(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RelativeYaw;                                       // 0x0015(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Rate;                                              // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExternalWound) == 0x000004, "Wrong alignment on FExternalWound");
static_assert(sizeof(FExternalWound) == 0x000020, "Wrong size on FExternalWound");
static_assert(offsetof(FExternalWound, AttachBoneName) == 0x000000, "Member 'FExternalWound::AttachBoneName' has a wrong offset!");
static_assert(offsetof(FExternalWound, RelativeLocation) == 0x000008, "Member 'FExternalWound::RelativeLocation' has a wrong offset!");
static_assert(offsetof(FExternalWound, RelativePitch) == 0x000014, "Member 'FExternalWound::RelativePitch' has a wrong offset!");
static_assert(offsetof(FExternalWound, RelativeYaw) == 0x000015, "Member 'FExternalWound::RelativeYaw' has a wrong offset!");
static_assert(offsetof(FExternalWound, Rate) == 0x000018, "Member 'FExternalWound::Rate' has a wrong offset!");
static_assert(offsetof(FExternalWound, Duration) == 0x00001C, "Member 'FExternalWound::Duration' has a wrong offset!");

// ScriptStruct GroundBranch.HitBulletIndexes
// 0x0020 (0x0020 - 0x0000)
struct FHitBulletIndexes final
{
public:
	TArray<uint8>                                 Indexes;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         StaKeys;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitBulletIndexes) == 0x000008, "Wrong alignment on FHitBulletIndexes");
static_assert(sizeof(FHitBulletIndexes) == 0x000020, "Wrong size on FHitBulletIndexes");
static_assert(offsetof(FHitBulletIndexes, Indexes) == 0x000000, "Member 'FHitBulletIndexes::Indexes' has a wrong offset!");
static_assert(offsetof(FHitBulletIndexes, StaKeys) == 0x000010, "Member 'FHitBulletIndexes::StaKeys' has a wrong offset!");

// ScriptStruct GroundBranch.GBAISightPart
// 0x0020 (0x0020 - 0x0000)
struct FGBAISightPart final
{
public:
	class FName                                   PartName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PartSize;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ValueCurveName;                                    // 0x000C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpdateFrequencyCurveName;                          // 0x0014(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBone;                                           // 0x001C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBAISightPart) == 0x000004, "Wrong alignment on FGBAISightPart");
static_assert(sizeof(FGBAISightPart) == 0x000020, "Wrong size on FGBAISightPart");
static_assert(offsetof(FGBAISightPart, PartName) == 0x000000, "Member 'FGBAISightPart::PartName' has a wrong offset!");
static_assert(offsetof(FGBAISightPart, PartSize) == 0x000008, "Member 'FGBAISightPart::PartSize' has a wrong offset!");
static_assert(offsetof(FGBAISightPart, ValueCurveName) == 0x00000C, "Member 'FGBAISightPart::ValueCurveName' has a wrong offset!");
static_assert(offsetof(FGBAISightPart, UpdateFrequencyCurveName) == 0x000014, "Member 'FGBAISightPart::UpdateFrequencyCurveName' has a wrong offset!");
static_assert(offsetof(FGBAISightPart, bIsBone) == 0x00001C, "Member 'FGBAISightPart::bIsBone' has a wrong offset!");

// ScriptStruct GroundBranch.GBCharAnimInstanceProxy
// 0x01F0 (0x0960 - 0x0770)
struct FGBCharAnimInstanceProxy final : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_770[0x1C];                                     // 0x0770(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               BaseAimRotation;                                   // 0x078C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CharacterGravityZ;                                 // 0x0798(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 MovementMode;                                      // 0x079C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnGround;                                       // 0x079D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasVeloctyOrAcceleration;                         // 0x079E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCrouching;                                      // 0x079F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchAlpha;                                       // 0x07A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsProne;                                          // 0x07A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A5[0x3];                                      // 0x07A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeanAlpha;                                         // 0x07A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRunning;                                        // 0x07AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSprinting;                                      // 0x07AD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasCrouchingLastUpdate;                           // 0x07AE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouchStateChanged;                               // 0x07AF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasProneLastUpdate;                               // 0x07B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProneStateChanged;                                // 0x07B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJumping;                                        // 0x07B2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFalling;                                        // 0x07B3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToJumpApex;                                    // 0x07B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRunningIntoWall;                                // 0x07B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B9[0x3];                                      // 0x07B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldLocation;                                     // 0x07BC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplacementSinceLastUpdate;                       // 0x07C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplacementSpeed;                                 // 0x07CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               WorldRotation;                                     // 0x07D0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         YawDeltaSinceLastUpdate;                           // 0x07DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawDeltaSpeed;                                     // 0x07E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveLeanAngle;                                 // 0x07E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldVelocity;                                     // 0x07E8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalVelocity2D;                                   // 0x07F4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalVelocityDirectionAngle;                       // 0x0800(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalVelocityDirectionAngleWithOffset;             // 0x0804(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGBAnimDirection                              LocalVelocityDirection;                            // 0x0808(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGBAnimDirection                              LocalVelocityDirectionNoOffset;                    // 0x0809(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasVelocity;                                      // 0x080A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80B[0x1];                                      // 0x080B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OrientationWarpingAngle;                           // 0x080C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_810[0x4];                                      // 0x0810(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldAcceleration2D;                               // 0x0814(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalAcceleration2D;                               // 0x0820(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PivotDirection2D;                                  // 0x082C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGBAnimDirection                              DirectionFromAcceleration;                         // 0x0838(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAcceleration;                                  // 0x0839(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_83A[0x2];                                      // 0x083A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpperbodyDynamicAdditiveWeight;                    // 0x083C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimPitch;                                          // 0x0840(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimPitchDeltaSinceLastUpdate;                      // 0x0844(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrevAimPitch;                                      // 0x0848(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimYaw;                                            // 0x084C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootYawOffset;                                     // 0x0850(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootYawOffsetPriorToTurn;                          // 0x0854(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatSpringState                      RootYawOffsetSpringState;                          // 0x0858(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TurnYawCurveValue;                                 // 0x0860(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrevTurnYawCurveValue;                             // 0x0864(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurningInPlace;                                   // 0x0868(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGBAnimRootYawOffsetMode                      RootYawOffsetMode;                                 // 0x0869(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86A[0x1A];                                     // 0x086A(0x001A)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DynamicLeftHandIKRoot_BoneName;                    // 0x0884(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UsedDynamicLeftHandIKRoot;                         // 0x088C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DynamicLeftHandIKRoot_LocOffset;                   // 0x0890(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DynamicLeftHandIKRoot_RotOffset;                   // 0x089C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   DynamicRightHandIKRoot_BoneName;                   // 0x08A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UsedDynamicRightHandIKRoot;                        // 0x08B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DynamicRightItemRoot_BoneName;                     // 0x08B4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UseDynamicRightItemRoot;                           // 0x08BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilBlendAlpha;                                  // 0x08C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HeadOffset;                                        // 0x08C4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CombinedRecoilSwayOffset;                          // 0x08D0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUpdateFirearmData;                                // 0x08DC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8DD[0x3];                                      // 0x08DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EquippedRotationalInertiaModifier;                 // 0x08E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHalfHeight;                                 // 0x08E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnLadder;                                       // 0x08E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E9[0x3];                                      // 0x08E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LadderTop;                                         // 0x08EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExitLadderTop;                                    // 0x08F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F1[0x3];                                      // 0x08F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LadderDistance;                                    // 0x08F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationalIInertiaExpConstant;                     // 0x08F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationalInertiaRecoverySpeed;                    // 0x08FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MaxEquippedRotationalInertiaOffset;                // 0x0900(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               EquippedRotationalInertiaOffset;                   // 0x090C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_918[0x14];                                     // 0x0918(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FirearmRootRotation;                               // 0x092C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               FirearmRootRotationReversed;                       // 0x0938(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              MovementSwayWalk;                                  // 0x0944(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MovementSwayRun;                                   // 0x094C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_954[0xC];                                      // 0x0954(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBCharAnimInstanceProxy) == 0x000010, "Wrong alignment on FGBCharAnimInstanceProxy");
static_assert(sizeof(FGBCharAnimInstanceProxy) == 0x000960, "Wrong size on FGBCharAnimInstanceProxy");
static_assert(offsetof(FGBCharAnimInstanceProxy, BaseAimRotation) == 0x00078C, "Member 'FGBCharAnimInstanceProxy::BaseAimRotation' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, CharacterGravityZ) == 0x000798, "Member 'FGBCharAnimInstanceProxy::CharacterGravityZ' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, MovementMode) == 0x00079C, "Member 'FGBCharAnimInstanceProxy::MovementMode' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bIsOnGround) == 0x00079D, "Member 'FGBCharAnimInstanceProxy::bIsOnGround' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bHasVeloctyOrAcceleration) == 0x00079E, "Member 'FGBCharAnimInstanceProxy::bHasVeloctyOrAcceleration' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bIsCrouching) == 0x00079F, "Member 'FGBCharAnimInstanceProxy::bIsCrouching' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, CrouchAlpha) == 0x0007A0, "Member 'FGBCharAnimInstanceProxy::CrouchAlpha' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bIsProne) == 0x0007A4, "Member 'FGBCharAnimInstanceProxy::bIsProne' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, LeanAlpha) == 0x0007A8, "Member 'FGBCharAnimInstanceProxy::LeanAlpha' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bIsRunning) == 0x0007AC, "Member 'FGBCharAnimInstanceProxy::bIsRunning' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bIsSprinting) == 0x0007AD, "Member 'FGBCharAnimInstanceProxy::bIsSprinting' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bWasCrouchingLastUpdate) == 0x0007AE, "Member 'FGBCharAnimInstanceProxy::bWasCrouchingLastUpdate' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bCrouchStateChanged) == 0x0007AF, "Member 'FGBCharAnimInstanceProxy::bCrouchStateChanged' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bWasProneLastUpdate) == 0x0007B0, "Member 'FGBCharAnimInstanceProxy::bWasProneLastUpdate' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bProneStateChanged) == 0x0007B1, "Member 'FGBCharAnimInstanceProxy::bProneStateChanged' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bIsJumping) == 0x0007B2, "Member 'FGBCharAnimInstanceProxy::bIsJumping' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bIsFalling) == 0x0007B3, "Member 'FGBCharAnimInstanceProxy::bIsFalling' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, TimeToJumpApex) == 0x0007B4, "Member 'FGBCharAnimInstanceProxy::TimeToJumpApex' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bIsRunningIntoWall) == 0x0007B8, "Member 'FGBCharAnimInstanceProxy::bIsRunningIntoWall' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, WorldLocation) == 0x0007BC, "Member 'FGBCharAnimInstanceProxy::WorldLocation' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, DisplacementSinceLastUpdate) == 0x0007C8, "Member 'FGBCharAnimInstanceProxy::DisplacementSinceLastUpdate' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, DisplacementSpeed) == 0x0007CC, "Member 'FGBCharAnimInstanceProxy::DisplacementSpeed' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, WorldRotation) == 0x0007D0, "Member 'FGBCharAnimInstanceProxy::WorldRotation' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, YawDeltaSinceLastUpdate) == 0x0007DC, "Member 'FGBCharAnimInstanceProxy::YawDeltaSinceLastUpdate' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, YawDeltaSpeed) == 0x0007E0, "Member 'FGBCharAnimInstanceProxy::YawDeltaSpeed' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, AdditiveLeanAngle) == 0x0007E4, "Member 'FGBCharAnimInstanceProxy::AdditiveLeanAngle' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, WorldVelocity) == 0x0007E8, "Member 'FGBCharAnimInstanceProxy::WorldVelocity' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, LocalVelocity2D) == 0x0007F4, "Member 'FGBCharAnimInstanceProxy::LocalVelocity2D' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, LocalVelocityDirectionAngle) == 0x000800, "Member 'FGBCharAnimInstanceProxy::LocalVelocityDirectionAngle' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, LocalVelocityDirectionAngleWithOffset) == 0x000804, "Member 'FGBCharAnimInstanceProxy::LocalVelocityDirectionAngleWithOffset' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, LocalVelocityDirection) == 0x000808, "Member 'FGBCharAnimInstanceProxy::LocalVelocityDirection' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, LocalVelocityDirectionNoOffset) == 0x000809, "Member 'FGBCharAnimInstanceProxy::LocalVelocityDirectionNoOffset' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bHasVelocity) == 0x00080A, "Member 'FGBCharAnimInstanceProxy::bHasVelocity' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, OrientationWarpingAngle) == 0x00080C, "Member 'FGBCharAnimInstanceProxy::OrientationWarpingAngle' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, WorldAcceleration2D) == 0x000814, "Member 'FGBCharAnimInstanceProxy::WorldAcceleration2D' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, LocalAcceleration2D) == 0x000820, "Member 'FGBCharAnimInstanceProxy::LocalAcceleration2D' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, PivotDirection2D) == 0x00082C, "Member 'FGBCharAnimInstanceProxy::PivotDirection2D' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, DirectionFromAcceleration) == 0x000838, "Member 'FGBCharAnimInstanceProxy::DirectionFromAcceleration' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bHasAcceleration) == 0x000839, "Member 'FGBCharAnimInstanceProxy::bHasAcceleration' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, UpperbodyDynamicAdditiveWeight) == 0x00083C, "Member 'FGBCharAnimInstanceProxy::UpperbodyDynamicAdditiveWeight' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, AimPitch) == 0x000840, "Member 'FGBCharAnimInstanceProxy::AimPitch' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, AimPitchDeltaSinceLastUpdate) == 0x000844, "Member 'FGBCharAnimInstanceProxy::AimPitchDeltaSinceLastUpdate' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, PrevAimPitch) == 0x000848, "Member 'FGBCharAnimInstanceProxy::PrevAimPitch' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, AimYaw) == 0x00084C, "Member 'FGBCharAnimInstanceProxy::AimYaw' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, RootYawOffset) == 0x000850, "Member 'FGBCharAnimInstanceProxy::RootYawOffset' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, RootYawOffsetPriorToTurn) == 0x000854, "Member 'FGBCharAnimInstanceProxy::RootYawOffsetPriorToTurn' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, RootYawOffsetSpringState) == 0x000858, "Member 'FGBCharAnimInstanceProxy::RootYawOffsetSpringState' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, TurnYawCurveValue) == 0x000860, "Member 'FGBCharAnimInstanceProxy::TurnYawCurveValue' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, PrevTurnYawCurveValue) == 0x000864, "Member 'FGBCharAnimInstanceProxy::PrevTurnYawCurveValue' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bTurningInPlace) == 0x000868, "Member 'FGBCharAnimInstanceProxy::bTurningInPlace' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, RootYawOffsetMode) == 0x000869, "Member 'FGBCharAnimInstanceProxy::RootYawOffsetMode' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, DynamicLeftHandIKRoot_BoneName) == 0x000884, "Member 'FGBCharAnimInstanceProxy::DynamicLeftHandIKRoot_BoneName' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, UsedDynamicLeftHandIKRoot) == 0x00088C, "Member 'FGBCharAnimInstanceProxy::UsedDynamicLeftHandIKRoot' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, DynamicLeftHandIKRoot_LocOffset) == 0x000890, "Member 'FGBCharAnimInstanceProxy::DynamicLeftHandIKRoot_LocOffset' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, DynamicLeftHandIKRoot_RotOffset) == 0x00089C, "Member 'FGBCharAnimInstanceProxy::DynamicLeftHandIKRoot_RotOffset' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, DynamicRightHandIKRoot_BoneName) == 0x0008A8, "Member 'FGBCharAnimInstanceProxy::DynamicRightHandIKRoot_BoneName' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, UsedDynamicRightHandIKRoot) == 0x0008B0, "Member 'FGBCharAnimInstanceProxy::UsedDynamicRightHandIKRoot' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, DynamicRightItemRoot_BoneName) == 0x0008B4, "Member 'FGBCharAnimInstanceProxy::DynamicRightItemRoot_BoneName' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, UseDynamicRightItemRoot) == 0x0008BC, "Member 'FGBCharAnimInstanceProxy::UseDynamicRightItemRoot' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, RecoilBlendAlpha) == 0x0008C0, "Member 'FGBCharAnimInstanceProxy::RecoilBlendAlpha' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, HeadOffset) == 0x0008C4, "Member 'FGBCharAnimInstanceProxy::HeadOffset' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, CombinedRecoilSwayOffset) == 0x0008D0, "Member 'FGBCharAnimInstanceProxy::CombinedRecoilSwayOffset' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bUpdateFirearmData) == 0x0008DC, "Member 'FGBCharAnimInstanceProxy::bUpdateFirearmData' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, EquippedRotationalInertiaModifier) == 0x0008E0, "Member 'FGBCharAnimInstanceProxy::EquippedRotationalInertiaModifier' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, CapsuleHalfHeight) == 0x0008E4, "Member 'FGBCharAnimInstanceProxy::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bIsOnLadder) == 0x0008E8, "Member 'FGBCharAnimInstanceProxy::bIsOnLadder' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, LadderTop) == 0x0008EC, "Member 'FGBCharAnimInstanceProxy::LadderTop' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, bExitLadderTop) == 0x0008F0, "Member 'FGBCharAnimInstanceProxy::bExitLadderTop' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, LadderDistance) == 0x0008F4, "Member 'FGBCharAnimInstanceProxy::LadderDistance' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, RotationalIInertiaExpConstant) == 0x0008F8, "Member 'FGBCharAnimInstanceProxy::RotationalIInertiaExpConstant' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, RotationalInertiaRecoverySpeed) == 0x0008FC, "Member 'FGBCharAnimInstanceProxy::RotationalInertiaRecoverySpeed' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, MaxEquippedRotationalInertiaOffset) == 0x000900, "Member 'FGBCharAnimInstanceProxy::MaxEquippedRotationalInertiaOffset' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, EquippedRotationalInertiaOffset) == 0x00090C, "Member 'FGBCharAnimInstanceProxy::EquippedRotationalInertiaOffset' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, FirearmRootRotation) == 0x00092C, "Member 'FGBCharAnimInstanceProxy::FirearmRootRotation' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, FirearmRootRotationReversed) == 0x000938, "Member 'FGBCharAnimInstanceProxy::FirearmRootRotationReversed' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, MovementSwayWalk) == 0x000944, "Member 'FGBCharAnimInstanceProxy::MovementSwayWalk' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceProxy, MovementSwayRun) == 0x00094C, "Member 'FGBCharAnimInstanceProxy::MovementSwayRun' has a wrong offset!");

// ScriptStruct GroundBranch.GBAnimDirectionSequences
// 0x0040 (0x0040 - 0x0000)
struct FGBAnimDirectionSequences final
{
public:
	class UAnimSequence*                          Forward;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ForwardLeft;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ForwardRight;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Backward;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BackwardLeft;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BackwardRight;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Left;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Right;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBAnimDirectionSequences) == 0x000008, "Wrong alignment on FGBAnimDirectionSequences");
static_assert(sizeof(FGBAnimDirectionSequences) == 0x000040, "Wrong size on FGBAnimDirectionSequences");
static_assert(offsetof(FGBAnimDirectionSequences, Forward) == 0x000000, "Member 'FGBAnimDirectionSequences::Forward' has a wrong offset!");
static_assert(offsetof(FGBAnimDirectionSequences, ForwardLeft) == 0x000008, "Member 'FGBAnimDirectionSequences::ForwardLeft' has a wrong offset!");
static_assert(offsetof(FGBAnimDirectionSequences, ForwardRight) == 0x000010, "Member 'FGBAnimDirectionSequences::ForwardRight' has a wrong offset!");
static_assert(offsetof(FGBAnimDirectionSequences, Backward) == 0x000018, "Member 'FGBAnimDirectionSequences::Backward' has a wrong offset!");
static_assert(offsetof(FGBAnimDirectionSequences, BackwardLeft) == 0x000020, "Member 'FGBAnimDirectionSequences::BackwardLeft' has a wrong offset!");
static_assert(offsetof(FGBAnimDirectionSequences, BackwardRight) == 0x000028, "Member 'FGBAnimDirectionSequences::BackwardRight' has a wrong offset!");
static_assert(offsetof(FGBAnimDirectionSequences, Left) == 0x000030, "Member 'FGBAnimDirectionSequences::Left' has a wrong offset!");
static_assert(offsetof(FGBAnimDirectionSequences, Right) == 0x000038, "Member 'FGBAnimDirectionSequences::Right' has a wrong offset!");

// ScriptStruct GroundBranch.GBCharAnimInstanceLayerProxy
// 0x0080 (0x07F0 - 0x0770)
struct FGBCharAnimInstanceLayerProxy final : public FAnimInstanceProxy
{
public:
	EGBAnimDirection                              LocalVelocityDirectionNoOffset;                    // 0x0770(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_771[0x3];                                      // 0x0771(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrouchAlpha;                                       // 0x0774(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAlpha;                                         // 0x0778(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsProne;                                          // 0x077C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRunning;                                        // 0x077D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSprinting;                                      // 0x077E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasVelocity;                                      // 0x077F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimPitch;                                          // 0x0780(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimYaw;                                            // 0x0784(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FirearmRootRotation;                               // 0x0788(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               FirearmRootRotationReversed;                       // 0x0794(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CombinedRecoilSwayOffset;                          // 0x07A0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               EquippedRotationalInertiaOffset;                   // 0x07AC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              MovementSwayWalk;                                  // 0x07B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MovementSwayRun;                                   // 0x07C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngagedAlpha;                                      // 0x07C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7CC[0x4];                                      // 0x07CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OffTargetAlpha;                                    // 0x07D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D4[0x4];                                      // 0x07D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowReadyHighExplicitTime;                          // 0x07D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerFingerExplicitTime;                         // 0x07DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E0[0x10];                                     // 0x07E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBCharAnimInstanceLayerProxy) == 0x000010, "Wrong alignment on FGBCharAnimInstanceLayerProxy");
static_assert(sizeof(FGBCharAnimInstanceLayerProxy) == 0x0007F0, "Wrong size on FGBCharAnimInstanceLayerProxy");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, LocalVelocityDirectionNoOffset) == 0x000770, "Member 'FGBCharAnimInstanceLayerProxy::LocalVelocityDirectionNoOffset' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, CrouchAlpha) == 0x000774, "Member 'FGBCharAnimInstanceLayerProxy::CrouchAlpha' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, LeanAlpha) == 0x000778, "Member 'FGBCharAnimInstanceLayerProxy::LeanAlpha' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, bIsProne) == 0x00077C, "Member 'FGBCharAnimInstanceLayerProxy::bIsProne' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, bIsRunning) == 0x00077D, "Member 'FGBCharAnimInstanceLayerProxy::bIsRunning' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, bIsSprinting) == 0x00077E, "Member 'FGBCharAnimInstanceLayerProxy::bIsSprinting' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, bHasVelocity) == 0x00077F, "Member 'FGBCharAnimInstanceLayerProxy::bHasVelocity' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, AimPitch) == 0x000780, "Member 'FGBCharAnimInstanceLayerProxy::AimPitch' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, AimYaw) == 0x000784, "Member 'FGBCharAnimInstanceLayerProxy::AimYaw' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, FirearmRootRotation) == 0x000788, "Member 'FGBCharAnimInstanceLayerProxy::FirearmRootRotation' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, FirearmRootRotationReversed) == 0x000794, "Member 'FGBCharAnimInstanceLayerProxy::FirearmRootRotationReversed' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, CombinedRecoilSwayOffset) == 0x0007A0, "Member 'FGBCharAnimInstanceLayerProxy::CombinedRecoilSwayOffset' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, EquippedRotationalInertiaOffset) == 0x0007AC, "Member 'FGBCharAnimInstanceLayerProxy::EquippedRotationalInertiaOffset' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, MovementSwayWalk) == 0x0007B8, "Member 'FGBCharAnimInstanceLayerProxy::MovementSwayWalk' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, MovementSwayRun) == 0x0007C0, "Member 'FGBCharAnimInstanceLayerProxy::MovementSwayRun' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, EngagedAlpha) == 0x0007C8, "Member 'FGBCharAnimInstanceLayerProxy::EngagedAlpha' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, OffTargetAlpha) == 0x0007D0, "Member 'FGBCharAnimInstanceLayerProxy::OffTargetAlpha' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, LowReadyHighExplicitTime) == 0x0007D8, "Member 'FGBCharAnimInstanceLayerProxy::LowReadyHighExplicitTime' has a wrong offset!");
static_assert(offsetof(FGBCharAnimInstanceLayerProxy, TriggerFingerExplicitTime) == 0x0007DC, "Member 'FGBCharAnimInstanceLayerProxy::TriggerFingerExplicitTime' has a wrong offset!");

// ScriptStruct GroundBranch.GBGameplayAbilityInputData
// 0x0010 (0x0018 - 0x0008)
struct FGBGameplayAbilityInputData final : public FTableRowBase
{
public:
	TSubclassOf<class UGBGameplayAbility>         GameplayAbilityClass;                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGBInputId                                    InputID;                                           // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBGameplayAbilityInputData) == 0x000008, "Wrong alignment on FGBGameplayAbilityInputData");
static_assert(sizeof(FGBGameplayAbilityInputData) == 0x000018, "Wrong size on FGBGameplayAbilityInputData");
static_assert(offsetof(FGBGameplayAbilityInputData, GameplayAbilityClass) == 0x000008, "Member 'FGBGameplayAbilityInputData::GameplayAbilityClass' has a wrong offset!");
static_assert(offsetof(FGBGameplayAbilityInputData, InputID) == 0x000010, "Member 'FGBGameplayAbilityInputData::InputID' has a wrong offset!");

// ScriptStruct GroundBranch.CharVoiceMessage
// 0x0048 (0x0048 - 0x0000)
struct FCharVoiceMessage final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           VoiceAudioEvent;                                   // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharVoiceMessage) == 0x000008, "Wrong alignment on FCharVoiceMessage");
static_assert(sizeof(FCharVoiceMessage) == 0x000048, "Wrong size on FCharVoiceMessage");
static_assert(offsetof(FCharVoiceMessage, Key) == 0x000000, "Member 'FCharVoiceMessage::Key' has a wrong offset!");
static_assert(offsetof(FCharVoiceMessage, DisplayName) == 0x000008, "Member 'FCharVoiceMessage::DisplayName' has a wrong offset!");
static_assert(offsetof(FCharVoiceMessage, VoiceAudioEvent) == 0x000020, "Member 'FCharVoiceMessage::VoiceAudioEvent' has a wrong offset!");

// ScriptStruct GroundBranch.GBSeasonalWeather
// 0x0018 (0x0018 - 0x0000)
struct FGBSeasonalWeather final
{
public:
	class USkyCreatorWeatherPreset*               WeatherType;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RelativeIncidence;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartHour;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBSeasonalWeather) == 0x000008, "Wrong alignment on FGBSeasonalWeather");
static_assert(sizeof(FGBSeasonalWeather) == 0x000018, "Wrong size on FGBSeasonalWeather");
static_assert(offsetof(FGBSeasonalWeather, WeatherType) == 0x000000, "Member 'FGBSeasonalWeather::WeatherType' has a wrong offset!");
static_assert(offsetof(FGBSeasonalWeather, RelativeIncidence) == 0x000008, "Member 'FGBSeasonalWeather::RelativeIncidence' has a wrong offset!");
static_assert(offsetof(FGBSeasonalWeather, StartHour) == 0x00000C, "Member 'FGBSeasonalWeather::StartHour' has a wrong offset!");
static_assert(offsetof(FGBSeasonalWeather, Duration) == 0x000010, "Member 'FGBSeasonalWeather::Duration' has a wrong offset!");

// ScriptStruct GroundBranch.GBClimateSettings
// 0x0060 (0x0060 - 0x0000)
struct FGBClimateSettings final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FGBSeasonalWeather>             SpringWeather;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGBSeasonalWeather>             SummerWeather;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGBSeasonalWeather>             AutumnWeather;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGBSeasonalWeather>             WinterWeather;                                     // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBClimateSettings) == 0x000008, "Wrong alignment on FGBClimateSettings");
static_assert(sizeof(FGBClimateSettings) == 0x000060, "Wrong size on FGBClimateSettings");
static_assert(offsetof(FGBClimateSettings, Name) == 0x000000, "Member 'FGBClimateSettings::Name' has a wrong offset!");
static_assert(offsetof(FGBClimateSettings, Description) == 0x000008, "Member 'FGBClimateSettings::Description' has a wrong offset!");
static_assert(offsetof(FGBClimateSettings, SpringWeather) == 0x000020, "Member 'FGBClimateSettings::SpringWeather' has a wrong offset!");
static_assert(offsetof(FGBClimateSettings, SummerWeather) == 0x000030, "Member 'FGBClimateSettings::SummerWeather' has a wrong offset!");
static_assert(offsetof(FGBClimateSettings, AutumnWeather) == 0x000040, "Member 'FGBClimateSettings::AutumnWeather' has a wrong offset!");
static_assert(offsetof(FGBClimateSettings, WinterWeather) == 0x000050, "Member 'FGBClimateSettings::WinterWeather' has a wrong offset!");

// ScriptStruct GroundBranch.GBOrganDamageEvent
// 0x0088 (0x0098 - 0x0010)
struct FGBOrganDamageEvent final : public FDamageEvent
{
public:
	int32                                         Damage;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BulletIndex;                                       // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StatKey;                                           // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              DamageDirection;                                   // 0x0028(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OrganHits;                                         // 0x0038(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<float>                                 OrganDamages;                                      // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     EntryPoints;                                       // 0x0058(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<float>                                 EntryDamages;                                      // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     ExitPoints;                                        // 0x0078(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<float>                                 ExitDamages;                                       // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBOrganDamageEvent) == 0x000008, "Wrong alignment on FGBOrganDamageEvent");
static_assert(sizeof(FGBOrganDamageEvent) == 0x000098, "Wrong size on FGBOrganDamageEvent");
static_assert(offsetof(FGBOrganDamageEvent, Damage) == 0x000010, "Member 'FGBOrganDamageEvent::Damage' has a wrong offset!");
static_assert(offsetof(FGBOrganDamageEvent, BulletIndex) == 0x000014, "Member 'FGBOrganDamageEvent::BulletIndex' has a wrong offset!");
static_assert(offsetof(FGBOrganDamageEvent, StatKey) == 0x000018, "Member 'FGBOrganDamageEvent::StatKey' has a wrong offset!");
static_assert(offsetof(FGBOrganDamageEvent, DamageDirection) == 0x000028, "Member 'FGBOrganDamageEvent::DamageDirection' has a wrong offset!");
static_assert(offsetof(FGBOrganDamageEvent, OrganHits) == 0x000038, "Member 'FGBOrganDamageEvent::OrganHits' has a wrong offset!");
static_assert(offsetof(FGBOrganDamageEvent, OrganDamages) == 0x000048, "Member 'FGBOrganDamageEvent::OrganDamages' has a wrong offset!");
static_assert(offsetof(FGBOrganDamageEvent, EntryPoints) == 0x000058, "Member 'FGBOrganDamageEvent::EntryPoints' has a wrong offset!");
static_assert(offsetof(FGBOrganDamageEvent, EntryDamages) == 0x000068, "Member 'FGBOrganDamageEvent::EntryDamages' has a wrong offset!");
static_assert(offsetof(FGBOrganDamageEvent, ExitPoints) == 0x000078, "Member 'FGBOrganDamageEvent::ExitPoints' has a wrong offset!");
static_assert(offsetof(FGBOrganDamageEvent, ExitDamages) == 0x000088, "Member 'FGBOrganDamageEvent::ExitDamages' has a wrong offset!");

// ScriptStruct GroundBranch.GBReplicatedSwing
// 0x000C (0x000C - 0x0000)
struct FGBReplicatedSwing final
{
public:
	uint8                                         Flags;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YawAngle;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawSpeed;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBReplicatedSwing) == 0x000004, "Wrong alignment on FGBReplicatedSwing");
static_assert(sizeof(FGBReplicatedSwing) == 0x00000C, "Wrong size on FGBReplicatedSwing");
static_assert(offsetof(FGBReplicatedSwing, Flags) == 0x000000, "Member 'FGBReplicatedSwing::Flags' has a wrong offset!");
static_assert(offsetof(FGBReplicatedSwing, YawAngle) == 0x000004, "Member 'FGBReplicatedSwing::YawAngle' has a wrong offset!");
static_assert(offsetof(FGBReplicatedSwing, YawSpeed) == 0x000008, "Member 'FGBReplicatedSwing::YawSpeed' has a wrong offset!");

// ScriptStruct GroundBranch.FiringModeData
// 0x0008 (0x0008 - 0x0000)
struct FFiringModeData final
{
public:
	uint8                                         BurstCount;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RateOfFire;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFiringModeData) == 0x000004, "Wrong alignment on FFiringModeData");
static_assert(sizeof(FFiringModeData) == 0x000008, "Wrong size on FFiringModeData");
static_assert(offsetof(FFiringModeData, BurstCount) == 0x000000, "Member 'FFiringModeData::BurstCount' has a wrong offset!");
static_assert(offsetof(FFiringModeData, RateOfFire) == 0x000004, "Member 'FFiringModeData::RateOfFire' has a wrong offset!");

// ScriptStruct GroundBranch.GBFoliageQuickrefInstance
// 0x0050 (0x0050 - 0x0000)
struct FGBFoliageQuickrefInstance final
{
public:
	int32                                         InstanceIndex;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BearingToBombOrigin;                               // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBFoliageQuickrefInstance) == 0x000010, "Wrong alignment on FGBFoliageQuickrefInstance");
static_assert(sizeof(FGBFoliageQuickrefInstance) == 0x000050, "Wrong size on FGBFoliageQuickrefInstance");
static_assert(offsetof(FGBFoliageQuickrefInstance, InstanceIndex) == 0x000000, "Member 'FGBFoliageQuickrefInstance::InstanceIndex' has a wrong offset!");
static_assert(offsetof(FGBFoliageQuickrefInstance, Transform) == 0x000010, "Member 'FGBFoliageQuickrefInstance::Transform' has a wrong offset!");
static_assert(offsetof(FGBFoliageQuickrefInstance, Distance) == 0x000040, "Member 'FGBFoliageQuickrefInstance::Distance' has a wrong offset!");
static_assert(offsetof(FGBFoliageQuickrefInstance, BearingToBombOrigin) == 0x000044, "Member 'FGBFoliageQuickrefInstance::BearingToBombOrigin' has a wrong offset!");

// ScriptStruct GroundBranch.GBFoliageQuickref
// 0x0018 (0x0018 - 0x0000)
struct FGBFoliageQuickref final
{
public:
	class UFoliageInstancedStaticMeshComponent*   FoliageComponent;                                  // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGBFoliageQuickrefInstance>     RelevantInstances;                                 // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBFoliageQuickref) == 0x000008, "Wrong alignment on FGBFoliageQuickref");
static_assert(sizeof(FGBFoliageQuickref) == 0x000018, "Wrong size on FGBFoliageQuickref");
static_assert(offsetof(FGBFoliageQuickref, FoliageComponent) == 0x000000, "Member 'FGBFoliageQuickref::FoliageComponent' has a wrong offset!");
static_assert(offsetof(FGBFoliageQuickref, RelevantInstances) == 0x000008, "Member 'FGBFoliageQuickref::RelevantInstances' has a wrong offset!");

// ScriptStruct GroundBranch.SequenceQueueItem
// 0x0030 (0x0030 - 0x0000)
struct FSequenceQueueItem final
{
public:
	TSoftObjectPtr<class ALevelSequenceActor>     LevelSequenceActor;                                // 0x0000(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCutscene;                                       // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAbort;                                         // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSequenceQueueItem) == 0x000008, "Wrong alignment on FSequenceQueueItem");
static_assert(sizeof(FSequenceQueueItem) == 0x000030, "Wrong size on FSequenceQueueItem");
static_assert(offsetof(FSequenceQueueItem, LevelSequenceActor) == 0x000000, "Member 'FSequenceQueueItem::LevelSequenceActor' has a wrong offset!");
static_assert(offsetof(FSequenceQueueItem, bIsCutscene) == 0x000028, "Member 'FSequenceQueueItem::bIsCutscene' has a wrong offset!");
static_assert(offsetof(FSequenceQueueItem, bCanAbort) == 0x000029, "Member 'FSequenceQueueItem::bCanAbort' has a wrong offset!");

// ScriptStruct GroundBranch.GBSpawnInfo
// 0x0014 (0x0014 - 0x0000)
struct FGBSpawnInfo final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Direction;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGBPlayerStance                               stance;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBSpawnInfo) == 0x000004, "Wrong alignment on FGBSpawnInfo");
static_assert(sizeof(FGBSpawnInfo) == 0x000014, "Wrong size on FGBSpawnInfo");
static_assert(offsetof(FGBSpawnInfo, Location) == 0x000000, "Member 'FGBSpawnInfo::Location' has a wrong offset!");
static_assert(offsetof(FGBSpawnInfo, Direction) == 0x00000C, "Member 'FGBSpawnInfo::Direction' has a wrong offset!");
static_assert(offsetof(FGBSpawnInfo, stance) == 0x000010, "Member 'FGBSpawnInfo::stance' has a wrong offset!");

// ScriptStruct GroundBranch.GBMatchInfo
// 0x0004 (0x0004 - 0x0000)
struct FGBMatchInfo final
{
public:
	EGBMatchType                                  MatchType;                                         // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RoundLimit;                                        // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RedTeamRoundsWon;                                  // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BlueTeamRoundsWon;                                 // 0x0003(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBMatchInfo) == 0x000001, "Wrong alignment on FGBMatchInfo");
static_assert(sizeof(FGBMatchInfo) == 0x000004, "Wrong size on FGBMatchInfo");
static_assert(offsetof(FGBMatchInfo, MatchType) == 0x000000, "Member 'FGBMatchInfo::MatchType' has a wrong offset!");
static_assert(offsetof(FGBMatchInfo, RoundLimit) == 0x000001, "Member 'FGBMatchInfo::RoundLimit' has a wrong offset!");
static_assert(offsetof(FGBMatchInfo, RedTeamRoundsWon) == 0x000002, "Member 'FGBMatchInfo::RedTeamRoundsWon' has a wrong offset!");
static_assert(offsetof(FGBMatchInfo, BlueTeamRoundsWon) == 0x000003, "Member 'FGBMatchInfo::BlueTeamRoundsWon' has a wrong offset!");

// ScriptStruct GroundBranch.DeadBodyData
// 0x0010 (0x0010 - 0x0000)
struct FDeadBodyData final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           PlayerState;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeadBodyData) == 0x000008, "Wrong alignment on FDeadBodyData");
static_assert(sizeof(FDeadBodyData) == 0x000010, "Wrong size on FDeadBodyData");
static_assert(offsetof(FDeadBodyData, Character) == 0x000000, "Member 'FDeadBodyData::Character' has a wrong offset!");
static_assert(offsetof(FDeadBodyData, PlayerState) == 0x000008, "Member 'FDeadBodyData::PlayerState' has a wrong offset!");

// ScriptStruct GroundBranch.BotInfo
// 0x0040 (0x0040 - 0x0000)
struct FBotInfo final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoadoutName;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SquadId;                                           // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBKytController*                       AIController;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGBCharacter*                           Character;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGBKitInfo*                             LoadoutInfo;                                       // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBotInfo) == 0x000008, "Wrong alignment on FBotInfo");
static_assert(sizeof(FBotInfo) == 0x000040, "Wrong size on FBotInfo");
static_assert(offsetof(FBotInfo, Name) == 0x000000, "Member 'FBotInfo::Name' has a wrong offset!");
static_assert(offsetof(FBotInfo, LoadoutName) == 0x000010, "Member 'FBotInfo::LoadoutName' has a wrong offset!");
static_assert(offsetof(FBotInfo, TeamId) == 0x000020, "Member 'FBotInfo::TeamId' has a wrong offset!");
static_assert(offsetof(FBotInfo, SquadId) == 0x000021, "Member 'FBotInfo::SquadId' has a wrong offset!");
static_assert(offsetof(FBotInfo, AIController) == 0x000028, "Member 'FBotInfo::AIController' has a wrong offset!");
static_assert(offsetof(FBotInfo, Character) == 0x000030, "Member 'FBotInfo::Character' has a wrong offset!");
static_assert(offsetof(FBotInfo, LoadoutInfo) == 0x000038, "Member 'FBotInfo::LoadoutInfo' has a wrong offset!");

// ScriptStruct GroundBranch.GBAbilitySet_GameplayAbility
// 0x0010 (0x0010 - 0x0000)
struct FGBAbilitySet_GameplayAbility final
{
public:
	TSubclassOf<class UGBGameplayAbility>         Ability;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGBInputId                                    InputID;                                           // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBAbilitySet_GameplayAbility) == 0x000008, "Wrong alignment on FGBAbilitySet_GameplayAbility");
static_assert(sizeof(FGBAbilitySet_GameplayAbility) == 0x000010, "Wrong size on FGBAbilitySet_GameplayAbility");
static_assert(offsetof(FGBAbilitySet_GameplayAbility, Ability) == 0x000000, "Member 'FGBAbilitySet_GameplayAbility::Ability' has a wrong offset!");
static_assert(offsetof(FGBAbilitySet_GameplayAbility, InputID) == 0x000008, "Member 'FGBAbilitySet_GameplayAbility::InputID' has a wrong offset!");

// ScriptStruct GroundBranch.ReplicatedAlpha
// 0x000C (0x000C - 0x0000)
struct FReplicatedAlpha final
{
public:
	uint8                                         Current;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Target;                                            // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Timestamp;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnsureRep;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedAlpha) == 0x000004, "Wrong alignment on FReplicatedAlpha");
static_assert(sizeof(FReplicatedAlpha) == 0x00000C, "Wrong size on FReplicatedAlpha");
static_assert(offsetof(FReplicatedAlpha, Current) == 0x000000, "Member 'FReplicatedAlpha::Current' has a wrong offset!");
static_assert(offsetof(FReplicatedAlpha, Target) == 0x000001, "Member 'FReplicatedAlpha::Target' has a wrong offset!");
static_assert(offsetof(FReplicatedAlpha, Timestamp) == 0x000004, "Member 'FReplicatedAlpha::Timestamp' has a wrong offset!");
static_assert(offsetof(FReplicatedAlpha, EnsureRep) == 0x000008, "Member 'FReplicatedAlpha::EnsureRep' has a wrong offset!");

// ScriptStruct GroundBranch.GBNameToGameplayTagTableRow
// 0x0008 (0x0010 - 0x0008)
struct FGBNameToGameplayTagTableRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBNameToGameplayTagTableRow) == 0x000008, "Wrong alignment on FGBNameToGameplayTagTableRow");
static_assert(sizeof(FGBNameToGameplayTagTableRow) == 0x000010, "Wrong size on FGBNameToGameplayTagTableRow");
static_assert(offsetof(FGBNameToGameplayTagTableRow, Tag) == 0x000008, "Member 'FGBNameToGameplayTagTableRow::Tag' has a wrong offset!");

// ScriptStruct GroundBranch.GBServerBasicInfo
// 0x0030 (0x0030 - 0x0000)
struct FGBServerBasicInfo final
{
public:
	class FString                                 ServerName;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerMOTD;                                        // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerWebBanner;                                   // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBServerBasicInfo) == 0x000008, "Wrong alignment on FGBServerBasicInfo");
static_assert(sizeof(FGBServerBasicInfo) == 0x000030, "Wrong size on FGBServerBasicInfo");
static_assert(offsetof(FGBServerBasicInfo, ServerName) == 0x000000, "Member 'FGBServerBasicInfo::ServerName' has a wrong offset!");
static_assert(offsetof(FGBServerBasicInfo, ServerMOTD) == 0x000010, "Member 'FGBServerBasicInfo::ServerMOTD' has a wrong offset!");
static_assert(offsetof(FGBServerBasicInfo, ServerWebBanner) == 0x000020, "Member 'FGBServerBasicInfo::ServerWebBanner' has a wrong offset!");

// ScriptStruct GroundBranch.GBCaptureZone
// 0x000C (0x000C - 0x0000)
struct FGBCaptureZone final
{
public:
	float                                         CaptureRadius;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureHeight;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DefenderTeamId;                                    // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZoneIsSpherical;                                  // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBCaptureZone) == 0x000004, "Wrong alignment on FGBCaptureZone");
static_assert(sizeof(FGBCaptureZone) == 0x00000C, "Wrong size on FGBCaptureZone");
static_assert(offsetof(FGBCaptureZone, CaptureRadius) == 0x000000, "Member 'FGBCaptureZone::CaptureRadius' has a wrong offset!");
static_assert(offsetof(FGBCaptureZone, CaptureHeight) == 0x000004, "Member 'FGBCaptureZone::CaptureHeight' has a wrong offset!");
static_assert(offsetof(FGBCaptureZone, DefenderTeamId) == 0x000008, "Member 'FGBCaptureZone::DefenderTeamId' has a wrong offset!");
static_assert(offsetof(FGBCaptureZone, bZoneIsSpherical) == 0x000009, "Member 'FGBCaptureZone::bZoneIsSpherical' has a wrong offset!");

// ScriptStruct GroundBranch.GBGameObjective
// 0x0010 (0x0010 - 0x0000)
struct FGBGameObjective final
{
public:
	uint8                                         TeamId;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGBGameObjectiveType                          ObjectiveType;                                     // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBGameObjective) == 0x000004, "Wrong alignment on FGBGameObjective");
static_assert(sizeof(FGBGameObjective) == 0x000010, "Wrong size on FGBGameObjective");
static_assert(offsetof(FGBGameObjective, TeamId) == 0x000000, "Member 'FGBGameObjective::TeamId' has a wrong offset!");
static_assert(offsetof(FGBGameObjective, Name) == 0x000004, "Member 'FGBGameObjective::Name' has a wrong offset!");
static_assert(offsetof(FGBGameObjective, ObjectiveType) == 0x00000C, "Member 'FGBGameObjective::ObjectiveType' has a wrong offset!");

// ScriptStruct GroundBranch.GBMissionSetting
// 0x0020 (0x0020 - 0x0000)
struct FGBMissionSetting final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinValue;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxValue;                                          // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentValue;                                      // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBMissionSetting) == 0x000008, "Wrong alignment on FGBMissionSetting");
static_assert(sizeof(FGBMissionSetting) == 0x000020, "Wrong size on FGBMissionSetting");
static_assert(offsetof(FGBMissionSetting, Name) == 0x000000, "Member 'FGBMissionSetting::Name' has a wrong offset!");
static_assert(offsetof(FGBMissionSetting, MinValue) == 0x000010, "Member 'FGBMissionSetting::MinValue' has a wrong offset!");
static_assert(offsetof(FGBMissionSetting, MaxValue) == 0x000014, "Member 'FGBMissionSetting::MaxValue' has a wrong offset!");
static_assert(offsetof(FGBMissionSetting, CurrentValue) == 0x000018, "Member 'FGBMissionSetting::CurrentValue' has a wrong offset!");

// ScriptStruct GroundBranch.GBMissionName
// 0x0020 (0x0020 - 0x0000)
struct FGBMissionName final
{
public:
	class FString                                 AdjectiveKey;                                      // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NounKey;                                           // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBMissionName) == 0x000008, "Wrong alignment on FGBMissionName");
static_assert(sizeof(FGBMissionName) == 0x000020, "Wrong size on FGBMissionName");
static_assert(offsetof(FGBMissionName, AdjectiveKey) == 0x000000, "Member 'FGBMissionName::AdjectiveKey' has a wrong offset!");
static_assert(offsetof(FGBMissionName, NounKey) == 0x000010, "Member 'FGBMissionName::NounKey' has a wrong offset!");

// ScriptStruct GroundBranch.UserAudioVolume
// 0x0028 (0x0028 - 0x0000)
struct FUserAudioVolume final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SoundClass;                                        // 0x0008(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUserAudioVolume) == 0x000008, "Wrong alignment on FUserAudioVolume");
static_assert(sizeof(FUserAudioVolume) == 0x000028, "Wrong size on FUserAudioVolume");
static_assert(offsetof(FUserAudioVolume, Name) == 0x000000, "Member 'FUserAudioVolume::Name' has a wrong offset!");
static_assert(offsetof(FUserAudioVolume, SoundClass) == 0x000008, "Member 'FUserAudioVolume::SoundClass' has a wrong offset!");
static_assert(offsetof(FUserAudioVolume, Volume) == 0x000020, "Member 'FUserAudioVolume::Volume' has a wrong offset!");

// ScriptStruct GroundBranch.HotspotNews
// 0x0018 (0x0018 - 0x0000)
struct FHotspotNews final
{
public:
	int32                                         MinHotspotProgression;                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHotspotProgression;                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           NewsItems;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHotspotNews) == 0x000008, "Wrong alignment on FHotspotNews");
static_assert(sizeof(FHotspotNews) == 0x000018, "Wrong size on FHotspotNews");
static_assert(offsetof(FHotspotNews, MinHotspotProgression) == 0x000000, "Member 'FHotspotNews::MinHotspotProgression' has a wrong offset!");
static_assert(offsetof(FHotspotNews, MaxHotspotProgression) == 0x000004, "Member 'FHotspotNews::MaxHotspotProgression' has a wrong offset!");
static_assert(offsetof(FHotspotNews, NewsItems) == 0x000008, "Member 'FHotspotNews::NewsItems' has a wrong offset!");

// ScriptStruct GroundBranch.GBChangeEquippedInfo
// 0x0020 (0x0020 - 0x0000)
struct FGBChangeEquippedInfo final
{
public:
	class AGBInvItem*                             CurrentLeft;                                       // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGBInvItem*                             CurrentRight;                                      // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGBInvItem*                             PendingLeft;                                       // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGBInvItem*                             PendingRight;                                      // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBChangeEquippedInfo) == 0x000008, "Wrong alignment on FGBChangeEquippedInfo");
static_assert(sizeof(FGBChangeEquippedInfo) == 0x000020, "Wrong size on FGBChangeEquippedInfo");
static_assert(offsetof(FGBChangeEquippedInfo, CurrentLeft) == 0x000000, "Member 'FGBChangeEquippedInfo::CurrentLeft' has a wrong offset!");
static_assert(offsetof(FGBChangeEquippedInfo, CurrentRight) == 0x000008, "Member 'FGBChangeEquippedInfo::CurrentRight' has a wrong offset!");
static_assert(offsetof(FGBChangeEquippedInfo, PendingLeft) == 0x000010, "Member 'FGBChangeEquippedInfo::PendingLeft' has a wrong offset!");
static_assert(offsetof(FGBChangeEquippedInfo, PendingRight) == 0x000018, "Member 'FGBChangeEquippedInfo::PendingRight' has a wrong offset!");

// ScriptStruct GroundBranch.GBUnequipInfo
// 0x0040 (0x0040 - 0x0000)
struct FGBUnequipInfo final
{
public:
	class USceneComponent*                        Component;                                         // 0x0000(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             RelativeTM;                                        // 0x0010(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBUnequipInfo) == 0x000010, "Wrong alignment on FGBUnequipInfo");
static_assert(sizeof(FGBUnequipInfo) == 0x000040, "Wrong size on FGBUnequipInfo");
static_assert(offsetof(FGBUnequipInfo, Component) == 0x000000, "Member 'FGBUnequipInfo::Component' has a wrong offset!");
static_assert(offsetof(FGBUnequipInfo, Socket) == 0x000008, "Member 'FGBUnequipInfo::Socket' has a wrong offset!");
static_assert(offsetof(FGBUnequipInfo, RelativeTM) == 0x000010, "Member 'FGBUnequipInfo::RelativeTM' has a wrong offset!");

// ScriptStruct GroundBranch.GBInvItemSkinMaterialInfo
// 0x0018 (0x0018 - 0x0000)
struct FGBInvItemSkinMaterialInfo final
{
public:
	class FName                                   ComponentName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     Material;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBInvItemSkinMaterialInfo) == 0x000008, "Wrong alignment on FGBInvItemSkinMaterialInfo");
static_assert(sizeof(FGBInvItemSkinMaterialInfo) == 0x000018, "Wrong size on FGBInvItemSkinMaterialInfo");
static_assert(offsetof(FGBInvItemSkinMaterialInfo, ComponentName) == 0x000000, "Member 'FGBInvItemSkinMaterialInfo::ComponentName' has a wrong offset!");
static_assert(offsetof(FGBInvItemSkinMaterialInfo, MaterialIndex) == 0x000008, "Member 'FGBInvItemSkinMaterialInfo::MaterialIndex' has a wrong offset!");
static_assert(offsetof(FGBInvItemSkinMaterialInfo, Material) == 0x000010, "Member 'FGBInvItemSkinMaterialInfo::Material' has a wrong offset!");

// ScriptStruct GroundBranch.GBItemMeshByTagsInfo
// 0x0038 (0x0038 - 0x0000)
struct FGBItemMeshByTagsInfo final
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0000(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Mesh;                                              // 0x0020(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBItemMeshByTagsInfo) == 0x000008, "Wrong alignment on FGBItemMeshByTagsInfo");
static_assert(sizeof(FGBItemMeshByTagsInfo) == 0x000038, "Wrong size on FGBItemMeshByTagsInfo");
static_assert(offsetof(FGBItemMeshByTagsInfo, Tags) == 0x000000, "Member 'FGBItemMeshByTagsInfo::Tags' has a wrong offset!");
static_assert(offsetof(FGBItemMeshByTagsInfo, Mesh) == 0x000020, "Member 'FGBItemMeshByTagsInfo::Mesh' has a wrong offset!");

// ScriptStruct GroundBranch.GBItemMorphByTagsInfo
// 0x0070 (0x0070 - 0x0000)
struct FGBItemMorphByTagsInfo final
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0000(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      MorphTargetNamesAndValues;                         // 0x0020(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBItemMorphByTagsInfo) == 0x000008, "Wrong alignment on FGBItemMorphByTagsInfo");
static_assert(sizeof(FGBItemMorphByTagsInfo) == 0x000070, "Wrong size on FGBItemMorphByTagsInfo");
static_assert(offsetof(FGBItemMorphByTagsInfo, Tags) == 0x000000, "Member 'FGBItemMorphByTagsInfo::Tags' has a wrong offset!");
static_assert(offsetof(FGBItemMorphByTagsInfo, MorphTargetNamesAndValues) == 0x000020, "Member 'FGBItemMorphByTagsInfo::MorphTargetNamesAndValues' has a wrong offset!");

// ScriptStruct GroundBranch.GBUpdateItemHelper
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FGBUpdateItemHelper final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBUpdateItemHelper) == 0x000008, "Wrong alignment on FGBUpdateItemHelper");
static_assert(sizeof(FGBUpdateItemHelper) == 0x000050, "Wrong size on FGBUpdateItemHelper");

// ScriptStruct GroundBranch.GBItemReplacementInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x04) FGBItemReplacementInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBItemReplacementInfo) == 0x000004, "Wrong alignment on FGBItemReplacementInfo");
static_assert(sizeof(FGBItemReplacementInfo) == 0x000030, "Wrong size on FGBItemReplacementInfo");

// ScriptStruct GroundBranch.GBDecodeFailureInfo
// 0x0030 (0x0030 - 0x0000)
struct FGBDecodeFailureInfo final
{
public:
	struct FGameplayTagContainer                  InvItemTags;                                       // 0x0000(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FString>                         Failures;                                          // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBDecodeFailureInfo) == 0x000008, "Wrong alignment on FGBDecodeFailureInfo");
static_assert(sizeof(FGBDecodeFailureInfo) == 0x000030, "Wrong size on FGBDecodeFailureInfo");
static_assert(offsetof(FGBDecodeFailureInfo, InvItemTags) == 0x000000, "Member 'FGBDecodeFailureInfo::InvItemTags' has a wrong offset!");
static_assert(offsetof(FGBDecodeFailureInfo, Failures) == 0x000020, "Member 'FGBDecodeFailureInfo::Failures' has a wrong offset!");

// ScriptStruct GroundBranch.GBKitValidationInfo
// 0x0060 (0x0060 - 0x0000)
struct FGBKitValidationInfo final
{
public:
	class FName                                   LoadoutName;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJsonWasValid;                                     // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbleToBeValidated;                                // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  MissingRequiredInvItemTypeTags;                    // 0x0010(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                ItemFailures;                                      // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                SkinFailures;                                      // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGBDecodeFailureInfo>           DecodeFailures;                                    // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBKitValidationInfo) == 0x000008, "Wrong alignment on FGBKitValidationInfo");
static_assert(sizeof(FGBKitValidationInfo) == 0x000060, "Wrong size on FGBKitValidationInfo");
static_assert(offsetof(FGBKitValidationInfo, LoadoutName) == 0x000000, "Member 'FGBKitValidationInfo::LoadoutName' has a wrong offset!");
static_assert(offsetof(FGBKitValidationInfo, bJsonWasValid) == 0x000008, "Member 'FGBKitValidationInfo::bJsonWasValid' has a wrong offset!");
static_assert(offsetof(FGBKitValidationInfo, bAbleToBeValidated) == 0x000009, "Member 'FGBKitValidationInfo::bAbleToBeValidated' has a wrong offset!");
static_assert(offsetof(FGBKitValidationInfo, MissingRequiredInvItemTypeTags) == 0x000010, "Member 'FGBKitValidationInfo::MissingRequiredInvItemTypeTags' has a wrong offset!");
static_assert(offsetof(FGBKitValidationInfo, ItemFailures) == 0x000030, "Member 'FGBKitValidationInfo::ItemFailures' has a wrong offset!");
static_assert(offsetof(FGBKitValidationInfo, SkinFailures) == 0x000040, "Member 'FGBKitValidationInfo::SkinFailures' has a wrong offset!");
static_assert(offsetof(FGBKitValidationInfo, DecodeFailures) == 0x000050, "Member 'FGBKitValidationInfo::DecodeFailures' has a wrong offset!");

// ScriptStruct GroundBranch.GBPatchAtlasInfo
// 0x0050 (0x0050 - 0x0000)
struct FGBPatchAtlasInfo final
{
public:
	class FString                                 PatchPath;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TintMaterial;                                      // 0x0010(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AssociatedPatchNameTags;                           // 0x0028(0x0020)(NativeAccessSpecifierPublic)
	int32                                         TextureAtlasIndex;                                 // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBPatchAtlasInfo) == 0x000008, "Wrong alignment on FGBPatchAtlasInfo");
static_assert(sizeof(FGBPatchAtlasInfo) == 0x000050, "Wrong size on FGBPatchAtlasInfo");
static_assert(offsetof(FGBPatchAtlasInfo, PatchPath) == 0x000000, "Member 'FGBPatchAtlasInfo::PatchPath' has a wrong offset!");
static_assert(offsetof(FGBPatchAtlasInfo, TintMaterial) == 0x000010, "Member 'FGBPatchAtlasInfo::TintMaterial' has a wrong offset!");
static_assert(offsetof(FGBPatchAtlasInfo, AssociatedPatchNameTags) == 0x000028, "Member 'FGBPatchAtlasInfo::AssociatedPatchNameTags' has a wrong offset!");
static_assert(offsetof(FGBPatchAtlasInfo, TextureAtlasIndex) == 0x000048, "Member 'FGBPatchAtlasInfo::TextureAtlasIndex' has a wrong offset!");

// ScriptStruct GroundBranch.GBMapMarker
// 0x00B0 (0x00B0 - 0x0000)
struct FGBMapMarker final
{
public:
	TSoftClassPtr<class UClass>                   WidgetClassRef;                                    // 0x0000(0x0028)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              position;                                          // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextToken;                                         // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatParam;                                        // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0044(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AGBMissionObjective>     LinkedObjective;                                   // 0x0048(0x0028)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              LinkedMapImageRef;                                 // 0x0070(0x0028)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowOnTablet;                                     // 0x0098(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowOnOpsBoard;                                   // 0x0099(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTooltipOnOpsBoard;                                // 0x009A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowOnCampaignMap;                                // 0x009B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTooltipOnCampaignMap;                             // 0x009C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LinkedOtherImageFilename;                          // 0x00A0(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBMapMarker) == 0x000008, "Wrong alignment on FGBMapMarker");
static_assert(sizeof(FGBMapMarker) == 0x0000B0, "Wrong size on FGBMapMarker");
static_assert(offsetof(FGBMapMarker, WidgetClassRef) == 0x000000, "Member 'FGBMapMarker::WidgetClassRef' has a wrong offset!");
static_assert(offsetof(FGBMapMarker, position) == 0x000028, "Member 'FGBMapMarker::position' has a wrong offset!");
static_assert(offsetof(FGBMapMarker, Scale) == 0x000030, "Member 'FGBMapMarker::Scale' has a wrong offset!");
static_assert(offsetof(FGBMapMarker, Rotation) == 0x000034, "Member 'FGBMapMarker::Rotation' has a wrong offset!");
static_assert(offsetof(FGBMapMarker, TextToken) == 0x000038, "Member 'FGBMapMarker::TextToken' has a wrong offset!");
static_assert(offsetof(FGBMapMarker, FloatParam) == 0x000040, "Member 'FGBMapMarker::FloatParam' has a wrong offset!");
static_assert(offsetof(FGBMapMarker, TeamId) == 0x000044, "Member 'FGBMapMarker::TeamId' has a wrong offset!");
static_assert(offsetof(FGBMapMarker, LinkedObjective) == 0x000048, "Member 'FGBMapMarker::LinkedObjective' has a wrong offset!");
static_assert(offsetof(FGBMapMarker, LinkedMapImageRef) == 0x000070, "Member 'FGBMapMarker::LinkedMapImageRef' has a wrong offset!");
static_assert(offsetof(FGBMapMarker, bShowOnTablet) == 0x000098, "Member 'FGBMapMarker::bShowOnTablet' has a wrong offset!");
static_assert(offsetof(FGBMapMarker, bShowOnOpsBoard) == 0x000099, "Member 'FGBMapMarker::bShowOnOpsBoard' has a wrong offset!");
static_assert(offsetof(FGBMapMarker, bTooltipOnOpsBoard) == 0x00009A, "Member 'FGBMapMarker::bTooltipOnOpsBoard' has a wrong offset!");
static_assert(offsetof(FGBMapMarker, bShowOnCampaignMap) == 0x00009B, "Member 'FGBMapMarker::bShowOnCampaignMap' has a wrong offset!");
static_assert(offsetof(FGBMapMarker, bTooltipOnCampaignMap) == 0x00009C, "Member 'FGBMapMarker::bTooltipOnCampaignMap' has a wrong offset!");
static_assert(offsetof(FGBMapMarker, LinkedOtherImageFilename) == 0x0000A0, "Member 'FGBMapMarker::LinkedOtherImageFilename' has a wrong offset!");

// ScriptStruct GroundBranch.GBMissionImage
// 0x0028 (0x0028 - 0x0000)
struct FGBMissionImage final
{
public:
	class FString                                 ImageFilename;                                     // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TabText;                                           // 0x0010(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBMissionImage) == 0x000008, "Wrong alignment on FGBMissionImage");
static_assert(sizeof(FGBMissionImage) == 0x000028, "Wrong size on FGBMissionImage");
static_assert(offsetof(FGBMissionImage, ImageFilename) == 0x000000, "Member 'FGBMissionImage::ImageFilename' has a wrong offset!");
static_assert(offsetof(FGBMissionImage, TabText) == 0x000010, "Member 'FGBMissionImage::TabText' has a wrong offset!");

// ScriptStruct GroundBranch.GBAILoadoutInfo
// 0x0030 (0x0030 - 0x0000)
struct FGBAILoadoutInfo final
{
public:
	class FString                                 LoadoutFileName;                                   // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoadoutContents;                                   // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoadoutHash;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBAILoadoutInfo) == 0x000008, "Wrong alignment on FGBAILoadoutInfo");
static_assert(sizeof(FGBAILoadoutInfo) == 0x000030, "Wrong size on FGBAILoadoutInfo");
static_assert(offsetof(FGBAILoadoutInfo, LoadoutFileName) == 0x000000, "Member 'FGBAILoadoutInfo::LoadoutFileName' has a wrong offset!");
static_assert(offsetof(FGBAILoadoutInfo, LoadoutContents) == 0x000010, "Member 'FGBAILoadoutInfo::LoadoutContents' has a wrong offset!");
static_assert(offsetof(FGBAILoadoutInfo, LoadoutHash) == 0x000020, "Member 'FGBAILoadoutInfo::LoadoutHash' has a wrong offset!");

// ScriptStruct GroundBranch.GBBotRosterInfo
// 0x0018 (0x0018 - 0x0000)
struct FGBBotRosterInfo final
{
public:
	uint8                                         TeamId;                                            // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Definitions;                                       // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBBotRosterInfo) == 0x000008, "Wrong alignment on FGBBotRosterInfo");
static_assert(sizeof(FGBBotRosterInfo) == 0x000018, "Wrong size on FGBBotRosterInfo");
static_assert(offsetof(FGBBotRosterInfo, TeamId) == 0x000000, "Member 'FGBBotRosterInfo::TeamId' has a wrong offset!");
static_assert(offsetof(FGBBotRosterInfo, Definitions) == 0x000008, "Member 'FGBBotRosterInfo::Definitions' has a wrong offset!");

// ScriptStruct GroundBranch.GBSingleObjectiveData
// 0x0030 (0x0030 - 0x0000)
struct FGBSingleObjectiveData final
{
public:
	class FName                                   ObjectiveType;                                     // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ObjectiveTitle;                                    // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ListDisplayPriority;                               // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPrimaryObjective;                               // 0x001C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHiddenObjective;                                // 0x001D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ObjectiveName;                                     // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBSingleObjectiveData) == 0x000008, "Wrong alignment on FGBSingleObjectiveData");
static_assert(sizeof(FGBSingleObjectiveData) == 0x000030, "Wrong size on FGBSingleObjectiveData");
static_assert(offsetof(FGBSingleObjectiveData, ObjectiveType) == 0x000000, "Member 'FGBSingleObjectiveData::ObjectiveType' has a wrong offset!");
static_assert(offsetof(FGBSingleObjectiveData, ObjectiveTitle) == 0x000008, "Member 'FGBSingleObjectiveData::ObjectiveTitle' has a wrong offset!");
static_assert(offsetof(FGBSingleObjectiveData, ListDisplayPriority) == 0x000018, "Member 'FGBSingleObjectiveData::ListDisplayPriority' has a wrong offset!");
static_assert(offsetof(FGBSingleObjectiveData, bIsPrimaryObjective) == 0x00001C, "Member 'FGBSingleObjectiveData::bIsPrimaryObjective' has a wrong offset!");
static_assert(offsetof(FGBSingleObjectiveData, bIsHiddenObjective) == 0x00001D, "Member 'FGBSingleObjectiveData::bIsHiddenObjective' has a wrong offset!");
static_assert(offsetof(FGBSingleObjectiveData, ObjectiveName) == 0x000020, "Member 'FGBSingleObjectiveData::ObjectiveName' has a wrong offset!");

// ScriptStruct GroundBranch.GBObjectiveData
// 0x0020 (0x0020 - 0x0000)
struct FGBObjectiveData final
{
public:
	TArray<struct FGBSingleObjectiveData>         PrimaryObjectives;                                 // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGBSingleObjectiveData>         SecondaryObjectives;                               // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBObjectiveData) == 0x000008, "Wrong alignment on FGBObjectiveData");
static_assert(sizeof(FGBObjectiveData) == 0x000020, "Wrong size on FGBObjectiveData");
static_assert(offsetof(FGBObjectiveData, PrimaryObjectives) == 0x000000, "Member 'FGBObjectiveData::PrimaryObjectives' has a wrong offset!");
static_assert(offsetof(FGBObjectiveData, SecondaryObjectives) == 0x000010, "Member 'FGBObjectiveData::SecondaryObjectives' has a wrong offset!");

// ScriptStruct GroundBranch.GBCampaignMissionObjectiveInfo
// 0x0058 (0x0058 - 0x0000)
struct FGBCampaignMissionObjectiveInfo final
{
public:
	EGBMissionObjectiveStatus                     MissionObjectiveStatus;                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ObjectiveType;                                     // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ObjectiveTitle;                                    // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPrimaryObjective;                               // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHiddenObjective;                                // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ListDisplayPriority;                               // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AGBMissionObjective>     MissionObjectiveRef;                               // 0x0030(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBCampaignMissionObjectiveInfo) == 0x000008, "Wrong alignment on FGBCampaignMissionObjectiveInfo");
static_assert(sizeof(FGBCampaignMissionObjectiveInfo) == 0x000058, "Wrong size on FGBCampaignMissionObjectiveInfo");
static_assert(offsetof(FGBCampaignMissionObjectiveInfo, MissionObjectiveStatus) == 0x000000, "Member 'FGBCampaignMissionObjectiveInfo::MissionObjectiveStatus' has a wrong offset!");
static_assert(offsetof(FGBCampaignMissionObjectiveInfo, ObjectiveType) == 0x000004, "Member 'FGBCampaignMissionObjectiveInfo::ObjectiveType' has a wrong offset!");
static_assert(offsetof(FGBCampaignMissionObjectiveInfo, ObjectiveTitle) == 0x000010, "Member 'FGBCampaignMissionObjectiveInfo::ObjectiveTitle' has a wrong offset!");
static_assert(offsetof(FGBCampaignMissionObjectiveInfo, bIsPrimaryObjective) == 0x000020, "Member 'FGBCampaignMissionObjectiveInfo::bIsPrimaryObjective' has a wrong offset!");
static_assert(offsetof(FGBCampaignMissionObjectiveInfo, bIsHiddenObjective) == 0x000021, "Member 'FGBCampaignMissionObjectiveInfo::bIsHiddenObjective' has a wrong offset!");
static_assert(offsetof(FGBCampaignMissionObjectiveInfo, ListDisplayPriority) == 0x000024, "Member 'FGBCampaignMissionObjectiveInfo::ListDisplayPriority' has a wrong offset!");
static_assert(offsetof(FGBCampaignMissionObjectiveInfo, bIsActive) == 0x000028, "Member 'FGBCampaignMissionObjectiveInfo::bIsActive' has a wrong offset!");
static_assert(offsetof(FGBCampaignMissionObjectiveInfo, TeamId) == 0x000029, "Member 'FGBCampaignMissionObjectiveInfo::TeamId' has a wrong offset!");
static_assert(offsetof(FGBCampaignMissionObjectiveInfo, MissionObjectiveRef) == 0x000030, "Member 'FGBCampaignMissionObjectiveInfo::MissionObjectiveRef' has a wrong offset!");

// ScriptStruct GroundBranch.GBNavLinkUseActorInstanceData
// 0x0008 (0x0070 - 0x0068)
struct FGBNavLinkUseActorInstanceData final : public FActorComponentInstanceData
{
public:
	uint32                                        NavLinkUserId;                                     // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBNavLinkUseActorInstanceData) == 0x000008, "Wrong alignment on FGBNavLinkUseActorInstanceData");
static_assert(sizeof(FGBNavLinkUseActorInstanceData) == 0x000070, "Wrong size on FGBNavLinkUseActorInstanceData");
static_assert(offsetof(FGBNavLinkUseActorInstanceData, NavLinkUserId) == 0x000068, "Member 'FGBNavLinkUseActorInstanceData::NavLinkUserId' has a wrong offset!");

// ScriptStruct GroundBranch.GBOperatorDetails
// 0x00A8 (0x00A8 - 0x0000)
struct FGBOperatorDetails final
{
public:
	class FName                                   UniqueId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGeneric;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFemale;                                           // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FirstName;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Surname;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CodeName;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Biography;                                         // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 LoadoutFileName;                                   // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPoseAsset>              RosterPose;                                        // 0x0068(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGBOperatorSpecialisation                     Specialisation;                                    // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Birthday;                                          // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OperationsUndertaken;                              // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBOperatorDetails) == 0x000008, "Wrong alignment on FGBOperatorDetails");
static_assert(sizeof(FGBOperatorDetails) == 0x0000A8, "Wrong size on FGBOperatorDetails");
static_assert(offsetof(FGBOperatorDetails, UniqueId) == 0x000000, "Member 'FGBOperatorDetails::UniqueId' has a wrong offset!");
static_assert(offsetof(FGBOperatorDetails, bGeneric) == 0x000008, "Member 'FGBOperatorDetails::bGeneric' has a wrong offset!");
static_assert(offsetof(FGBOperatorDetails, bFemale) == 0x000009, "Member 'FGBOperatorDetails::bFemale' has a wrong offset!");
static_assert(offsetof(FGBOperatorDetails, FirstName) == 0x000010, "Member 'FGBOperatorDetails::FirstName' has a wrong offset!");
static_assert(offsetof(FGBOperatorDetails, Surname) == 0x000020, "Member 'FGBOperatorDetails::Surname' has a wrong offset!");
static_assert(offsetof(FGBOperatorDetails, CodeName) == 0x000030, "Member 'FGBOperatorDetails::CodeName' has a wrong offset!");
static_assert(offsetof(FGBOperatorDetails, Biography) == 0x000040, "Member 'FGBOperatorDetails::Biography' has a wrong offset!");
static_assert(offsetof(FGBOperatorDetails, LoadoutFileName) == 0x000058, "Member 'FGBOperatorDetails::LoadoutFileName' has a wrong offset!");
static_assert(offsetof(FGBOperatorDetails, RosterPose) == 0x000068, "Member 'FGBOperatorDetails::RosterPose' has a wrong offset!");
static_assert(offsetof(FGBOperatorDetails, Specialisation) == 0x000090, "Member 'FGBOperatorDetails::Specialisation' has a wrong offset!");
static_assert(offsetof(FGBOperatorDetails, Birthday) == 0x000098, "Member 'FGBOperatorDetails::Birthday' has a wrong offset!");
static_assert(offsetof(FGBOperatorDetails, OperationsUndertaken) == 0x0000A0, "Member 'FGBOperatorDetails::OperationsUndertaken' has a wrong offset!");

// ScriptStruct GroundBranch.GBPatchInfo
// 0x0040 (0x0040 - 0x0000)
struct FGBPatchInfo final
{
public:
	class FString                                 PatchPath;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        PatchTintSkinId;                                   // 0x0010(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FallbackPatchPath;                                 // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        FallbackPatchTintSkinId;                           // 0x0030(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBPatchInfo) == 0x000008, "Wrong alignment on FGBPatchInfo");
static_assert(sizeof(FGBPatchInfo) == 0x000040, "Wrong size on FGBPatchInfo");
static_assert(offsetof(FGBPatchInfo, PatchPath) == 0x000000, "Member 'FGBPatchInfo::PatchPath' has a wrong offset!");
static_assert(offsetof(FGBPatchInfo, PatchTintSkinId) == 0x000010, "Member 'FGBPatchInfo::PatchTintSkinId' has a wrong offset!");
static_assert(offsetof(FGBPatchInfo, FallbackPatchPath) == 0x000020, "Member 'FGBPatchInfo::FallbackPatchPath' has a wrong offset!");
static_assert(offsetof(FGBPatchInfo, FallbackPatchTintSkinId) == 0x000030, "Member 'FGBPatchInfo::FallbackPatchTintSkinId' has a wrong offset!");

// ScriptStruct GroundBranch.GBFullScreenWidget
// 0x0010 (0x0010 - 0x0000)
struct FGBFullScreenWidget final
{
public:
	class UUserWidget*                            Widget;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBFullScreenWidget) == 0x000008, "Wrong alignment on FGBFullScreenWidget");
static_assert(sizeof(FGBFullScreenWidget) == 0x000010, "Wrong size on FGBFullScreenWidget");
static_assert(offsetof(FGBFullScreenWidget, Widget) == 0x000000, "Member 'FGBFullScreenWidget::Widget' has a wrong offset!");

// ScriptStruct GroundBranch.InputExecKeyMapping
// 0x0030 (0x0030 - 0x0000)
struct FInputExecKeyMapping final
{
public:
	class FString                                 ExecCommand;                                       // 0x0000(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0010(0x0018)(Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShift : 1;                                        // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCtrl : 1;                                         // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlt : 1;                                          // 0x0028(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCmd : 1;                                          // 0x0028(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInputExecKeyMapping) == 0x000008, "Wrong alignment on FInputExecKeyMapping");
static_assert(sizeof(FInputExecKeyMapping) == 0x000030, "Wrong size on FInputExecKeyMapping");
static_assert(offsetof(FInputExecKeyMapping, ExecCommand) == 0x000000, "Member 'FInputExecKeyMapping::ExecCommand' has a wrong offset!");
static_assert(offsetof(FInputExecKeyMapping, Key) == 0x000010, "Member 'FInputExecKeyMapping::Key' has a wrong offset!");

// ScriptStruct GroundBranch.PlayerHint
// 0x0018 (0x0018 - 0x0000)
struct FPlayerHint final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LastShown;                                         // 0x0010(0x0008)(ZeroConstructor, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerHint) == 0x000008, "Wrong alignment on FPlayerHint");
static_assert(sizeof(FPlayerHint) == 0x000018, "Wrong size on FPlayerHint");
static_assert(offsetof(FPlayerHint, Name) == 0x000000, "Member 'FPlayerHint::Name' has a wrong offset!");
static_assert(offsetof(FPlayerHint, Count) == 0x000008, "Member 'FPlayerHint::Count' has a wrong offset!");
static_assert(offsetof(FPlayerHint, LastShown) == 0x000010, "Member 'FPlayerHint::LastShown' has a wrong offset!");

// ScriptStruct GroundBranch.GBPlayerInteraction
// 0x0010 (0x0010 - 0x0000)
struct FGBPlayerInteraction final
{
public:
	EGBPlayerInteractionStatus                    InteractionStatus;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBPlayerState*                         InteractingPlayer;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBPlayerInteraction) == 0x000008, "Wrong alignment on FGBPlayerInteraction");
static_assert(sizeof(FGBPlayerInteraction) == 0x000010, "Wrong size on FGBPlayerInteraction");
static_assert(offsetof(FGBPlayerInteraction, InteractionStatus) == 0x000000, "Member 'FGBPlayerInteraction::InteractionStatus' has a wrong offset!");
static_assert(offsetof(FGBPlayerInteraction, InteractingPlayer) == 0x000008, "Member 'FGBPlayerInteraction::InteractingPlayer' has a wrong offset!");

// ScriptStruct GroundBranch.RepRailAttachment
// 0x0018 (0x0018 - 0x0000)
struct FRepRailAttachment final
{
public:
	class AActor*                                 AttachParent;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachComponent;                                   // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RecoilSlot;                                        // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRepRailAttachment) == 0x000008, "Wrong alignment on FRepRailAttachment");
static_assert(sizeof(FRepRailAttachment) == 0x000018, "Wrong size on FRepRailAttachment");
static_assert(offsetof(FRepRailAttachment, AttachParent) == 0x000000, "Member 'FRepRailAttachment::AttachParent' has a wrong offset!");
static_assert(offsetof(FRepRailAttachment, AttachComponent) == 0x000008, "Member 'FRepRailAttachment::AttachComponent' has a wrong offset!");
static_assert(offsetof(FRepRailAttachment, RecoilSlot) == 0x000010, "Member 'FRepRailAttachment::RecoilSlot' has a wrong offset!");

// ScriptStruct GroundBranch.ValidatedRecoilSlots
// 0x0018 (0x0018 - 0x0000)
struct FValidatedRecoilSlots final
{
public:
	class UGBRailComponent*                       RailComp;                                          // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ValidRecoilSlots;                                  // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FValidatedRecoilSlots) == 0x000008, "Wrong alignment on FValidatedRecoilSlots");
static_assert(sizeof(FValidatedRecoilSlots) == 0x000018, "Wrong size on FValidatedRecoilSlots");
static_assert(offsetof(FValidatedRecoilSlots, RailComp) == 0x000000, "Member 'FValidatedRecoilSlots::RailComp' has a wrong offset!");
static_assert(offsetof(FValidatedRecoilSlots, ValidRecoilSlots) == 0x000008, "Member 'FValidatedRecoilSlots::ValidRecoilSlots' has a wrong offset!");

// ScriptStruct GroundBranch.GBReplicatedString
// 0x0018 (0x0018 - 0x0000)
struct FGBReplicatedString final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         StringChunks;                                      // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBReplicatedString) == 0x000008, "Wrong alignment on FGBReplicatedString");
static_assert(sizeof(FGBReplicatedString) == 0x000018, "Wrong size on FGBReplicatedString");
static_assert(offsetof(FGBReplicatedString, Name) == 0x000000, "Member 'FGBReplicatedString::Name' has a wrong offset!");
static_assert(offsetof(FGBReplicatedString, StringChunks) == 0x000008, "Member 'FGBReplicatedString::StringChunks' has a wrong offset!");

// ScriptStruct GroundBranch.GBRigUnit_SphereTraceWorld
// 0x0058 (0x0060 - 0x0008)
struct FGBRigUnit_SphereTraceWorld final : public FRigUnit
{
public:
	struct FVector                                Start;                                             // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      TraceObjectTypes;                                  // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   IgnoredPMTags;                                     // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHit;                                              // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitLocation;                                       // 0x0048(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormal;                                         // 0x0054(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBRigUnit_SphereTraceWorld) == 0x000008, "Wrong alignment on FGBRigUnit_SphereTraceWorld");
static_assert(sizeof(FGBRigUnit_SphereTraceWorld) == 0x000060, "Wrong size on FGBRigUnit_SphereTraceWorld");
static_assert(offsetof(FGBRigUnit_SphereTraceWorld, Start) == 0x000008, "Member 'FGBRigUnit_SphereTraceWorld::Start' has a wrong offset!");
static_assert(offsetof(FGBRigUnit_SphereTraceWorld, End) == 0x000014, "Member 'FGBRigUnit_SphereTraceWorld::End' has a wrong offset!");
static_assert(offsetof(FGBRigUnit_SphereTraceWorld, TraceObjectTypes) == 0x000020, "Member 'FGBRigUnit_SphereTraceWorld::TraceObjectTypes' has a wrong offset!");
static_assert(offsetof(FGBRigUnit_SphereTraceWorld, IgnoredPMTags) == 0x000030, "Member 'FGBRigUnit_SphereTraceWorld::IgnoredPMTags' has a wrong offset!");
static_assert(offsetof(FGBRigUnit_SphereTraceWorld, Radius) == 0x000040, "Member 'FGBRigUnit_SphereTraceWorld::Radius' has a wrong offset!");
static_assert(offsetof(FGBRigUnit_SphereTraceWorld, bHit) == 0x000044, "Member 'FGBRigUnit_SphereTraceWorld::bHit' has a wrong offset!");
static_assert(offsetof(FGBRigUnit_SphereTraceWorld, HitLocation) == 0x000048, "Member 'FGBRigUnit_SphereTraceWorld::HitLocation' has a wrong offset!");
static_assert(offsetof(FGBRigUnit_SphereTraceWorld, HitNormal) == 0x000054, "Member 'FGBRigUnit_SphereTraceWorld::HitNormal' has a wrong offset!");

// ScriptStruct GroundBranch.GBMatchStats
// 0x0028 (0x0028 - 0x0000)
struct FGBMatchStats final
{
public:
	TArray<int32>                                 TeamCumulativeScores;                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 TeamCumulativeRoundsWon;                           // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RoundNumber;                                       // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBMatchStats) == 0x000008, "Wrong alignment on FGBMatchStats");
static_assert(sizeof(FGBMatchStats) == 0x000028, "Wrong size on FGBMatchStats");
static_assert(offsetof(FGBMatchStats, TeamCumulativeScores) == 0x000000, "Member 'FGBMatchStats::TeamCumulativeScores' has a wrong offset!");
static_assert(offsetof(FGBMatchStats, TeamCumulativeRoundsWon) == 0x000010, "Member 'FGBMatchStats::TeamCumulativeRoundsWon' has a wrong offset!");
static_assert(offsetof(FGBMatchStats, RoundNumber) == 0x000020, "Member 'FGBMatchStats::RoundNumber' has a wrong offset!");

// ScriptStruct GroundBranch.GBScoreLine
// 0x0028 (0x0028 - 0x0000)
struct FGBScoreLine final
{
public:
	class FName                                   ScoreName;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         score;                                             // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScoreToAdd;                                        // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOneOff;                                           // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBScoreLine) == 0x000008, "Wrong alignment on FGBScoreLine");
static_assert(sizeof(FGBScoreLine) == 0x000028, "Wrong size on FGBScoreLine");
static_assert(offsetof(FGBScoreLine, ScoreName) == 0x000000, "Member 'FGBScoreLine::ScoreName' has a wrong offset!");
static_assert(offsetof(FGBScoreLine, Description) == 0x000008, "Member 'FGBScoreLine::Description' has a wrong offset!");
static_assert(offsetof(FGBScoreLine, score) == 0x000018, "Member 'FGBScoreLine::score' has a wrong offset!");
static_assert(offsetof(FGBScoreLine, ScoreToAdd) == 0x00001C, "Member 'FGBScoreLine::ScoreToAdd' has a wrong offset!");
static_assert(offsetof(FGBScoreLine, bOneOff) == 0x000020, "Member 'FGBScoreLine::bOneOff' has a wrong offset!");

// ScriptStruct GroundBranch.GBScoreCollection
// 0x0010 (0x0010 - 0x0000)
struct FGBScoreCollection final
{
public:
	TArray<struct FGBScoreLine>                   ScoreList;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBScoreCollection) == 0x000008, "Wrong alignment on FGBScoreCollection");
static_assert(sizeof(FGBScoreCollection) == 0x000010, "Wrong size on FGBScoreCollection");
static_assert(offsetof(FGBScoreCollection, ScoreList) == 0x000000, "Member 'FGBScoreCollection::ScoreList' has a wrong offset!");

// ScriptStruct GroundBranch.GBSightLineInfo
// 0x0054 (0x0054 - 0x0000)
struct FGBSightLineInfo final
{
public:
	struct FVector_NetQuantize100                 ZeroRelativeToSight;                               // 0x0000(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 SightLocationOffset;                               // 0x000C(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SightRotationOffset;                               // 0x0018(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 SightLocationRelativeToFirearm;                    // 0x0024(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SightRotationRelativeToFirearm;                    // 0x0030(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 AnimLocationOffset;                                // 0x003C(0x000C)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AnimRotationOffset;                                // 0x0048(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBSightLineInfo) == 0x000004, "Wrong alignment on FGBSightLineInfo");
static_assert(sizeof(FGBSightLineInfo) == 0x000054, "Wrong size on FGBSightLineInfo");
static_assert(offsetof(FGBSightLineInfo, ZeroRelativeToSight) == 0x000000, "Member 'FGBSightLineInfo::ZeroRelativeToSight' has a wrong offset!");
static_assert(offsetof(FGBSightLineInfo, SightLocationOffset) == 0x00000C, "Member 'FGBSightLineInfo::SightLocationOffset' has a wrong offset!");
static_assert(offsetof(FGBSightLineInfo, SightRotationOffset) == 0x000018, "Member 'FGBSightLineInfo::SightRotationOffset' has a wrong offset!");
static_assert(offsetof(FGBSightLineInfo, SightLocationRelativeToFirearm) == 0x000024, "Member 'FGBSightLineInfo::SightLocationRelativeToFirearm' has a wrong offset!");
static_assert(offsetof(FGBSightLineInfo, SightRotationRelativeToFirearm) == 0x000030, "Member 'FGBSightLineInfo::SightRotationRelativeToFirearm' has a wrong offset!");
static_assert(offsetof(FGBSightLineInfo, AnimLocationOffset) == 0x00003C, "Member 'FGBSightLineInfo::AnimLocationOffset' has a wrong offset!");
static_assert(offsetof(FGBSightLineInfo, AnimRotationOffset) == 0x000048, "Member 'FGBSightLineInfo::AnimRotationOffset' has a wrong offset!");

// ScriptStruct GroundBranch.GBTimeOfDayAlarm
// 0x0010 (0x0010 - 0x0000)
struct FGBTimeOfDayAlarm final
{
public:
	float                                         Hour;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AlarmName;                                         // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseStandardHours;                                 // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBTimeOfDayAlarm) == 0x000004, "Wrong alignment on FGBTimeOfDayAlarm");
static_assert(sizeof(FGBTimeOfDayAlarm) == 0x000010, "Wrong size on FGBTimeOfDayAlarm");
static_assert(offsetof(FGBTimeOfDayAlarm, Hour) == 0x000000, "Member 'FGBTimeOfDayAlarm::Hour' has a wrong offset!");
static_assert(offsetof(FGBTimeOfDayAlarm, AlarmName) == 0x000004, "Member 'FGBTimeOfDayAlarm::AlarmName' has a wrong offset!");
static_assert(offsetof(FGBTimeOfDayAlarm, bUseStandardHours) == 0x00000C, "Member 'FGBTimeOfDayAlarm::bUseStandardHours' has a wrong offset!");

// ScriptStruct GroundBranch.GBBlendedTimeSpan
// 0x0014 (0x0014 - 0x0000)
struct FGBBlendedTimeSpan final
{
public:
	class FName                                   CurrentTag;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextTag;                                           // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBBlendedTimeSpan) == 0x000004, "Wrong alignment on FGBBlendedTimeSpan");
static_assert(sizeof(FGBBlendedTimeSpan) == 0x000014, "Wrong size on FGBBlendedTimeSpan");
static_assert(offsetof(FGBBlendedTimeSpan, CurrentTag) == 0x000000, "Member 'FGBBlendedTimeSpan::CurrentTag' has a wrong offset!");
static_assert(offsetof(FGBBlendedTimeSpan, NextTag) == 0x000008, "Member 'FGBBlendedTimeSpan::NextTag' has a wrong offset!");
static_assert(offsetof(FGBBlendedTimeSpan, Alpha) == 0x000010, "Member 'FGBBlendedTimeSpan::Alpha' has a wrong offset!");

// ScriptStruct GroundBranch.GBFogSettings
// 0x0038 (0x0038 - 0x0000)
struct FGBFogSettings final
{
public:
	float                                         FogDensity;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightFalloff;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondFogDensity;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FogInscatteringColor;                              // 0x000C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOpacity;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDistance;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DirectionalInscatteringColor;                      // 0x0024(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricFogViewDistance;                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBFogSettings) == 0x000004, "Wrong alignment on FGBFogSettings");
static_assert(sizeof(FGBFogSettings) == 0x000038, "Wrong size on FGBFogSettings");
static_assert(offsetof(FGBFogSettings, FogDensity) == 0x000000, "Member 'FGBFogSettings::FogDensity' has a wrong offset!");
static_assert(offsetof(FGBFogSettings, FogHeightFalloff) == 0x000004, "Member 'FGBFogSettings::FogHeightFalloff' has a wrong offset!");
static_assert(offsetof(FGBFogSettings, SecondFogDensity) == 0x000008, "Member 'FGBFogSettings::SecondFogDensity' has a wrong offset!");
static_assert(offsetof(FGBFogSettings, FogInscatteringColor) == 0x00000C, "Member 'FGBFogSettings::FogInscatteringColor' has a wrong offset!");
static_assert(offsetof(FGBFogSettings, MaxOpacity) == 0x00001C, "Member 'FGBFogSettings::MaxOpacity' has a wrong offset!");
static_assert(offsetof(FGBFogSettings, StartDistance) == 0x000020, "Member 'FGBFogSettings::StartDistance' has a wrong offset!");
static_assert(offsetof(FGBFogSettings, DirectionalInscatteringColor) == 0x000024, "Member 'FGBFogSettings::DirectionalInscatteringColor' has a wrong offset!");
static_assert(offsetof(FGBFogSettings, VolumetricFogViewDistance) == 0x000034, "Member 'FGBFogSettings::VolumetricFogViewDistance' has a wrong offset!");

// ScriptStruct GroundBranch.GBReplicatedDateTime
// 0x0014 (0x0014 - 0x0000)
struct FGBReplicatedDateTime final
{
public:
	int32                                         Day;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Month;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Year;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMissionTimeLabel                             MissionTimeLabel;                                  // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitialTimeOfDay;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBReplicatedDateTime) == 0x000004, "Wrong alignment on FGBReplicatedDateTime");
static_assert(sizeof(FGBReplicatedDateTime) == 0x000014, "Wrong size on FGBReplicatedDateTime");
static_assert(offsetof(FGBReplicatedDateTime, Day) == 0x000000, "Member 'FGBReplicatedDateTime::Day' has a wrong offset!");
static_assert(offsetof(FGBReplicatedDateTime, Month) == 0x000004, "Member 'FGBReplicatedDateTime::Month' has a wrong offset!");
static_assert(offsetof(FGBReplicatedDateTime, Year) == 0x000008, "Member 'FGBReplicatedDateTime::Year' has a wrong offset!");
static_assert(offsetof(FGBReplicatedDateTime, MissionTimeLabel) == 0x00000C, "Member 'FGBReplicatedDateTime::MissionTimeLabel' has a wrong offset!");
static_assert(offsetof(FGBReplicatedDateTime, InitialTimeOfDay) == 0x000010, "Member 'FGBReplicatedDateTime::InitialTimeOfDay' has a wrong offset!");

// ScriptStruct GroundBranch.GBBiasedMontageInfo
// 0x0010 (0x0010 - 0x0000)
struct FGBBiasedMontageInfo final
{
public:
	int32                                         Bias;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGBBiasedMontageInfo) == 0x000008, "Wrong alignment on FGBBiasedMontageInfo");
static_assert(sizeof(FGBBiasedMontageInfo) == 0x000010, "Wrong size on FGBBiasedMontageInfo");
static_assert(offsetof(FGBBiasedMontageInfo, Bias) == 0x000000, "Member 'FGBBiasedMontageInfo::Bias' has a wrong offset!");
static_assert(offsetof(FGBBiasedMontageInfo, Montage) == 0x000008, "Member 'FGBBiasedMontageInfo::Montage' has a wrong offset!");

// ScriptStruct GroundBranch.GBTaggedMontageInfo
// 0x0038 (0x0038 - 0x0000)
struct FGBTaggedMontageInfo final
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FGBBiasedMontageInfo>           BiasedMontages;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TotalBias;                                         // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBTaggedMontageInfo) == 0x000008, "Wrong alignment on FGBTaggedMontageInfo");
static_assert(sizeof(FGBTaggedMontageInfo) == 0x000038, "Wrong size on FGBTaggedMontageInfo");
static_assert(offsetof(FGBTaggedMontageInfo, Tags) == 0x000000, "Member 'FGBTaggedMontageInfo::Tags' has a wrong offset!");
static_assert(offsetof(FGBTaggedMontageInfo, BiasedMontages) == 0x000020, "Member 'FGBTaggedMontageInfo::BiasedMontages' has a wrong offset!");
static_assert(offsetof(FGBTaggedMontageInfo, TotalBias) == 0x000030, "Member 'FGBTaggedMontageInfo::TotalBias' has a wrong offset!");

// ScriptStruct GroundBranch.MapListItem
// 0x0048 (0x0048 - 0x0000)
struct FMapListItem final
{
public:
	class FString                                 PackageName;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Author;                                            // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapListItem) == 0x000008, "Wrong alignment on FMapListItem");
static_assert(sizeof(FMapListItem) == 0x000048, "Wrong size on FMapListItem");
static_assert(offsetof(FMapListItem, PackageName) == 0x000000, "Member 'FMapListItem::PackageName' has a wrong offset!");
static_assert(offsetof(FMapListItem, Title) == 0x000010, "Member 'FMapListItem::Title' has a wrong offset!");
static_assert(offsetof(FMapListItem, Author) == 0x000020, "Member 'FMapListItem::Author' has a wrong offset!");
static_assert(offsetof(FMapListItem, Description) == 0x000030, "Member 'FMapListItem::Description' has a wrong offset!");

// ScriptStruct GroundBranch.InputBoundKey
// 0x0020 (0x0020 - 0x0000)
struct FInputBoundKey final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShift;                                            // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCtrl;                                             // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlt;                                              // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCmd;                                              // 0x001B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInputBoundKey) == 0x000008, "Wrong alignment on FInputBoundKey");
static_assert(sizeof(FInputBoundKey) == 0x000020, "Wrong size on FInputBoundKey");
static_assert(offsetof(FInputBoundKey, Key) == 0x000000, "Member 'FInputBoundKey::Key' has a wrong offset!");
static_assert(offsetof(FInputBoundKey, bShift) == 0x000018, "Member 'FInputBoundKey::bShift' has a wrong offset!");
static_assert(offsetof(FInputBoundKey, bCtrl) == 0x000019, "Member 'FInputBoundKey::bCtrl' has a wrong offset!");
static_assert(offsetof(FInputBoundKey, bAlt) == 0x00001A, "Member 'FInputBoundKey::bAlt' has a wrong offset!");
static_assert(offsetof(FInputBoundKey, bCmd) == 0x00001B, "Member 'FInputBoundKey::bCmd' has a wrong offset!");

// ScriptStruct GroundBranch.InputBindableCommand
// 0x0048 (0x0048 - 0x0000)
struct FInputBindableCommand final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 CommandName;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInputBoundKey>                 BoundKeys;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsExec;                                           // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInputBindableCommand) == 0x000008, "Wrong alignment on FInputBindableCommand");
static_assert(sizeof(FInputBindableCommand) == 0x000048, "Wrong size on FInputBindableCommand");
static_assert(offsetof(FInputBindableCommand, DisplayName) == 0x000000, "Member 'FInputBindableCommand::DisplayName' has a wrong offset!");
static_assert(offsetof(FInputBindableCommand, CommandName) == 0x000018, "Member 'FInputBindableCommand::CommandName' has a wrong offset!");
static_assert(offsetof(FInputBindableCommand, Scale) == 0x000028, "Member 'FInputBindableCommand::Scale' has a wrong offset!");
static_assert(offsetof(FInputBindableCommand, BoundKeys) == 0x000030, "Member 'FInputBindableCommand::BoundKeys' has a wrong offset!");
static_assert(offsetof(FInputBindableCommand, bIsExec) == 0x000040, "Member 'FInputBindableCommand::bIsExec' has a wrong offset!");

// ScriptStruct GroundBranch.GBPlayerCharVoiceInfo
// 0x0018 (0x0018 - 0x0000)
struct FGBPlayerCharVoiceInfo final
{
public:
	class AGBPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkComponent*                           AKVoiceComp;                                       // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRadio;                                          // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBPlayerCharVoiceInfo) == 0x000008, "Wrong alignment on FGBPlayerCharVoiceInfo");
static_assert(sizeof(FGBPlayerCharVoiceInfo) == 0x000018, "Wrong size on FGBPlayerCharVoiceInfo");
static_assert(offsetof(FGBPlayerCharVoiceInfo, PlayerState) == 0x000000, "Member 'FGBPlayerCharVoiceInfo::PlayerState' has a wrong offset!");
static_assert(offsetof(FGBPlayerCharVoiceInfo, AKVoiceComp) == 0x000008, "Member 'FGBPlayerCharVoiceInfo::AKVoiceComp' has a wrong offset!");
static_assert(offsetof(FGBPlayerCharVoiceInfo, bIsRadio) == 0x000010, "Member 'FGBPlayerCharVoiceInfo::bIsRadio' has a wrong offset!");

// ScriptStruct GroundBranch.GBVOIPData
// 0x0028 (0x0028 - 0x0000)
struct FGBVOIPData final
{
public:
	uint64                                        SteamID;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGBPlayerState*                         PlayerState;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGBVOIPAudioComponent*                  VOIPAudioComponent;                                // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVOIPType                                     VOIPType;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0xF];                                       // 0x0019(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBVOIPData) == 0x000008, "Wrong alignment on FGBVOIPData");
static_assert(sizeof(FGBVOIPData) == 0x000028, "Wrong size on FGBVOIPData");
static_assert(offsetof(FGBVOIPData, SteamID) == 0x000000, "Member 'FGBVOIPData::SteamID' has a wrong offset!");
static_assert(offsetof(FGBVOIPData, PlayerState) == 0x000008, "Member 'FGBVOIPData::PlayerState' has a wrong offset!");
static_assert(offsetof(FGBVOIPData, VOIPAudioComponent) == 0x000010, "Member 'FGBVOIPData::VOIPAudioComponent' has a wrong offset!");
static_assert(offsetof(FGBVOIPData, VOIPType) == 0x000018, "Member 'FGBVOIPData::VOIPType' has a wrong offset!");

}

