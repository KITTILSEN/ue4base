#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MeshMorpherRuntime

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "MeshMorpherRuntime_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class MeshMorpherRuntime.MeshMorpherRuntimeLibrary
// 0x0000 (0x0028 - 0x0028)
class UMeshMorpherRuntimeLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DoBakeMultiple(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USkeletalMesh* SkeletalMesh, const TMap<class UMorphTarget*, float>& MorphTargets, EMeshMorpherBakeBranches* Out);
	static void DoBakeMultipleStandalone(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USkeletalMesh* SkeletalMesh, const TMap<class UStandaloneMorphTarget*, float>& MorphTargets, EMeshMorpherBakeBranches* Out);
	static void DoBakeSingle(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USkeletalMesh* SkeletalMesh, class UMorphTarget* MorphTarget, float Weight, EMeshMorpherBakeBranches* Out);
	static void DoBakeSingleStandalone(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USkeletalMesh* SkeletalMesh, class UStandaloneMorphTarget* MorphTarget, float Weight, EMeshMorpherBakeBranches* Out);
	static class UMorphTarget* FindMorphTarget(class USkeletalMesh* SkeletalMesh, class FName Name_0);
	static void GetMorphTargetsNames(class USkeletalMesh* SkeletalMesh, TArray<class FName>* Names);
	static bool RemoveMorphTarget(class USkeletalMesh* SkeletalMesh, class FName Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshMorpherRuntimeLibrary">();
	}
	static class UMeshMorpherRuntimeLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshMorpherRuntimeLibrary>();
	}
};
static_assert(alignof(UMeshMorpherRuntimeLibrary) == 0x000008, "Wrong alignment on UMeshMorpherRuntimeLibrary");
static_assert(sizeof(UMeshMorpherRuntimeLibrary) == 0x000028, "Wrong size on UMeshMorpherRuntimeLibrary");

// Class MeshMorpherRuntime.MeshMorpherWorkerLibrary
// 0x0000 (0x0028 - 0x0028)
class UMeshMorpherWorkerLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void Cancel(class UObject* WorldContextObject, struct FMeshMorpherWorkerRef& WorkerReference, bool* bIsSuccess);
	static bool IsCanceled(class UObject* WorldContextObject, const struct FMeshMorpherWorkerRef& WorkerReference);
	static bool IsRunning(class UObject* WorldContextObject, const struct FMeshMorpherWorkerRef& WorkerReference);
	static bool IsValid(class UObject* WorldContextObject, const struct FMeshMorpherWorkerRef& WorkerReference);
	static void WaitToFinish(class UObject* WorldContextObject, const struct FMeshMorpherWorkerRef& WorkerReference);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshMorpherWorkerLibrary">();
	}
	static class UMeshMorpherWorkerLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshMorpherWorkerLibrary>();
	}
};
static_assert(alignof(UMeshMorpherWorkerLibrary) == 0x000008, "Wrong alignment on UMeshMorpherWorkerLibrary");
static_assert(sizeof(UMeshMorpherWorkerLibrary) == 0x000028, "Wrong size on UMeshMorpherWorkerLibrary");

// Class MeshMorpherRuntime.MetaMorph
// 0x0010 (0x0038 - 0x0028)
class UMetaMorph final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaMorph">();
	}
	static class UMetaMorph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMetaMorph>();
	}
};
static_assert(alignof(UMetaMorph) == 0x000008, "Wrong alignment on UMetaMorph");
static_assert(sizeof(UMetaMorph) == 0x000038, "Wrong size on UMetaMorph");

// Class MeshMorpherRuntime.StandaloneMaskSelection
// 0x00E8 (0x0110 - 0x0028)
class UStandaloneMaskSelection final : public UObject
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<int32>                                   SelectedVertices;                                  // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<int32>                                   SelectedTriangles;                                 // 0x0080(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x00D0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         MeshVertexCount;                                   // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MeshTriangleCount;                                 // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StandaloneMaskSelection">();
	}
	static class UStandaloneMaskSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStandaloneMaskSelection>();
	}
};
static_assert(alignof(UStandaloneMaskSelection) == 0x000010, "Wrong alignment on UStandaloneMaskSelection");
static_assert(sizeof(UStandaloneMaskSelection) == 0x000110, "Wrong size on UStandaloneMaskSelection");
static_assert(offsetof(UStandaloneMaskSelection, SkeletalMesh) == 0x000028, "Member 'UStandaloneMaskSelection::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UStandaloneMaskSelection, SelectedVertices) == 0x000030, "Member 'UStandaloneMaskSelection::SelectedVertices' has a wrong offset!");
static_assert(offsetof(UStandaloneMaskSelection, SelectedTriangles) == 0x000080, "Member 'UStandaloneMaskSelection::SelectedTriangles' has a wrong offset!");
static_assert(offsetof(UStandaloneMaskSelection, Transform) == 0x0000D0, "Member 'UStandaloneMaskSelection::Transform' has a wrong offset!");
static_assert(offsetof(UStandaloneMaskSelection, MeshVertexCount) == 0x000100, "Member 'UStandaloneMaskSelection::MeshVertexCount' has a wrong offset!");
static_assert(offsetof(UStandaloneMaskSelection, MeshTriangleCount) == 0x000104, "Member 'UStandaloneMaskSelection::MeshTriangleCount' has a wrong offset!");

// Class MeshMorpherRuntime.StandaloneMorphTarget
// 0x0018 (0x0040 - 0x0028)
class UStandaloneMorphTarget final : public UObject
{
public:
	class USkeletalMesh*                          BaseSkelMesh;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StandaloneMorphTarget">();
	}
	static class UStandaloneMorphTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStandaloneMorphTarget>();
	}
};
static_assert(alignof(UStandaloneMorphTarget) == 0x000008, "Wrong alignment on UStandaloneMorphTarget");
static_assert(sizeof(UStandaloneMorphTarget) == 0x000040, "Wrong size on UStandaloneMorphTarget");
static_assert(offsetof(UStandaloneMorphTarget, BaseSkelMesh) == 0x000028, "Member 'UStandaloneMorphTarget::BaseSkelMesh' has a wrong offset!");

}

