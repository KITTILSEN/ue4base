#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GroundBranch

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "ModKit_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "GroundBranch_structs.hpp"
#include "Gauntlet_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "PhysicsCore_structs.hpp"
#include "PhysicsCore_classes.hpp"
#include "SlateCore_structs.hpp"
#include "UMG_classes.hpp"
#include "Foliage_classes.hpp"
#include "FMModdingPlugin_structs.hpp"
#include "LuaMachine_classes.hpp"
#include "KytheraPlugin_classes.hpp"
#include "LXR_classes.hpp"
#include "RBHotFoot_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "PortalSystem_classes.hpp"
#include "SkyCreatorPlugin_classes.hpp"
#include "AkAudio_structs.hpp"
#include "AkAudio_classes.hpp"


namespace SDK
{

// Class GroundBranch.GBInvItem
// 0x0228 (0x0448 - 0x0220)
class AGBInvItem : public AActor
{
public:
	class FName                                   ItemAssetName;                                     // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DefaultItemBuild;                                  // 0x0228(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ItemWeight;                                        // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0240(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0258(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoClear, AssetRegistrySearchable, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  InvItemTags;                                       // 0x0280(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CosmeticTags;                                      // 0x02A0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  RequiredCosmeticTags;                              // 0x02C0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  IncompatibleCosmeticTags;                          // 0x02E0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected)
	class AGBCharacter*                           GBInstigator;                                      // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                CustomisationWidget;                               // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, TSoftClassPtr<class UClass>> DragDropOperations;                       // 0x0310(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class AGBDroppedInvItem>          DroppedInvItemClass;                               // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   EquippedCollisionProfileName;                      // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   UnequippedCollisionProfileName;                    // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUnequippedEnableCollision;                        // 0x0378(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBInvItem* ClientsideProxy, class AGBInvItem* Source)> OnReplacingClientsideProxy; // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_390[0x1];                                      // 0x0390(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAllowKitEncoding;                                 // 0x0391(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_392[0x2];                                      // 0x0392(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InventorySlot;                                     // 0x0394(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                InventorySlotWidget;                               // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        InvItemSkinId;                                     // 0x03A0(0x0010)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseRotationalInertiaModifier;                     // 0x03B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UGBGameplayAbilitySet>> GameplayAbilitySets;                         // 0x03B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FGameplayAbilitySpecHandle>     GameplayAbilitySpecHandles;                        // 0x03C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   AnimLayerClass;                                    // 0x03D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UGBInvItemMontageSet>> CharMontageSets;                              // 0x0400(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UGBInvItemMontageSet>> MontageSets;                                  // 0x0410(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UGBInvItemAudioEventSet>> AudioEventSets;                            // 0x0420(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UGBInvItemEffectSet>> EffectSets;                                    // 0x0430(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         DecalFadeScreenSize;                               // 0x0440(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AGBInvItem* SpawnInvItem(TSubclassOf<class AGBInvItem> InvItemClass, class AActor* InvItemOwner);

	void AddAttachedUseMenuEntries(class UUserWidget* UsageMenu);
	void AddedToCharacter(class AGBCharacter* NewParentCharacter);
	void AddedToItem(class AGBInvItem* NewParentItem);
	class UGBItemCameraModifier* AddNewItemCameraModifier(TSubclassOf<class UGBItemCameraModifier> ItemCameraModifierClass);
	void AddToInventory(class AGBCharacter* Character);
	bool AllowUsageWhileAttached();
	void ApplyPlayerSettings(class UGBPlayerSettings* GBPlayerSettings);
	bool BP_AttachItemTo(class USceneComponent* Parent, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule);
	void BP_DetachItemFrom(EDetachmentRule LocationRule, EDetachmentRule RotationRule);
	bool CanAddChild(class AGBInvItem* PotentialChild);
	bool CanAddToCharacter(class AGBCharacter* Character);
	bool CanBeAddedAsChild(class AGBInvItem* PotentialParent);
	void ChangeOwnerOnlyRelevancy(bool bOnlyOwner);
	void CharacterDestroyed(class AActor* DestroyedActor);
	void ClientAddToInventory(class AGBCharacter* Character);
	void ClientForceDestroy();
	void ClientRemoveFromInventory(class AGBCharacter* Character);
	class AGBInvItem* CreateClientsideProxy();
	void CreateMIDs();
	void CreateMIDsEvent();
	bool DecodeKit(class UVaRestJsonObject* ItemAsJson, class AActor* DecodedOwner, class AGBInvItem* DecodedParentItem, const class FName& ProfileName);
	bool DenyDrop();
	bool DenyUnequip();
	class AGBDroppedInvItem* DoDropFrom(const struct FVector& InLocation, const struct FRotator& InRotation, const struct FVector& InVelocity, const struct FVector& InAngularVelocity);
	void EditItemSetup(class AGBCharacter* UICharacter);
	void EncodeKit(class UVaRestJsonObject* ItemAsJson);
	TArray<class AGBInvItem*> FindParentItems(class AGBCharacter* Character);
	void ForceCreateMIDs();
	void ForceLoadGameplayAbilities();
	void ForceLODZero();
	TArray<class AGBInvItem*> GetChildInvItemsOfClass(TSubclassOf<class AGBInvItem> InvItemClass, bool bAllChildren);
	class FName GetEquipMontageSection(EHand TargetHand, const struct FGBChangeEquippedInfo& ChangeEquippedInfo);
	TArray<class UPrimitiveComponent*> GetHiddenComponents();
	bool GetPatchSocketNameMap(class USceneComponent* SceneComp, TMap<class FName, struct FGameplayTag>* OutSocketToPatchNameTagMap);
	void GetPositionAlphaTargets(float TargetEngagedAlpha, float TargetOffTargetAlpha, float* OutTargetEngagedAlpha, float* OutTargetOffTargetAlpha, float* OutOffTargetInterpSpeed);
	void GetStaminaMultipliers(float* RecoveryMultiplier, float* ExhaustionMultiplier);
	TSoftObjectPtr<class UMaterialInterface> GetStaticMeshPatchMaterial();
	class FString GetStatKey();
	struct FGBUnequipInfo GetUnequipInfo(EHand TargetHand);
	class FName GetUnequipMontageSection(EHand TargetHand, const struct FGBChangeEquippedInfo& ChangeEquippedInfo, const struct FGBUnequipInfo& LeftUnequipInfo, const struct FGBUnequipInfo& RightUnequipInfo);
	float GetWeaponsPositionTransitionTime(EGBWeaponPosition FromPosition, EGBWeaponPosition ToPosition);
	void MarkAsClientsideProxy();
	void OnAddedToCharacter(class AGBCharacter* NewParentCharacter);
	void OnAddedToInventoryEvent(class AGBCharacter* Character);
	void OnAddedToItem(class AGBInvItem* NewParentItem);
	void OnAddingChild(class AGBInvItem* AddedChild);
	void OnBeingDropped();
	void OnBeingEquipped();
	void OnBeingUnequipped();
	void OnClientsideProxyCreatedEvent(class AGBInvItem* Proxy);
	void OnCosmeticTagsUpdated(const struct FGameplayTagContainer& InCosmeticTags);
	void OnForceLoadGameplayAbilitiesComplete();
	void OnRemovedFromCharacter(class AGBCharacter* OldParentCharacter, class FName OldSocketName);
	void OnRemovedFromInventoryEvent(class AGBCharacter* Character);
	void OnRemovedFromItem(class AGBInvItem* OldParentItem, class USceneComponent* OldParentComp, class FName OldParentSocket);
	void OnRemovingChild(class AGBInvItem* RemovedChild);
	void OnRep_InvItemSkinId();
	bool OtherTagsSatisfied(const struct FGameplayTagContainer& InCosmeticTags);
	class AGBDroppedInvItem* PlaceAt(const struct FVector& InLocation, const struct FRotator& InRotation);
	void PositionAlphaMet();
	void PositionTransitionBegins();
	bool PostDecode();
	void PreEncodeCheck();
	void Refill();
	void RemovedFromCharacter(class AGBCharacter* OldParentCharacter, const class FName& OldSocketName);
	void RemovedFromItem(class AGBInvItem* OldParentItem, class USceneComponent* OldParentComp, const class FName& OldParentSocket);
	void RemoveFromInventory(class AGBCharacter* Character);
	void RemoveFromSkinnedDecalSampler(class AGBCharacter* Character);
	void RemoveItemCameraModifier(class UGBItemCameraModifier* ItemCameraModifierToRemove);
	void SetInvItemSkinId(const struct FPrimaryAssetId& NewInvItemSkinId);
	void SetupSightComponents();
	void SyncMontageWithOtherItem(class AGBInvItem* OtherItem, class FName MontageName);
	bool TryActivateItemAbilityByTag(const struct FGameplayTag& GameplayTag);
	bool TryActivateItemAbilityByTagWithPayload(const struct FGameplayTag& GameplayTag, const struct FGameplayEventData& Payload);
	void UpdateAudioValues();
	void UpdatePatches();
	void UpdateWetness(float InRadius, const struct FVector& InLocation);
	bool ValidateDecodedItem(class FString* OutFailureReason);

	TSubclassOf<class UAnimInstance> GetAnimLayerClassRef() const;
	class AGBInvItem* GetBaseItem() const;
	class UAnimMontage* GetCharMontage(class FName MontageName) const;
	TArray<class AGBInvItem*> GetChildInvItems(bool bAllChildren) const;
	TArray<class AGBInvItem*> GetChildInvItemsAttachedTo(class USceneComponent* Component, class FName SocketName) const;
	TArray<class AGBInvItem*> GetChildInvItemsWithTags(const struct FGameplayTagContainer& WithTags, bool bExactMatch, bool bAllChildren) const;
	struct FGameplayTagContainer GetCosmeticTags() const;
	class UGBSightComponent* GetCurrentSight() const;
	TSubclassOf<class UUserWidget> GetCustomisationWidget() const;
	class FText GetDisplayName() const;
	TSubclassOf<class UGBInvItemDragDropOperation> GetDragDropOperation(const struct FGameplayTagContainer& DragOpTags) const;
	class UNiagaraSystem* GetEffect(class FName EffectName) const;
	class AGBInvItem* GetFirstChildInvItemAttachedTo(class USceneComponent* Component, class FName SocketName) const;
	class AGBInvItem* GetFirstChildInvItemOfClass(TSubclassOf<class AGBInvItem> InvItemClass, bool bAllChildren) const;
	class AGBInvItem* GetFirstChildInvItemWithTags(const struct FGameplayTagContainer& WithTags, bool bExactMatch, bool bAllChildren) const;
	TArray<struct FGameplayAbilitySpecHandle> GetGameplayAbilitySpecHandles() const;
	class AGBCharacter* GetGBInstigator() const;
	EHand GetHandEnum() const;
	TSoftObjectPtr<class UTexture2D> GetIcon() const;
	int32 GetInventorySlot() const;
	TSubclassOf<class UUserWidget> GetInventorySlotWidget() const;
	struct FPrimaryAssetId GetInvItemSkinId() const;
	struct FGameplayTagContainer GetInvItemTags() const;
	float GetItemWeight() const;
	class UAnimMontage* GetMontage(class FName MontageName) const;
	class AGBInvItem* GetParentItem() const;
	class UAkAudioEvent* GetSound(class FName SoundName) const;
	bool IsClientsideProxy() const;
	bool IsEquipped() const;
	bool UsesGameplayAbilityByClass(TSubclassOf<class UGBGameplayAbility> GameplayAbilityClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBInvItem">();
	}
	static class AGBInvItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBInvItem>();
	}
};
static_assert(alignof(AGBInvItem) == 0x000008, "Wrong alignment on AGBInvItem");
static_assert(sizeof(AGBInvItem) == 0x000448, "Wrong size on AGBInvItem");
static_assert(offsetof(AGBInvItem, ItemAssetName) == 0x000220, "Member 'AGBInvItem::ItemAssetName' has a wrong offset!");
static_assert(offsetof(AGBInvItem, DefaultItemBuild) == 0x000228, "Member 'AGBInvItem::DefaultItemBuild' has a wrong offset!");
static_assert(offsetof(AGBInvItem, ItemWeight) == 0x000238, "Member 'AGBInvItem::ItemWeight' has a wrong offset!");
static_assert(offsetof(AGBInvItem, DisplayName) == 0x000240, "Member 'AGBInvItem::DisplayName' has a wrong offset!");
static_assert(offsetof(AGBInvItem, Icon) == 0x000258, "Member 'AGBInvItem::Icon' has a wrong offset!");
static_assert(offsetof(AGBInvItem, InvItemTags) == 0x000280, "Member 'AGBInvItem::InvItemTags' has a wrong offset!");
static_assert(offsetof(AGBInvItem, CosmeticTags) == 0x0002A0, "Member 'AGBInvItem::CosmeticTags' has a wrong offset!");
static_assert(offsetof(AGBInvItem, RequiredCosmeticTags) == 0x0002C0, "Member 'AGBInvItem::RequiredCosmeticTags' has a wrong offset!");
static_assert(offsetof(AGBInvItem, IncompatibleCosmeticTags) == 0x0002E0, "Member 'AGBInvItem::IncompatibleCosmeticTags' has a wrong offset!");
static_assert(offsetof(AGBInvItem, GBInstigator) == 0x000300, "Member 'AGBInvItem::GBInstigator' has a wrong offset!");
static_assert(offsetof(AGBInvItem, CustomisationWidget) == 0x000308, "Member 'AGBInvItem::CustomisationWidget' has a wrong offset!");
static_assert(offsetof(AGBInvItem, DragDropOperations) == 0x000310, "Member 'AGBInvItem::DragDropOperations' has a wrong offset!");
static_assert(offsetof(AGBInvItem, DroppedInvItemClass) == 0x000360, "Member 'AGBInvItem::DroppedInvItemClass' has a wrong offset!");
static_assert(offsetof(AGBInvItem, EquippedCollisionProfileName) == 0x000368, "Member 'AGBInvItem::EquippedCollisionProfileName' has a wrong offset!");
static_assert(offsetof(AGBInvItem, UnequippedCollisionProfileName) == 0x000370, "Member 'AGBInvItem::UnequippedCollisionProfileName' has a wrong offset!");
static_assert(offsetof(AGBInvItem, bUnequippedEnableCollision) == 0x000378, "Member 'AGBInvItem::bUnequippedEnableCollision' has a wrong offset!");
static_assert(offsetof(AGBInvItem, OnReplacingClientsideProxy) == 0x000380, "Member 'AGBInvItem::OnReplacingClientsideProxy' has a wrong offset!");
static_assert(offsetof(AGBInvItem, bAllowKitEncoding) == 0x000391, "Member 'AGBInvItem::bAllowKitEncoding' has a wrong offset!");
static_assert(offsetof(AGBInvItem, InventorySlot) == 0x000394, "Member 'AGBInvItem::InventorySlot' has a wrong offset!");
static_assert(offsetof(AGBInvItem, InventorySlotWidget) == 0x000398, "Member 'AGBInvItem::InventorySlotWidget' has a wrong offset!");
static_assert(offsetof(AGBInvItem, InvItemSkinId) == 0x0003A0, "Member 'AGBInvItem::InvItemSkinId' has a wrong offset!");
static_assert(offsetof(AGBInvItem, BaseRotationalInertiaModifier) == 0x0003B0, "Member 'AGBInvItem::BaseRotationalInertiaModifier' has a wrong offset!");
static_assert(offsetof(AGBInvItem, GameplayAbilitySets) == 0x0003B8, "Member 'AGBInvItem::GameplayAbilitySets' has a wrong offset!");
static_assert(offsetof(AGBInvItem, GameplayAbilitySpecHandles) == 0x0003C8, "Member 'AGBInvItem::GameplayAbilitySpecHandles' has a wrong offset!");
static_assert(offsetof(AGBInvItem, AnimLayerClass) == 0x0003D8, "Member 'AGBInvItem::AnimLayerClass' has a wrong offset!");
static_assert(offsetof(AGBInvItem, CharMontageSets) == 0x000400, "Member 'AGBInvItem::CharMontageSets' has a wrong offset!");
static_assert(offsetof(AGBInvItem, MontageSets) == 0x000410, "Member 'AGBInvItem::MontageSets' has a wrong offset!");
static_assert(offsetof(AGBInvItem, AudioEventSets) == 0x000420, "Member 'AGBInvItem::AudioEventSets' has a wrong offset!");
static_assert(offsetof(AGBInvItem, EffectSets) == 0x000430, "Member 'AGBInvItem::EffectSets' has a wrong offset!");
static_assert(offsetof(AGBInvItem, DecalFadeScreenSize) == 0x000440, "Member 'AGBInvItem::DecalFadeScreenSize' has a wrong offset!");

// Class GroundBranch.GBAmmunition
// 0x0000 (0x0448 - 0x0448)
class AGBAmmunition : public AGBInvItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAmmunition">();
	}
	static class AGBAmmunition* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBAmmunition>();
	}
};
static_assert(alignof(AGBAmmunition) == 0x000008, "Wrong alignment on AGBAmmunition");
static_assert(sizeof(AGBAmmunition) == 0x000448, "Wrong size on AGBAmmunition");

// Class GroundBranch.GBBulletItem
// 0x0008 (0x0450 - 0x0448)
class AGBBulletItem : public AGBAmmunition
{
public:
	TSubclassOf<class AGBBulletProjectile>        BulletProjectileClass;                             // 0x0448(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TSubclassOf<class AGBBulletProjectile> GetBulletProjectileClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBBulletItem">();
	}
	static class AGBBulletItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBBulletItem>();
	}
};
static_assert(alignof(AGBBulletItem) == 0x000008, "Wrong alignment on AGBBulletItem");
static_assert(sizeof(AGBBulletItem) == 0x000450, "Wrong size on AGBBulletItem");
static_assert(offsetof(AGBBulletItem, BulletProjectileClass) == 0x000448, "Member 'AGBBulletItem::BulletProjectileClass' has a wrong offset!");

// Class GroundBranch.GBAbilitySystemBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UGBAbilitySystemBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddGameplayEffect(class AActor* Actor, TSubclassOf<class UGameplayEffect> GameplayEffectClass);
	static void AddGameplayEffectWithDuration(class AActor* Actor, TSubclassOf<class UGameplayEffect> GameplayEffectClass, float Duration);
	static bool AddLooseGameplayTag(class AActor* Actor, const struct FGameplayTag& GameplayTag, bool bShouldReplicate);
	static bool AddLooseGameplayTags(class AActor* Actor, const struct FGameplayTagContainer& GameplayTags, bool bShouldReplicate);
	static void CancelAbilities(class AActor* Actor, const struct FGameplayTagContainer& WithTags, const struct FGameplayTagContainer& WithoutTags, class UGameplayAbility* Ignore);
	static void ClearLooseGameplayTagsByParent(class AActor* Actor, const struct FGameplayTag& ParentGameplayTag, bool bShouldReplicate);
	static bool ConditionalAddLooseGameplayTag(class AActor* Actor, const struct FGameplayTag& GameplayTag, bool bShouldReplicate);
	static bool ConditionalRemoveLooseGameplayTag(class AActor* Actor, const struct FGameplayTag& GameplayTag, bool bShouldReplicate);
	static struct FGameplayTag ConvertNameToGameplayTag(const class FName& TagName, bool ErrorIfNotFound);
	static struct FGameplayTag ConvertStringToGameplayTag(const class FString& TagString, bool ErrorIfNotFound);
	static bool GameplayEffect_IsValidHandle(const struct FActiveGameplayEffectHandle& GameplayEffectHandle);
	static struct FGameplayTag GameplayTag_FromSocketName(const class FName& SocketName, const struct FGameplayTag& ParentGameplayTag);
	static class FName GameplayTag_ToSocketName(const struct FGameplayTag& GameplayTag, const struct FGameplayTag& ParentGameplayTag);
	static bool GameplayTagContainer_Filter(const struct FGameplayTagContainer& SourceContainer, const struct FGameplayTagContainer& OtherContainer, struct FGameplayTagContainer* OutFilteredContainer);
	static bool GameplayTagContainer_FilterExact(const struct FGameplayTagContainer& SourceContainer, const struct FGameplayTagContainer& OtherContainer, struct FGameplayTagContainer* OutFilteredContainer);
	static bool GameplayTagContainer_IsValid(const struct FGameplayTagContainer& Container);
	static struct FGameplayTagContainer GetPrimaryFirearmTypeTags();
	static struct FGameplayTagContainer GetSidearmFirearmTypeTags();
	static struct FGBGameplayTagEventHandle RegisterGameplayTagEvent(class AActor* Actor, const struct FGameplayTag& Tag, TDelegate<void(int32 NewCount)> OnGameplayTagChanged);
	static void RemoveGameplayEffect(class AActor* Actor, TSubclassOf<class UGameplayEffect> GameplayEffectClass);
	static bool RemoveLooseGameplayTag(class AActor* Actor, const struct FGameplayTag& GameplayTag, bool bShouldReplicate);
	static bool RemoveLooseGameplayTags(class AActor* Actor, const struct FGameplayTagContainer& GameplayTags, bool bShouldReplicate);
	static struct FGameplayTagContainer RequestGameplayTagChildren(const struct FGameplayTag& ParentTag);
	static bool SetLooseGameplayTagCount(class AActor* Actor, const struct FGameplayTag& GameplayTag, int32 NewCount, bool bShouldReplicate);
	static void SetRemoveAbilityOnEnd(class AActor* Actor, class UGameplayAbility* Ability);
	static void UnregisterGameplayTagEvent(struct FGBGameplayTagEventHandle& Handle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAbilitySystemBlueprintLibrary">();
	}
	static class UGBAbilitySystemBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAbilitySystemBlueprintLibrary>();
	}
};
static_assert(alignof(UGBAbilitySystemBlueprintLibrary) == 0x000008, "Wrong alignment on UGBAbilitySystemBlueprintLibrary");
static_assert(sizeof(UGBAbilitySystemBlueprintLibrary) == 0x000028, "Wrong size on UGBAbilitySystemBlueprintLibrary");

// Class GroundBranch.GBAbilitySystemComponent
// 0x0130 (0x1498 - 0x1368)
class UGBAbilitySystemComponent final : public UAbilitySystemComponent
{
public:
	class UGBAbilityTagRelationshipMapping*       TagRelationshipMapping;                            // 0x1368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1370[0x128];                                   // 0x1370(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlockAbilitiesWithoutTags(const struct FGameplayTagContainer& Tags);
	bool CancelAbilityByClass(TSubclassOf<class UGameplayAbility> InAbilityToCancel);
	bool SetGameplayEffectDurationHandle(const struct FActiveGameplayEffectHandle& Handle, float NewDuration);
	void UnBlockAbilitiesWithoutTags(const struct FGameplayTagContainer& Tags);

	struct FActiveGameplayEffectHandle GetFirstActiveGameplayEffect(const TSubclassOf<class UGameplayEffect>& GameplayEffectClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAbilitySystemComponent">();
	}
	static class UGBAbilitySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAbilitySystemComponent>();
	}
};
static_assert(alignof(UGBAbilitySystemComponent) == 0x000008, "Wrong alignment on UGBAbilitySystemComponent");
static_assert(sizeof(UGBAbilitySystemComponent) == 0x001498, "Wrong size on UGBAbilitySystemComponent");
static_assert(offsetof(UGBAbilitySystemComponent, TagRelationshipMapping) == 0x001368, "Member 'UGBAbilitySystemComponent::TagRelationshipMapping' has a wrong offset!");

// Class GroundBranch.GBAbilityTagRelationshipMapping
// 0x0010 (0x0040 - 0x0030)
class UGBAbilityTagRelationshipMapping final : public UDataAsset
{
public:
	TArray<struct FGBAbilityTagRelationship>      AbilityTagRelationships;                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAbilityTagRelationshipMapping">();
	}
	static class UGBAbilityTagRelationshipMapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAbilityTagRelationshipMapping>();
	}
};
static_assert(alignof(UGBAbilityTagRelationshipMapping) == 0x000008, "Wrong alignment on UGBAbilityTagRelationshipMapping");
static_assert(sizeof(UGBAbilityTagRelationshipMapping) == 0x000040, "Wrong size on UGBAbilityTagRelationshipMapping");
static_assert(offsetof(UGBAbilityTagRelationshipMapping, AbilityTagRelationships) == 0x000030, "Member 'UGBAbilityTagRelationshipMapping::AbilityTagRelationships' has a wrong offset!");

// Class GroundBranch.GBBulletMovementComponent
// 0x0110 (0x02E0 - 0x01D0)
class UGBBulletMovementComponent final : public UProjectileMovementComponent
{
public:
	uint8                                         Pad_1D0[0x8];                                      // 0x01D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FHitResult& ImpactResult)> OnImpactDelegate;          // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHitResult& ImpactResult)> OnExitDelegate;            // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IgnoredPMTags;                                     // 0x0200(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  FXOnlyPMTags;                                      // 0x0220(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ImpenetrablePMTags;                                // 0x0240(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_260[0xC];                                      // 0x0260(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AirDensity;                                        // 0x026C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaterDensity;                                      // 0x0270(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Length;                                            // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Diameter;                                          // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0xC];                                      // 0x027C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Mass;                                              // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DragCoefficient;                                   // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DragCoefficientTable;                              // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExpansionIndice;                                   // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PointShape;                                        // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x40];                                     // 0x02A0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetDragCoefficient(float Speed) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBBulletMovementComponent">();
	}
	static class UGBBulletMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBBulletMovementComponent>();
	}
};
static_assert(alignof(UGBBulletMovementComponent) == 0x000010, "Wrong alignment on UGBBulletMovementComponent");
static_assert(sizeof(UGBBulletMovementComponent) == 0x0002E0, "Wrong size on UGBBulletMovementComponent");
static_assert(offsetof(UGBBulletMovementComponent, OnImpactDelegate) == 0x0001D8, "Member 'UGBBulletMovementComponent::OnImpactDelegate' has a wrong offset!");
static_assert(offsetof(UGBBulletMovementComponent, OnExitDelegate) == 0x0001E8, "Member 'UGBBulletMovementComponent::OnExitDelegate' has a wrong offset!");
static_assert(offsetof(UGBBulletMovementComponent, IgnoredPMTags) == 0x000200, "Member 'UGBBulletMovementComponent::IgnoredPMTags' has a wrong offset!");
static_assert(offsetof(UGBBulletMovementComponent, FXOnlyPMTags) == 0x000220, "Member 'UGBBulletMovementComponent::FXOnlyPMTags' has a wrong offset!");
static_assert(offsetof(UGBBulletMovementComponent, ImpenetrablePMTags) == 0x000240, "Member 'UGBBulletMovementComponent::ImpenetrablePMTags' has a wrong offset!");
static_assert(offsetof(UGBBulletMovementComponent, AirDensity) == 0x00026C, "Member 'UGBBulletMovementComponent::AirDensity' has a wrong offset!");
static_assert(offsetof(UGBBulletMovementComponent, WaterDensity) == 0x000270, "Member 'UGBBulletMovementComponent::WaterDensity' has a wrong offset!");
static_assert(offsetof(UGBBulletMovementComponent, Length) == 0x000274, "Member 'UGBBulletMovementComponent::Length' has a wrong offset!");
static_assert(offsetof(UGBBulletMovementComponent, Diameter) == 0x000278, "Member 'UGBBulletMovementComponent::Diameter' has a wrong offset!");
static_assert(offsetof(UGBBulletMovementComponent, Mass) == 0x000288, "Member 'UGBBulletMovementComponent::Mass' has a wrong offset!");
static_assert(offsetof(UGBBulletMovementComponent, DragCoefficient) == 0x00028C, "Member 'UGBBulletMovementComponent::DragCoefficient' has a wrong offset!");
static_assert(offsetof(UGBBulletMovementComponent, DragCoefficientTable) == 0x000290, "Member 'UGBBulletMovementComponent::DragCoefficientTable' has a wrong offset!");
static_assert(offsetof(UGBBulletMovementComponent, ExpansionIndice) == 0x000298, "Member 'UGBBulletMovementComponent::ExpansionIndice' has a wrong offset!");
static_assert(offsetof(UGBBulletMovementComponent, PointShape) == 0x00029C, "Member 'UGBBulletMovementComponent::PointShape' has a wrong offset!");

// Class GroundBranch.GBAbilityTask_CharacterWalkTo
// 0x0050 (0x00D0 - 0x0080)
class UGBAbilityTask_CharacterWalkTo final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnTargetReached;                                   // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnFailureToMove;                                   // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x14];                                      // 0x00A0(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AcceptableRadius;                                  // 0x00B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x00B8(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetRotationYaw;                                 // 0x00C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RateOfRotation;                                    // 0x00C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGBAbilityTask_CharacterWalkTo* CharacterWalkTo(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FVector& Location, float Radius, const struct FRotator& Rotation, float RotationRate, float MaxFailedMoveTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAbilityTask_CharacterWalkTo">();
	}
	static class UGBAbilityTask_CharacterWalkTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAbilityTask_CharacterWalkTo>();
	}
};
static_assert(alignof(UGBAbilityTask_CharacterWalkTo) == 0x000008, "Wrong alignment on UGBAbilityTask_CharacterWalkTo");
static_assert(sizeof(UGBAbilityTask_CharacterWalkTo) == 0x0000D0, "Wrong size on UGBAbilityTask_CharacterWalkTo");
static_assert(offsetof(UGBAbilityTask_CharacterWalkTo, OnTargetReached) == 0x000080, "Member 'UGBAbilityTask_CharacterWalkTo::OnTargetReached' has a wrong offset!");
static_assert(offsetof(UGBAbilityTask_CharacterWalkTo, OnFailureToMove) == 0x000090, "Member 'UGBAbilityTask_CharacterWalkTo::OnFailureToMove' has a wrong offset!");
static_assert(offsetof(UGBAbilityTask_CharacterWalkTo, AcceptableRadius) == 0x0000B4, "Member 'UGBAbilityTask_CharacterWalkTo::AcceptableRadius' has a wrong offset!");
static_assert(offsetof(UGBAbilityTask_CharacterWalkTo, TargetLocation) == 0x0000B8, "Member 'UGBAbilityTask_CharacterWalkTo::TargetLocation' has a wrong offset!");
static_assert(offsetof(UGBAbilityTask_CharacterWalkTo, TargetRotationYaw) == 0x0000C4, "Member 'UGBAbilityTask_CharacterWalkTo::TargetRotationYaw' has a wrong offset!");
static_assert(offsetof(UGBAbilityTask_CharacterWalkTo, RateOfRotation) == 0x0000C8, "Member 'UGBAbilityTask_CharacterWalkTo::RateOfRotation' has a wrong offset!");

// Class GroundBranch.GBBulletProjectile
// 0x00C8 (0x02E8 - 0x0220)
class AGBBulletProjectile : public AActor
{
public:
	uint8                                         Pad_220[0x30];                                     // 0x0220(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRepBulletMovement                     BulletReplicatedMovement;                          // 0x0250(0x0018)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DumpedKEToDamageScale;                             // 0x0268(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DumpedKEToDamageScaleDeviation;                    // 0x026C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGBBulletMovementComponent*             BulletMovementComp;                                // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       CollisionComp;                                     // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       BulletWarningTrigger;                              // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkImpactComponent;                                 // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGBBulletProjectile>        SimulatedBulletClass;                              // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBBulletProjectile*                    ParentBullet;                                      // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 StatKey;                                           // 0x02C0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         BulletIndex;                                       // 0x02D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0xF];                                      // 0x02D1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         TracerColourIndex;                                 // 0x02E0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AGBBulletProjectile* SpawnBullet(class AActor* BulletOwner, TSubclassOf<class AGBBulletProjectile> BulletClass, const struct FVector& SpawnLocation, const struct FVector& ShotDirection, float VelocityModifier, bool bSimulated);

	void CharacterImpact(class AGBCharacter* Character, const struct FHitResult& HitResult);
	void CreateTracerEvent();
	void ImpactDamage(const struct FHitResult& HitResult);
	void ImpactEffect(const struct FHitResult& HitResult, bool bExiting);
	void InitForSimulatedTrajectory();
	void OnBulletWarnSphereEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnExit(const struct FHitResult& HitResult);
	void OnExitEvent(const struct FHitResult& HitResult);
	void OnImpact(const struct FHitResult& HitResult);
	void OnRep_BulletReplicatedMovement();
	void OnStop(const struct FHitResult& HitResult);
	void OnStopEvent(const struct FHitResult& HitResult);
	void SetBulletIndex(uint8 NewBulletIndex);
	void SetDragCoefficientOverride(float NewValue);
	void SetDumpedKEToDamageScale(float NewValue);
	void SetDumpedKEToDamageScaleDeviation(int32 NewValue);
	void SetParentBullet(class AGBBulletProjectile* NewParentBullet);
	void SetStatKey(const class FString& NewStatKey);
	void SetTracerColourIndex(uint8 NewTracerColourIndex);
	void SimulateTrajectory(const struct FTransform& SimTM, const float SimTime, const float SimTimeStep, const float MaxDistance, TArray<struct FVector>* OutTrajectoryPoints, bool* bOutSimulatedImpact);

	uint8 GetBulletIndex() const;
	class UGBBulletMovementComponent* GetBulletMovementComp() const;
	float GetDumpedKEToDamageScale() const;
	int32 GetDumpedKEToDamageScaleDeviation() const;
	class UAkComponent* GetImpactComp() const;
	class FString GetStatKey() const;
	uint8 GetTracerColourIndex() const;
	bool IsDebuggingBullets() const;
	bool IsSimulatedOnly() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBBulletProjectile">();
	}
	static class AGBBulletProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBBulletProjectile>();
	}
};
static_assert(alignof(AGBBulletProjectile) == 0x000008, "Wrong alignment on AGBBulletProjectile");
static_assert(sizeof(AGBBulletProjectile) == 0x0002E8, "Wrong size on AGBBulletProjectile");
static_assert(offsetof(AGBBulletProjectile, BulletReplicatedMovement) == 0x000250, "Member 'AGBBulletProjectile::BulletReplicatedMovement' has a wrong offset!");
static_assert(offsetof(AGBBulletProjectile, DumpedKEToDamageScale) == 0x000268, "Member 'AGBBulletProjectile::DumpedKEToDamageScale' has a wrong offset!");
static_assert(offsetof(AGBBulletProjectile, DumpedKEToDamageScaleDeviation) == 0x00026C, "Member 'AGBBulletProjectile::DumpedKEToDamageScaleDeviation' has a wrong offset!");
static_assert(offsetof(AGBBulletProjectile, DamageType) == 0x000270, "Member 'AGBBulletProjectile::DamageType' has a wrong offset!");
static_assert(offsetof(AGBBulletProjectile, BulletMovementComp) == 0x000278, "Member 'AGBBulletProjectile::BulletMovementComp' has a wrong offset!");
static_assert(offsetof(AGBBulletProjectile, CollisionComp) == 0x000280, "Member 'AGBBulletProjectile::CollisionComp' has a wrong offset!");
static_assert(offsetof(AGBBulletProjectile, BulletWarningTrigger) == 0x000288, "Member 'AGBBulletProjectile::BulletWarningTrigger' has a wrong offset!");
static_assert(offsetof(AGBBulletProjectile, AkImpactComponent) == 0x000290, "Member 'AGBBulletProjectile::AkImpactComponent' has a wrong offset!");
static_assert(offsetof(AGBBulletProjectile, SimulatedBulletClass) == 0x0002A0, "Member 'AGBBulletProjectile::SimulatedBulletClass' has a wrong offset!");
static_assert(offsetof(AGBBulletProjectile, ParentBullet) == 0x0002B8, "Member 'AGBBulletProjectile::ParentBullet' has a wrong offset!");
static_assert(offsetof(AGBBulletProjectile, StatKey) == 0x0002C0, "Member 'AGBBulletProjectile::StatKey' has a wrong offset!");
static_assert(offsetof(AGBBulletProjectile, BulletIndex) == 0x0002D0, "Member 'AGBBulletProjectile::BulletIndex' has a wrong offset!");
static_assert(offsetof(AGBBulletProjectile, TracerColourIndex) == 0x0002E0, "Member 'AGBBulletProjectile::TracerColourIndex' has a wrong offset!");

// Class GroundBranch.GBAbilityTask_Tick
// 0x0010 (0x0090 - 0x0080)
class UGBAbilityTask_Tick final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(float DeltaTime)> OnTick;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UGBAbilityTask_Tick* Tick(class UGameplayAbility* OwningAbility, class FName TaskInstanceName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAbilityTask_Tick">();
	}
	static class UGBAbilityTask_Tick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAbilityTask_Tick>();
	}
};
static_assert(alignof(UGBAbilityTask_Tick) == 0x000008, "Wrong alignment on UGBAbilityTask_Tick");
static_assert(sizeof(UGBAbilityTask_Tick) == 0x000090, "Wrong size on UGBAbilityTask_Tick");
static_assert(offsetof(UGBAbilityTask_Tick, OnTick) == 0x000080, "Member 'UGBAbilityTask_Tick::OnTick' has a wrong offset!");

// Class GroundBranch.GBAbilityTask_WaitAbilityEnded
// 0x00B8 (0x0138 - 0x0080)
class UGBAbilityTask_WaitAbilityEnded final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(class UGameplayAbility* EndedAbility)> OnEnded;                    // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0xA8];                                      // 0x0090(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGBAbilityTask_WaitAbilityEnded* WaitForAbilityEnded(class UGameplayAbility* OwningAbility, const struct FGameplayTag& WithTag, const struct FGameplayTag& WithoutTag, bool IncludeTriggeredAbilities, bool TriggerOnce);
	static class UGBAbilityTask_WaitAbilityEnded* WaitForAbilityEnded_Query(class UGameplayAbility* OwningAbility, const struct FGameplayTagQuery& Query, bool IncludeTriggeredAbilities, bool TriggerOnce);
	static class UGBAbilityTask_WaitAbilityEnded* WaitForAbilityEndedWithTagRequirements(class UGameplayAbility* OwningAbility, const struct FGameplayTagRequirements& TagRequirements, bool IncludeTriggeredAbilities, bool TriggerOnce);

	void OnAbilityEnded(class UGameplayAbility* EndedAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAbilityTask_WaitAbilityEnded">();
	}
	static class UGBAbilityTask_WaitAbilityEnded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAbilityTask_WaitAbilityEnded>();
	}
};
static_assert(alignof(UGBAbilityTask_WaitAbilityEnded) == 0x000008, "Wrong alignment on UGBAbilityTask_WaitAbilityEnded");
static_assert(sizeof(UGBAbilityTask_WaitAbilityEnded) == 0x000138, "Wrong size on UGBAbilityTask_WaitAbilityEnded");
static_assert(offsetof(UGBAbilityTask_WaitAbilityEnded, OnEnded) == 0x000080, "Member 'UGBAbilityTask_WaitAbilityEnded::OnEnded' has a wrong offset!");

// Class GroundBranch.GBCameraModifier
// 0x0000 (0x0048 - 0x0048)
class UGBCameraModifier : public UCameraModifier
{
public:
	void BlueprintAddedToCamera(class AGBPlayerCameraManager* GBPlayerCameraManager);
	void BlueprintPreApplyCameraModifier(class AGBPlayerCameraManager* GBPlayerCameraManager, float DeltaTime);
	bool BlueprintProcessViewRotation(class AActor* ViewTarget, float DeltaTime, struct FRotator* OutViewRotation, struct FRotator* OutDeltaRot);
	void BlueprintRemovedFromCamera(class AGBPlayerCameraManager* GBPlayerCameraManager);
	void OnCameraStyleChanged(class FName OldCameraStyle, class FName NewCameraStyle);
	void OnCameraStyleChangedEvent(class FName OldCameraStyle, class FName NewCameraStyle);
	void OnModifierDisabledEvent();
	void OnModifierEnabledEvent();

	class AGBPlayerCameraManager* GetGBPlayerCameraManager() const;
	class AGBPlayerController* GetGBPlayerController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBCameraModifier">();
	}
	static class UGBCameraModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBCameraModifier>();
	}
};
static_assert(alignof(UGBCameraModifier) == 0x000008, "Wrong alignment on UGBCameraModifier");
static_assert(sizeof(UGBCameraModifier) == 0x000048, "Wrong size on UGBCameraModifier");

// Class GroundBranch.GBAbilityTask_WaitActionPress
// 0x0030 (0x00B0 - 0x0080)
class UGBAbilityTask_WaitActionPress final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(float TimeWaited)> OnPress;                                        // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputComponent*                        InputComponent;                                    // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UGBAbilityTask_WaitActionPress* WaitActionPress(class UGameplayAbility* OwningAbility, class FName ActionName, bool bTestAlreadyPressed);

	void OnPressCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAbilityTask_WaitActionPress">();
	}
	static class UGBAbilityTask_WaitActionPress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAbilityTask_WaitActionPress>();
	}
};
static_assert(alignof(UGBAbilityTask_WaitActionPress) == 0x000008, "Wrong alignment on UGBAbilityTask_WaitActionPress");
static_assert(sizeof(UGBAbilityTask_WaitActionPress) == 0x0000B0, "Wrong size on UGBAbilityTask_WaitActionPress");
static_assert(offsetof(UGBAbilityTask_WaitActionPress, OnPress) == 0x000080, "Member 'UGBAbilityTask_WaitActionPress::OnPress' has a wrong offset!");
static_assert(offsetof(UGBAbilityTask_WaitActionPress, InputComponent) == 0x0000A8, "Member 'UGBAbilityTask_WaitActionPress::InputComponent' has a wrong offset!");

// Class GroundBranch.GBCampaignSettings
// 0x0050 (0x0078 - 0x0028)
class UGBCampaignSettings final : public UObject
{
public:
	int32                                         RosterSize;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGBOperatorDetails>             OperatorRoster;                                    // 0x0030(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGBOperatorDetails>             KIAList;                                           // 0x0040(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGBMissionCompletionDetails>    MissionCompletionDetails;                          // 0x0050(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           AvailableCodenames;                                // 0x0060(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bGeneratedAvailableCodenames;                      // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLoadedConfig;                                     // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGBCampaignSettings* Get();

	void AddOperatorToRoster(const struct FGBOperatorDetails& OperatorDetails, const bool bUpdateConfig);
	void FillRoster();
	void GenerateAvailableCodenames();
	TArray<class FName> GetAvailableCodenames();
	struct FGBMissionCompletionDetails GetCompletionDetailsForMission(const class FName& InHotspotCodename, const int32 InMissionSequenceNumber);
	void GetCompletionForHotspot(const class FName& InHotspotCodename, float* OutSinglePlayerCompletion, float* OutCoopCompletion);
	int32 GetIndexInOperatorDetailsList(const TArray<struct FGBOperatorDetails>& OperatorList, const struct FGBOperatorDetails& OperatorDetails);
	TArray<struct FGBOperatorDetails> GetKIAList();
	struct FGBOperatorDetails GetNewOperator();
	TArray<struct FGBOperatorDetails> GetOperatorRoster();
	void MarkOperatorKIA(const struct FGBOperatorDetails& OperatorDetails);
	void ResetCampaign();
	void ResetCompletionDetailsForHotspot(const class FName& InHotspotCodename);
	void ResetCompletionDetailsForMission(const class FName& InHotspotCodename, const int32 InMissionSequenceNumber);
	void SetCompletionDetailsForMission(const class FName& InHotspotCodename, const int32 InMissionSequenceNumber, const bool bSinglePlayer, const float CompletionAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBCampaignSettings">();
	}
	static class UGBCampaignSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBCampaignSettings>();
	}
};
static_assert(alignof(UGBCampaignSettings) == 0x000008, "Wrong alignment on UGBCampaignSettings");
static_assert(sizeof(UGBCampaignSettings) == 0x000078, "Wrong size on UGBCampaignSettings");
static_assert(offsetof(UGBCampaignSettings, RosterSize) == 0x000028, "Member 'UGBCampaignSettings::RosterSize' has a wrong offset!");
static_assert(offsetof(UGBCampaignSettings, OperatorRoster) == 0x000030, "Member 'UGBCampaignSettings::OperatorRoster' has a wrong offset!");
static_assert(offsetof(UGBCampaignSettings, KIAList) == 0x000040, "Member 'UGBCampaignSettings::KIAList' has a wrong offset!");
static_assert(offsetof(UGBCampaignSettings, MissionCompletionDetails) == 0x000050, "Member 'UGBCampaignSettings::MissionCompletionDetails' has a wrong offset!");
static_assert(offsetof(UGBCampaignSettings, AvailableCodenames) == 0x000060, "Member 'UGBCampaignSettings::AvailableCodenames' has a wrong offset!");
static_assert(offsetof(UGBCampaignSettings, bGeneratedAvailableCodenames) == 0x000070, "Member 'UGBCampaignSettings::bGeneratedAvailableCodenames' has a wrong offset!");
static_assert(offsetof(UGBCampaignSettings, bLoadedConfig) == 0x000071, "Member 'UGBCampaignSettings::bLoadedConfig' has a wrong offset!");

// Class GroundBranch.GBAbilityTask_WaitActionRelease
// 0x0030 (0x00B0 - 0x0080)
class UGBAbilityTask_WaitActionRelease final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(float TimeHeld)> OnRelease;                                        // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputComponent*                        InputComponent;                                    // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UGBAbilityTask_WaitActionRelease* WaitActionRelease(class UGameplayAbility* OwningAbility, class FName ActionName, bool bTestAlreadyReleased);

	void OnReleaseCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAbilityTask_WaitActionRelease">();
	}
	static class UGBAbilityTask_WaitActionRelease* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAbilityTask_WaitActionRelease>();
	}
};
static_assert(alignof(UGBAbilityTask_WaitActionRelease) == 0x000008, "Wrong alignment on UGBAbilityTask_WaitActionRelease");
static_assert(sizeof(UGBAbilityTask_WaitActionRelease) == 0x0000B0, "Wrong size on UGBAbilityTask_WaitActionRelease");
static_assert(offsetof(UGBAbilityTask_WaitActionRelease, OnRelease) == 0x000080, "Member 'UGBAbilityTask_WaitActionRelease::OnRelease' has a wrong offset!");
static_assert(offsetof(UGBAbilityTask_WaitActionRelease, InputComponent) == 0x0000A8, "Member 'UGBAbilityTask_WaitActionRelease::InputComponent' has a wrong offset!");

// Class GroundBranch.GBAbilityTask_WaitForNextTick
// 0x0010 (0x0090 - 0x0080)
class UGBAbilityTask_WaitForNextTick final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnNextTick;                                        // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UGBAbilityTask_WaitForNextTick* WaitForNextTick(class UGameplayAbility* OwningAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAbilityTask_WaitForNextTick">();
	}
	static class UGBAbilityTask_WaitForNextTick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAbilityTask_WaitForNextTick>();
	}
};
static_assert(alignof(UGBAbilityTask_WaitForNextTick) == 0x000008, "Wrong alignment on UGBAbilityTask_WaitForNextTick");
static_assert(sizeof(UGBAbilityTask_WaitForNextTick) == 0x000090, "Wrong size on UGBAbilityTask_WaitForNextTick");
static_assert(offsetof(UGBAbilityTask_WaitForNextTick, OnNextTick) == 0x000080, "Member 'UGBAbilityTask_WaitForNextTick::OnNextTick' has a wrong offset!");

// Class GroundBranch.GBCharacter
// 0x08D0 (0x0D90 - 0x04C0)
class AGBCharacter : public ACharacter
{
public:
	uint8                                         Pad_4C0[0x28];                                     // 0x04C0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                GameplayAbilitySets;                               // 0x04E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UGBAbilityTagRelationshipMapping*       TagRelationshipMapping;                            // 0x04F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_500[0x10];                                     // 0x0500(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAnimInstance>              UnarmedAnimLayerClass;                             // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AKVoiceComp;                                       // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AKFootstepComp;                                    // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_528[0x4];                                      // 0x0528(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRTPCSpeedValueChange;                           // 0x052C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_530[0x4];                                      // 0x0530(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRTPCWeightValueChange;                          // 0x0534(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AGBPlayerState* GBPlayerState)> OnReceivePlayerState;        // 0x0538(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class APlayerController* PlayerController, class AGBCharacter* Character)> OnBecomeViewTarget; // 0x0548(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class APlayerController* PlayerController, class AGBCharacter* Character)> OnEndViewTarget; // 0x0558(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_568[0xC];                                      // 0x0568(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemHandSocketLeft;                                // 0x0574(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemHandSocketRight;                               // 0x057C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SightLineBone;                                     // 0x0584(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bItemWasColliding : 1;                             // 0x058C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bItemIsColliding : 1;                              // 0x058C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_58D[0x3];                                      // 0x058D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxHealth;                                         // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Health;                                            // 0x0594(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_598[0x4];                                      // 0x0598(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         RemoteHeadPitchDif;                                // 0x059C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         RemoteHeadYawDif;                                  // 0x059D(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59E[0x2];                                      // 0x059E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ViewPitchMin;                                      // 0x05A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewPitchMax;                                      // 0x05A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewPitchMinProne;                                 // 0x05A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewPitchMaxProne;                                 // 0x05AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B0[0x4];                                      // 0x05B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrouchInterpSpeed;                                 // 0x05B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsProne : 1;                                      // 0x05B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_5B9[0x7];                                      // 0x05B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGBCharacterMovement*                   GBMovementComponent;                               // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxUnderWaterTime;                                 // 0x05C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DrowningDamagePerSecond;                           // 0x05CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastBreathTime;                                    // 0x05D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastDrownTime;                                     // 0x05D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            HeadUnderWaterEffect;                              // 0x05D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           GlobalEnvironmentMPC;                              // 0x05E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSafeFallSpeed;                                  // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathFallSpeed;                                    // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrushingDamageFactor;                              // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FC[0x4];                                      // 0x05FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBCharacter* Character)> OnRecoilCountUpdated;              // 0x0600(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AGBInvItem*                             EquippedLeft;                                      // 0x0610(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBInvItem*                             EquippedRight;                                     // 0x0618(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBInvItem*                             PrevEquippedLeft;                                  // 0x0620(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBInvItem*                             PrevEquippedRight;                                 // 0x0628(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              CurrentAnimLayerClass;                             // 0x0630(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bWantsToRun : 1;                                   // 0x0638(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bWantsToSprint : 1;                                // 0x0638(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_639[0x14];                                     // 0x0639(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	EHand                                         CurrentHand;                                       // 0x064D(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64E[0x2];                                      // 0x064E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DesiredLeanAlpha;                                  // 0x0650(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         RemoteDesiredLeanAlpha;                            // 0x0654(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_655[0x3];                                      // 0x0655(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeanInterpSpeed;                                   // 0x0658(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeanAlpha;                                         // 0x065C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_660[0x8];                                      // 0x0660(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBCharacter* Character)> OnPositionAlphasUpdated;           // 0x0668(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBCharacter* Character)> OnPositionAlphaMet;                // 0x0678(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         HeadOffsetPitchMin;                                // 0x0688(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeadOffsetPitchMax;                                // 0x068C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeadOffsetYawMax;                                  // 0x0690(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         DesiredWaterLevel;                                 // 0x0694(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ActualWaterLevel;                                  // 0x0695(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_696[0xE];                                      // 0x0696(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         RecoilCount;                                       // 0x06A4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A5[0x63];                                     // 0x06A5(0x0063)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RNGSeed;                                           // 0x0708(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70C[0xC];                                      // 0x070C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBKitInfo*                             LoadoutInfo;                                       // 0x0718(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LeftChestSlingPoint;                               // 0x0720(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RightChestSlingPoint;                              // 0x0728(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LeftShoulderSlingPoint;                            // 0x0730(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RightShoulderSlingPoint;                           // 0x0738(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxStamina;                                        // 0x0740(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Stamina;                                           // 0x0744(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaGainIdle;                                   // 0x0748(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaGainWalking;                                // 0x074C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaGainRunning;                                // 0x0750(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaLossWalking;                                // 0x0754(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaLossRunning;                                // 0x0758(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaLossSprinting;                              // 0x075C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaLossJump;                                   // 0x0760(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaLossControlledBreathing;                    // 0x0764(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaLossCrouchToStanding;                       // 0x0768(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaLossGoToProne;                              // 0x076C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaLossGetUpFromProne;                         // 0x0770(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaLossLean;                                   // 0x0774(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaInstantLossLeanSpam;                        // 0x0778(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaInstantLossRunSpam;                         // 0x077C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaInstantLossSprintSpam;                      // 0x0780(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaMinWeightThreshold;                         // 0x0784(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaMaxWeightThreshold;                         // 0x0788(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78C[0x4];                                      // 0x078C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaminaAudibleBreathingThreshold;                  // 0x0790(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaBreathingSwayThreshold;                     // 0x0794(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinRespiratoryRate;                                // 0x0798(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxRespiratoryRate;                                // 0x079C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A0[0x18];                                     // 0x07A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxArmStrength;                                    // 0x07B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrength;                                       // 0x07BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthGainUnarmed;                            // 0x07C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthGainIdle;                               // 0x07C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthGainWalking;                            // 0x07C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthGainRunning;                            // 0x07CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthLossIdle;                               // 0x07D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthLossIdleEngaged;                        // 0x07D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthLossWalking;                            // 0x07D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthLossWalkingEngaged;                     // 0x07DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthLossRunning;                            // 0x07E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthLossRunningEngaged;                     // 0x07E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthLossSprinting;                          // 0x07E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthLossJump;                               // 0x07EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthLossJumpEngaged;                        // 0x07F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthLossCrouchToStanding;                   // 0x07F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthLossGoToProne;                          // 0x07F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthLossGetUpFromProne;                     // 0x07FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthLossLean;                               // 0x0800(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthInstantLossLeanSpam;                    // 0x0804(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthInstantLossRunSpam;                     // 0x0808(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthInstantLossSprintSpam;                  // 0x080C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthMinWeightThreshold;                     // 0x0810(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmStrengthMaxWeightThreshold;                     // 0x0814(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_818[0xC];                                      // 0x0818(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        SwaySeed;                                          // 0x0824(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ArmSwayFreqRandRangeBase;                          // 0x0828(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ArmSwayFreqRandRangeDev;                           // 0x0830(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_838[0x10];                                     // 0x0838(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArmTwitchChance;                                   // 0x0848(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmEaseInOutExp;                                   // 0x084C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_850[0x14];                                     // 0x0850(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxBreathingPitch;                                 // 0x0864(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_868[0x8];                                      // 0x0868(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlattenSwayDuration;                               // 0x0870(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_874[0x4];                                      // 0x0874(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ControlBreathRecoveryScale;                        // 0x0878(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_87C[0x24];                                     // 0x087C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MaxBreathingDeviation;                             // 0x08A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MinReadySway;                                      // 0x08A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MaxReadySway;                                      // 0x08B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MinReadySwayCrouched;                              // 0x08B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MaxReadySwayCrouched;                              // 0x08C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MinEngagedSway;                                    // 0x08C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MaxEngagedSway;                                    // 0x08D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MinEngagedSwayCrouched;                            // 0x08D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MaxEngagedSwayCrouched;                            // 0x08E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E8[0x14];                                     // 0x08E8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         RemoteDesiredEngagedAlpha;                         // 0x08FC(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8FD[0xB];                                      // 0x08FD(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         RemoteDesiredOffTargetAlpha;                       // 0x0908(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_909[0x7];                                      // 0x0909(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBCharacter* Character)> OnLoadoutApplied;                  // 0x0910(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTakeHitInfo                           LastTakeHitInfo;                                   // 0x0920(0x0038)(BlueprintVisible, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FootstepTraceOffset;                               // 0x0958(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_95C[0x6];                                      // 0x095C(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bStartingRagdoll;                                  // 0x0962(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGBDeathState                                 DeathState;                                        // 0x0963(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_964[0x4];                                      // 0x0964(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FGameplayTag>        BoneNameToTagMap;                                  // 0x0968(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AGBCharacter* Character)> OnDeathStarted;                    // 0x09B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBCharacter* Character)> OnDeathFinished;                   // 0x09C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         LastTakeHitTime;                                   // 0x09D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastTakeHitReplicatedTime;                         // 0x09DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BodyImpactSoundSpeedSquared;                       // 0x09E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9E4[0x4];                                      // 0x09E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBetweenBodyImpactSounds;                       // 0x09E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9EC[0x4];                                      // 0x09EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      BoneDamageScaleMap;                                // 0x09F0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   RootBone;                                          // 0x0A40(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PelvisBone;                                        // 0x0A48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LeftFootBone;                                      // 0x0A50(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RightFootBone;                                     // 0x0A58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   EyesSocket;                                        // 0x0A60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BodyCamSocket;                                     // 0x0A68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HeadCamSocket;                                     // 0x0A70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AGBInvItem*>                     InventoryList;                                     // 0x0A78(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A88[0x20];                                     // 0x0A88(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBCharacter* Character, class AGBInvItem* InvItem)> InventoryItemAdded; // 0x0AA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBCharacter* Character, class AGBInvItem* InvItem)> InventoryItemRemoved; // 0x0AB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC8[0x8];                                      // 0x0AC8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FGameplayTagContainer& InCosmeticTags)> OnCosmeticTagsUpdated; // 0x0AD0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE0[0x8];                                      // 0x0AE0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGBCharVoiceInfo                       CharVoiceInfo;                                     // 0x0AE8(0x0014)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_AFC[0x24];                                     // 0x0AFC(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      CollisionTraceObjectTypes;                         // 0x0B20(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           HeadCollisionBones;                                // 0x0B30(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B40[0x10];                                     // 0x0B40(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           LeanLeftCollisionBones;                            // 0x0B50(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B60[0x10];                                     // 0x0B60(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           LeanRightCollisionBones;                           // 0x0B70(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B80[0x20];                                     // 0x0B80(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldUpdateSavedLagCompInfo;                     // 0x0BA0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BA1[0x3];                                      // 0x0BA1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxLagCompTime;                                    // 0x0BA4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           BodyInstanceBones;                                 // 0x0BA8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           RadialDamageBones;                                 // 0x0BB8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraSystem>          BloodImpactEffect;                                 // 0x0BC8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraSystem>          BloodExitEffect;                                   // 0x0BF0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraSystem>          NeckDeathEffect;                                   // 0x0C18(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                NeckDeathEffectLocationOffset;                     // 0x0C40(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               NeckDeathEffectRotationOffset;                     // 0x0C4C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<class AGBPlayerState*, struct FHitBulletIndexes> BulletHitMap;                              // 0x0C58(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FGBAISightPart>                 CharSightParts;                                    // 0x0CA8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        CharSightPartsCurve;                               // 0x0CB8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveCurviest*                         CharSightPartsCurveRef;                            // 0x0CD0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        LightLevelDistanceCurve;                           // 0x0CD8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveCurviest*                         LightLevelDistanceCurveRef;                        // 0x0CF0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpResetTime;                                     // 0x0CF8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpHopTime;                                       // 0x0CFC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         BulletIndex;                                       // 0x0D00(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D01[0x7];                                      // 0x0D01(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FName& RefBoneName, const struct FVector& RefPosPosition)> OnTakeHit; // 0x0D08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         RagdollImpulseStrength;                            // 0x0D18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsRagDoll : 1;                                    // 0x0D1C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_D1D[0x3];                                      // 0x0D1D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USkinnedDecalSampler*                   SkinnedDecalSampler;                               // 0x0D20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGBLXRDetectionComponent*               LightDetectionComponent;                           // 0x0D28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NVGBounce_WalkMultiplier;                          // 0x0D30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NVGBounce_RunMultiplier;                           // 0x0D34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NVGBounce_SprintMultiplier;                        // 0x0D38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NVGBounce_ImpulseDecayRate;                        // 0x0D3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NVGBounce_GlobalDecayRate;                         // 0x0D40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D44[0x10];                                     // 0x0D44(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StandToCrouchPelvisHeightDifference;               // 0x0D54(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D58[0x4];                                      // 0x0D58(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProneYawOffCenterLimit;                            // 0x0D5C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProneMawYawForTurnInPlace;                         // 0x0D60(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastShotTime;                                      // 0x0D64(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastShotRadius;                                    // 0x0D68(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D6C[0x8];                                      // 0x0D6C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeanSpamThreshold;                                 // 0x0D74(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D78[0x4];                                      // 0x0D78(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RunSpamThreshold;                                  // 0x0D7C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D80[0x4];                                      // 0x0D80(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintSpamThreshold;                               // 0x0D84(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D88[0x4];                                      // 0x0D88(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintTimeoutDuration;                             // 0x0D8C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static EHand GetOppositeHandEnum(EHand EquippedType);

	void AddArmStrengthInstantLoss(float Amount);
	void AddDefaultItems();
	void AddDefaultItemsEvent();
	void AddRecoil(const struct FGBRecoilData& RecoilData);
	void AddStaminaInstantLoss(float Amount);
	void AnimNotifyFootstep(bool bInLeftFoot);
	bool CanDamageRadial(const struct FVector& DamageOrigin, const TArray<class AActor*>& IgnoreActors, ECollisionChannel TraceChannel, const TArray<EPhysicalSurface>& SurfaceTypesToIgnore, struct FHitResult* OutHit);
	void CleanUpLocalInventory();
	void ClearBraceInfo();
	bool ClearSimilarItems(const struct FGameplayTagContainer& InvItemTags, bool bExactMatch, class AGBInvItem* Exclude);
	void ClientAddDefaultItems();
	void ClientSyncEquipped(class AGBInvItem* ServerEquippedLeft, class AGBInvItem* ServerEquippedRight);
	void DestroyInventory(bool bForceClient);
	void ForceClientEquippedSync();
	class AGBInvItem* GetInvItemAttachedToSocket(class FName SocketName);
	TArray<class AGBInvItem*> GetInvItemsAttachedToSocket(class FName SocketName);
	class AGBInvItem* GetItemAttachedToSocket(class FName SocketName);
	float GetMinLightLevel(const class FName& Type);
	bool GetPrevEquipped(class AGBInvItem** OutPrevEquippedLeft, class AGBInvItem** OutPrevEquippedRight);
	uint8 IncrementBulletIndex();
	bool IsFrozen();
	bool ModifyDamageCaused(int32& AppliedDamage, int32& Damage, struct FVector& Momentum, const struct FHitResult& HitInfo, class AActor* Victim, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageType);
	bool ModifyDamageTaken(int32& AppliedDamage, int32& Damage, struct FVector& Momentum, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageType);
	void NetMulticastPlayVoice(const class FName Key, bool bIsRadioMessage);
	void NetworkedMontageJumpToSection(class FName SectionName);
	void NotifyPlayerHasFired(const float ShotSoundLevel);
	void OnEndProneEvent(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
	void OnHopped();
	void OnLandedEffects(const struct FHitResult& Hit, float FallingSpeed);
	void OnMantleEvent();
	void OnPhysicsCollision(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnPlayVoiceEvent(class UAkAudioEvent* VoiceAudioEvent, bool bIsLocalPlayer);
	void OnRep_CharVoiceInfo();
	void OnRep_CurrentAnimLayerClass();
	void OnRep_DeathState(EGBDeathState OldDeathState);
	void OnRep_EquippedLeft(class AGBInvItem* LastLeftEquipped);
	void OnRep_EquippedRight(class AGBInvItem* LastRightEquipped);
	void OnRep_IsProne();
	void OnRep_LoadoutInfo();
	void OnRep_RecoilCount();
	void OnRep_RemoteDesiredEngagedAlpha();
	void OnRep_RemoteDesiredLeanAlpha();
	void OnRep_RemoteDesiredOffTargetAlpha();
	void OnRep_RNGSeed();
	void OnStaminaChangedEvent(float OldStamina);
	void OnStartProneEvent(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
	void OnStopVoiceEvent();
	void OptOut();
	void PlayDamageEffects();
	float PlayNetworkedMontage(class UAnimMontage* AnimMontage, class FName SyncName, float PlayRate, class FName StartSectionName, TSubclassOf<class UAnimInstance> AnimLayerClass, bool bReplicateToOwner);
	void PlayTakeHitEffects();
	void PlayVoice(const class FName Key, bool bIsRadioMessage);
	void Prone(bool bClientSimulation);
	void RemoveMeshComponentFromSkinnedDecalSampler(class USkeletalMeshComponent* MeshToRemove);
	void ResetSkinnedDecalSampler();
	float SeededFRandRange(float InMin, float InMax);
	void ServerClearBraceInfo();
	void ServerSetBraceLocation(const struct FVector& NewBraceLocation);
	void ServerSetDesiredEngagedAlpha(uint8 AlphaAsByte);
	void ServerSetDesiredLeanAlpha(uint8 AlphaAsByte);
	void ServerSetDesiredOffTargetAlpha(uint8 AlphaAsByte);
	void ServerSetLightLevel(const class FName& Type, float Alpha);
	void ServerSetMinLightLevel(const class FName& Type, float Alpha);
	void ServerSetRemoteHeadOffset(uint8 NewRemoteHeadPitchDif, uint8 NewRemoteHeadYawDif);
	void ServerSetWantsToRun(bool bNewWantsToRun);
	void ServerSetWantsToSprint(bool bNewWantsToSprint);
	void SetBraceInfo(const struct FVector& NewBraceLocation);
	void SetCharVoiceInfo(const struct FPrimaryAssetId& NewCharVoiceDataId, uint8 NewVoiceActorIndex);
	void SetCurrentAnimLayerClass(TSubclassOf<class UAnimInstance> NewAnimLayerClass);
	void SetCurrentHand(EHand NewHand);
	void SetDesiredEngagedAlpha(float NewDesiredEngagedAlpha);
	void SetDesiredLeanAlpha(float Alpha);
	void SetDesiredOffTargetAlpha(float NewDesiredOffTargetAlpha);
	void SetEquipped(EHand TargetHand, class AGBInvItem* NewEquipped, class AGBInvItem* LastEquipped);
	void SetLightLevel(const class FName& Type, float Alpha);
	void SetLoadoutInfo(class AGBKitInfo* NewLoadoutInfo);
	void SetMaxArmStrength(float NewMaxArmStrength);
	void SetMaxStamina(float NewMaxStamina);
	void SetMinLightLevel(const class FName& Type, float Alpha);
	void SetNetworkedMontageNextSection(class UAnimMontage* AnimMontage, class FName SectionNameToChange, class FName NextSection);
	void SetRagdollPhysics();
	void SetRecoilCount(uint8 NewRecoilCount);
	void SetRemoteHeadOffset();
	void SetWantsToRun(bool bNewWantsToRun);
	void SetWantsToSprint(bool bNewWantsToSprint);
	void StopNetworkedMontage(class UAnimMontage* AnimMontage);
	void StopVoice();
	void TakeFallingDamage(const struct FHitResult& Hit, float FallingSpeed);
	void ToggleNightVision();
	void TriggerRagdoll();
	void UnarmedLayerSync();
	void UnProne(bool bToCrouch, bool bClientSimulation);
	void UnsetPlayerInteractions();
	void UpdateLean(float DeltaSeconds);
	void UpdateStamina(float DeltaSeconds);
	void UpdateSway(float DeltaSeconds);

	struct FRotator GetAimCenterOffset() const;
	class UAnimInstance* GetAnimInstance() const;
	float GetArmStrength() const;
	class FName GetBodyCamSocket() const;
	float GetBreathingSinValue() const;
	class UAkAudioEvent* GetCharVoiceAudioEvent(const class FName Key) const;
	class FName GetChestSlingPoint() const;
	const struct FGameplayTagContainer GetCosmeticTags() const;
	float GetCrouchAlpha() const;
	TSubclassOf<class UAnimInstance> GetCurrentAnimLayerClass() const;
	EHand GetCurrentHand() const;
	EGBDeathState GetDeathState() const;
	float GetDesiredEngagedAlpha() const;
	float GetDesiredLeanAlpha() const;
	float GetDesiredOffTargetAlpha() const;
	float GetEngagedAlpha() const;
	class AGBInvItem* GetEquipped(EHand TargetHand) const;
	float GetEquippedRotationalInertiaModifier() const;
	class FName GetEyesSocket() const;
	class AGBInvItem* GetFirstInvItemByClass(TSubclassOf<class AGBInvItem> InvItemClass) const;
	class AGBInvItem* GetFirstInvItemByItemAssetId(const struct FPrimaryAssetId& InvItemAssetId, TSubclassOf<class AGBInvItem> CastToInvItemClass) const;
	class AGBInvItem* GetFirstInvItemByTags(const struct FGameplayTagContainer& InvItemTags, bool bExactMatch, TSubclassOf<class AGBInvItem> CastToInvItemClass) const;
	float GetFlattenSwayTime() const;
	class UAkComponent* GetFootstepComp() const;
	class UGBCharacterMovement* GetGBMovementComp() const;
	EHand GetHandEnum(EHand EquippedType) const;
	EHand GetHandEnumFromSocket(class FName SocketName) const;
	class FName GetHeadCamSocket() const;
	TArray<class AGBInvItem*> GetInventoryList() const;
	TArray<class AGBInvItem*> GetInvItemsByClass(TSubclassOf<class AGBInvItem> InvItemClass) const;
	TArray<class AGBInvItem*> GetInvItemsByItemAssetId(const struct FPrimaryAssetId& InvItemAssetId) const;
	TArray<class AGBInvItem*> GetInvItemsByTags(const struct FGameplayTagContainer& InvItemTags, bool bExactMatch) const;
	class FName GetItemHandSocket(EHand TargetHand) const;
	float GetLastTakeHitTime() const;
	float GetLeanAlpha() const;
	class UGBLXRDetectionComponent* GetLightDetectionComponent() const;
	float GetLightLevelScale() const;
	class AGBPlayerController* GetLocalViewer() const;
	float GetMaxArmStrength() const;
	float GetMaxStamina() const;
	float GetMovementDirection() const;
	float GetMovementSpeed() const;
	class UAnimMontage* GetNetworkedMontage() const;
	class FName GetNetworkedMontageSection() const;
	class FName GetNetworkedMontageSyncName() const;
	float GetOffTargetAlpha() const;
	class FName GetPelvisBone() const;
	float GetProneYawCenter() const;
	float GetProneYawOffCenterLimit() const;
	float GetRecoilAlpha() const;
	uint8 GetRecoilCount() const;
	struct FRotator GetRecoilOffset() const;
	struct FRotator GetRemoteHeadOffset() const;
	float GetRemoteViewPitch() const;
	class FName GetShoulderSlingPoint(EHand TargetHand) const;
	struct FTransform GetSightLineTransform() const;
	class USkinnedDecalSampler* GetSkinnedDecalSampler() const;
	float GetStamina() const;
	struct FRotator GetSwayOffset() const;
	float GetTotalItemWeight() const;
	float GetTracedCollisionOffset() const;
	float GetViewPitchMax() const;
	float GetViewPitchMin() const;
	float GetVisibilityModifier() const;
	class UAkComponent* GetVoiceComp() const;
	bool GetWantsToControlBreath() const;
	bool Is3DMovementMode() const;
	bool IsAlive() const;
	bool IsBeingLed() const;
	bool IsCrouched() const;
	bool IsDummyCharacter() const;
	bool IsEngaged() const;
	bool IsInInventory(const class AGBInvItem* InvItem) const;
	bool IsLeading() const;
	bool IsLocallyViewed() const;
	bool IsProne() const;
	bool IsRagdoll() const;
	bool IsRunning() const;
	bool IsSprinting() const;
	bool IsUICharacter() const;
	bool WantsToLean() const;
	bool WantsToLeanLeft() const;
	bool WantsToLeanRight() const;
	bool WantsToRun() const;
	bool WantsToSprint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBCharacter">();
	}
	static class AGBCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBCharacter>();
	}
};
static_assert(alignof(AGBCharacter) == 0x000010, "Wrong alignment on AGBCharacter");
static_assert(sizeof(AGBCharacter) == 0x000D90, "Wrong size on AGBCharacter");
static_assert(offsetof(AGBCharacter, GameplayAbilitySets) == 0x0004E8, "Member 'AGBCharacter::GameplayAbilitySets' has a wrong offset!");
static_assert(offsetof(AGBCharacter, TagRelationshipMapping) == 0x0004F8, "Member 'AGBCharacter::TagRelationshipMapping' has a wrong offset!");
static_assert(offsetof(AGBCharacter, UnarmedAnimLayerClass) == 0x000510, "Member 'AGBCharacter::UnarmedAnimLayerClass' has a wrong offset!");
static_assert(offsetof(AGBCharacter, AKVoiceComp) == 0x000518, "Member 'AGBCharacter::AKVoiceComp' has a wrong offset!");
static_assert(offsetof(AGBCharacter, AKFootstepComp) == 0x000520, "Member 'AGBCharacter::AKFootstepComp' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MinRTPCSpeedValueChange) == 0x00052C, "Member 'AGBCharacter::MinRTPCSpeedValueChange' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MinRTPCWeightValueChange) == 0x000534, "Member 'AGBCharacter::MinRTPCWeightValueChange' has a wrong offset!");
static_assert(offsetof(AGBCharacter, OnReceivePlayerState) == 0x000538, "Member 'AGBCharacter::OnReceivePlayerState' has a wrong offset!");
static_assert(offsetof(AGBCharacter, OnBecomeViewTarget) == 0x000548, "Member 'AGBCharacter::OnBecomeViewTarget' has a wrong offset!");
static_assert(offsetof(AGBCharacter, OnEndViewTarget) == 0x000558, "Member 'AGBCharacter::OnEndViewTarget' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ItemHandSocketLeft) == 0x000574, "Member 'AGBCharacter::ItemHandSocketLeft' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ItemHandSocketRight) == 0x00057C, "Member 'AGBCharacter::ItemHandSocketRight' has a wrong offset!");
static_assert(offsetof(AGBCharacter, SightLineBone) == 0x000584, "Member 'AGBCharacter::SightLineBone' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MaxHealth) == 0x000590, "Member 'AGBCharacter::MaxHealth' has a wrong offset!");
static_assert(offsetof(AGBCharacter, Health) == 0x000594, "Member 'AGBCharacter::Health' has a wrong offset!");
static_assert(offsetof(AGBCharacter, RemoteHeadPitchDif) == 0x00059C, "Member 'AGBCharacter::RemoteHeadPitchDif' has a wrong offset!");
static_assert(offsetof(AGBCharacter, RemoteHeadYawDif) == 0x00059D, "Member 'AGBCharacter::RemoteHeadYawDif' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ViewPitchMin) == 0x0005A0, "Member 'AGBCharacter::ViewPitchMin' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ViewPitchMax) == 0x0005A4, "Member 'AGBCharacter::ViewPitchMax' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ViewPitchMinProne) == 0x0005A8, "Member 'AGBCharacter::ViewPitchMinProne' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ViewPitchMaxProne) == 0x0005AC, "Member 'AGBCharacter::ViewPitchMaxProne' has a wrong offset!");
static_assert(offsetof(AGBCharacter, CrouchInterpSpeed) == 0x0005B4, "Member 'AGBCharacter::CrouchInterpSpeed' has a wrong offset!");
static_assert(offsetof(AGBCharacter, GBMovementComponent) == 0x0005C0, "Member 'AGBCharacter::GBMovementComponent' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MaxUnderWaterTime) == 0x0005C8, "Member 'AGBCharacter::MaxUnderWaterTime' has a wrong offset!");
static_assert(offsetof(AGBCharacter, DrowningDamagePerSecond) == 0x0005CC, "Member 'AGBCharacter::DrowningDamagePerSecond' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LastBreathTime) == 0x0005D0, "Member 'AGBCharacter::LastBreathTime' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LastDrownTime) == 0x0005D4, "Member 'AGBCharacter::LastDrownTime' has a wrong offset!");
static_assert(offsetof(AGBCharacter, HeadUnderWaterEffect) == 0x0005D8, "Member 'AGBCharacter::HeadUnderWaterEffect' has a wrong offset!");
static_assert(offsetof(AGBCharacter, GlobalEnvironmentMPC) == 0x0005E8, "Member 'AGBCharacter::GlobalEnvironmentMPC' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MinSafeFallSpeed) == 0x0005F0, "Member 'AGBCharacter::MinSafeFallSpeed' has a wrong offset!");
static_assert(offsetof(AGBCharacter, DeathFallSpeed) == 0x0005F4, "Member 'AGBCharacter::DeathFallSpeed' has a wrong offset!");
static_assert(offsetof(AGBCharacter, CrushingDamageFactor) == 0x0005F8, "Member 'AGBCharacter::CrushingDamageFactor' has a wrong offset!");
static_assert(offsetof(AGBCharacter, OnRecoilCountUpdated) == 0x000600, "Member 'AGBCharacter::OnRecoilCountUpdated' has a wrong offset!");
static_assert(offsetof(AGBCharacter, EquippedLeft) == 0x000610, "Member 'AGBCharacter::EquippedLeft' has a wrong offset!");
static_assert(offsetof(AGBCharacter, EquippedRight) == 0x000618, "Member 'AGBCharacter::EquippedRight' has a wrong offset!");
static_assert(offsetof(AGBCharacter, PrevEquippedLeft) == 0x000620, "Member 'AGBCharacter::PrevEquippedLeft' has a wrong offset!");
static_assert(offsetof(AGBCharacter, PrevEquippedRight) == 0x000628, "Member 'AGBCharacter::PrevEquippedRight' has a wrong offset!");
static_assert(offsetof(AGBCharacter, CurrentAnimLayerClass) == 0x000630, "Member 'AGBCharacter::CurrentAnimLayerClass' has a wrong offset!");
static_assert(offsetof(AGBCharacter, CurrentHand) == 0x00064D, "Member 'AGBCharacter::CurrentHand' has a wrong offset!");
static_assert(offsetof(AGBCharacter, DesiredLeanAlpha) == 0x000650, "Member 'AGBCharacter::DesiredLeanAlpha' has a wrong offset!");
static_assert(offsetof(AGBCharacter, RemoteDesiredLeanAlpha) == 0x000654, "Member 'AGBCharacter::RemoteDesiredLeanAlpha' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LeanInterpSpeed) == 0x000658, "Member 'AGBCharacter::LeanInterpSpeed' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LeanAlpha) == 0x00065C, "Member 'AGBCharacter::LeanAlpha' has a wrong offset!");
static_assert(offsetof(AGBCharacter, OnPositionAlphasUpdated) == 0x000668, "Member 'AGBCharacter::OnPositionAlphasUpdated' has a wrong offset!");
static_assert(offsetof(AGBCharacter, OnPositionAlphaMet) == 0x000678, "Member 'AGBCharacter::OnPositionAlphaMet' has a wrong offset!");
static_assert(offsetof(AGBCharacter, HeadOffsetPitchMin) == 0x000688, "Member 'AGBCharacter::HeadOffsetPitchMin' has a wrong offset!");
static_assert(offsetof(AGBCharacter, HeadOffsetPitchMax) == 0x00068C, "Member 'AGBCharacter::HeadOffsetPitchMax' has a wrong offset!");
static_assert(offsetof(AGBCharacter, HeadOffsetYawMax) == 0x000690, "Member 'AGBCharacter::HeadOffsetYawMax' has a wrong offset!");
static_assert(offsetof(AGBCharacter, DesiredWaterLevel) == 0x000694, "Member 'AGBCharacter::DesiredWaterLevel' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ActualWaterLevel) == 0x000695, "Member 'AGBCharacter::ActualWaterLevel' has a wrong offset!");
static_assert(offsetof(AGBCharacter, RecoilCount) == 0x0006A4, "Member 'AGBCharacter::RecoilCount' has a wrong offset!");
static_assert(offsetof(AGBCharacter, RNGSeed) == 0x000708, "Member 'AGBCharacter::RNGSeed' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LoadoutInfo) == 0x000718, "Member 'AGBCharacter::LoadoutInfo' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LeftChestSlingPoint) == 0x000720, "Member 'AGBCharacter::LeftChestSlingPoint' has a wrong offset!");
static_assert(offsetof(AGBCharacter, RightChestSlingPoint) == 0x000728, "Member 'AGBCharacter::RightChestSlingPoint' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LeftShoulderSlingPoint) == 0x000730, "Member 'AGBCharacter::LeftShoulderSlingPoint' has a wrong offset!");
static_assert(offsetof(AGBCharacter, RightShoulderSlingPoint) == 0x000738, "Member 'AGBCharacter::RightShoulderSlingPoint' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MaxStamina) == 0x000740, "Member 'AGBCharacter::MaxStamina' has a wrong offset!");
static_assert(offsetof(AGBCharacter, Stamina) == 0x000744, "Member 'AGBCharacter::Stamina' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaGainIdle) == 0x000748, "Member 'AGBCharacter::StaminaGainIdle' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaGainWalking) == 0x00074C, "Member 'AGBCharacter::StaminaGainWalking' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaGainRunning) == 0x000750, "Member 'AGBCharacter::StaminaGainRunning' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaLossWalking) == 0x000754, "Member 'AGBCharacter::StaminaLossWalking' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaLossRunning) == 0x000758, "Member 'AGBCharacter::StaminaLossRunning' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaLossSprinting) == 0x00075C, "Member 'AGBCharacter::StaminaLossSprinting' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaLossJump) == 0x000760, "Member 'AGBCharacter::StaminaLossJump' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaLossControlledBreathing) == 0x000764, "Member 'AGBCharacter::StaminaLossControlledBreathing' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaLossCrouchToStanding) == 0x000768, "Member 'AGBCharacter::StaminaLossCrouchToStanding' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaLossGoToProne) == 0x00076C, "Member 'AGBCharacter::StaminaLossGoToProne' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaLossGetUpFromProne) == 0x000770, "Member 'AGBCharacter::StaminaLossGetUpFromProne' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaLossLean) == 0x000774, "Member 'AGBCharacter::StaminaLossLean' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaInstantLossLeanSpam) == 0x000778, "Member 'AGBCharacter::StaminaInstantLossLeanSpam' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaInstantLossRunSpam) == 0x00077C, "Member 'AGBCharacter::StaminaInstantLossRunSpam' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaInstantLossSprintSpam) == 0x000780, "Member 'AGBCharacter::StaminaInstantLossSprintSpam' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaMinWeightThreshold) == 0x000784, "Member 'AGBCharacter::StaminaMinWeightThreshold' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaMaxWeightThreshold) == 0x000788, "Member 'AGBCharacter::StaminaMaxWeightThreshold' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaAudibleBreathingThreshold) == 0x000790, "Member 'AGBCharacter::StaminaAudibleBreathingThreshold' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StaminaBreathingSwayThreshold) == 0x000794, "Member 'AGBCharacter::StaminaBreathingSwayThreshold' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MinRespiratoryRate) == 0x000798, "Member 'AGBCharacter::MinRespiratoryRate' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MaxRespiratoryRate) == 0x00079C, "Member 'AGBCharacter::MaxRespiratoryRate' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MaxArmStrength) == 0x0007B8, "Member 'AGBCharacter::MaxArmStrength' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrength) == 0x0007BC, "Member 'AGBCharacter::ArmStrength' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthGainUnarmed) == 0x0007C0, "Member 'AGBCharacter::ArmStrengthGainUnarmed' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthGainIdle) == 0x0007C4, "Member 'AGBCharacter::ArmStrengthGainIdle' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthGainWalking) == 0x0007C8, "Member 'AGBCharacter::ArmStrengthGainWalking' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthGainRunning) == 0x0007CC, "Member 'AGBCharacter::ArmStrengthGainRunning' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthLossIdle) == 0x0007D0, "Member 'AGBCharacter::ArmStrengthLossIdle' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthLossIdleEngaged) == 0x0007D4, "Member 'AGBCharacter::ArmStrengthLossIdleEngaged' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthLossWalking) == 0x0007D8, "Member 'AGBCharacter::ArmStrengthLossWalking' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthLossWalkingEngaged) == 0x0007DC, "Member 'AGBCharacter::ArmStrengthLossWalkingEngaged' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthLossRunning) == 0x0007E0, "Member 'AGBCharacter::ArmStrengthLossRunning' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthLossRunningEngaged) == 0x0007E4, "Member 'AGBCharacter::ArmStrengthLossRunningEngaged' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthLossSprinting) == 0x0007E8, "Member 'AGBCharacter::ArmStrengthLossSprinting' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthLossJump) == 0x0007EC, "Member 'AGBCharacter::ArmStrengthLossJump' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthLossJumpEngaged) == 0x0007F0, "Member 'AGBCharacter::ArmStrengthLossJumpEngaged' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthLossCrouchToStanding) == 0x0007F4, "Member 'AGBCharacter::ArmStrengthLossCrouchToStanding' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthLossGoToProne) == 0x0007F8, "Member 'AGBCharacter::ArmStrengthLossGoToProne' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthLossGetUpFromProne) == 0x0007FC, "Member 'AGBCharacter::ArmStrengthLossGetUpFromProne' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthLossLean) == 0x000800, "Member 'AGBCharacter::ArmStrengthLossLean' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthInstantLossLeanSpam) == 0x000804, "Member 'AGBCharacter::ArmStrengthInstantLossLeanSpam' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthInstantLossRunSpam) == 0x000808, "Member 'AGBCharacter::ArmStrengthInstantLossRunSpam' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthInstantLossSprintSpam) == 0x00080C, "Member 'AGBCharacter::ArmStrengthInstantLossSprintSpam' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthMinWeightThreshold) == 0x000810, "Member 'AGBCharacter::ArmStrengthMinWeightThreshold' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmStrengthMaxWeightThreshold) == 0x000814, "Member 'AGBCharacter::ArmStrengthMaxWeightThreshold' has a wrong offset!");
static_assert(offsetof(AGBCharacter, SwaySeed) == 0x000824, "Member 'AGBCharacter::SwaySeed' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmSwayFreqRandRangeBase) == 0x000828, "Member 'AGBCharacter::ArmSwayFreqRandRangeBase' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmSwayFreqRandRangeDev) == 0x000830, "Member 'AGBCharacter::ArmSwayFreqRandRangeDev' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmTwitchChance) == 0x000848, "Member 'AGBCharacter::ArmTwitchChance' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ArmEaseInOutExp) == 0x00084C, "Member 'AGBCharacter::ArmEaseInOutExp' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MaxBreathingPitch) == 0x000864, "Member 'AGBCharacter::MaxBreathingPitch' has a wrong offset!");
static_assert(offsetof(AGBCharacter, FlattenSwayDuration) == 0x000870, "Member 'AGBCharacter::FlattenSwayDuration' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ControlBreathRecoveryScale) == 0x000878, "Member 'AGBCharacter::ControlBreathRecoveryScale' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MaxBreathingDeviation) == 0x0008A0, "Member 'AGBCharacter::MaxBreathingDeviation' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MinReadySway) == 0x0008A8, "Member 'AGBCharacter::MinReadySway' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MaxReadySway) == 0x0008B0, "Member 'AGBCharacter::MaxReadySway' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MinReadySwayCrouched) == 0x0008B8, "Member 'AGBCharacter::MinReadySwayCrouched' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MaxReadySwayCrouched) == 0x0008C0, "Member 'AGBCharacter::MaxReadySwayCrouched' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MinEngagedSway) == 0x0008C8, "Member 'AGBCharacter::MinEngagedSway' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MaxEngagedSway) == 0x0008D0, "Member 'AGBCharacter::MaxEngagedSway' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MinEngagedSwayCrouched) == 0x0008D8, "Member 'AGBCharacter::MinEngagedSwayCrouched' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MaxEngagedSwayCrouched) == 0x0008E0, "Member 'AGBCharacter::MaxEngagedSwayCrouched' has a wrong offset!");
static_assert(offsetof(AGBCharacter, RemoteDesiredEngagedAlpha) == 0x0008FC, "Member 'AGBCharacter::RemoteDesiredEngagedAlpha' has a wrong offset!");
static_assert(offsetof(AGBCharacter, RemoteDesiredOffTargetAlpha) == 0x000908, "Member 'AGBCharacter::RemoteDesiredOffTargetAlpha' has a wrong offset!");
static_assert(offsetof(AGBCharacter, OnLoadoutApplied) == 0x000910, "Member 'AGBCharacter::OnLoadoutApplied' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LastTakeHitInfo) == 0x000920, "Member 'AGBCharacter::LastTakeHitInfo' has a wrong offset!");
static_assert(offsetof(AGBCharacter, FootstepTraceOffset) == 0x000958, "Member 'AGBCharacter::FootstepTraceOffset' has a wrong offset!");
static_assert(offsetof(AGBCharacter, bStartingRagdoll) == 0x000962, "Member 'AGBCharacter::bStartingRagdoll' has a wrong offset!");
static_assert(offsetof(AGBCharacter, DeathState) == 0x000963, "Member 'AGBCharacter::DeathState' has a wrong offset!");
static_assert(offsetof(AGBCharacter, BoneNameToTagMap) == 0x000968, "Member 'AGBCharacter::BoneNameToTagMap' has a wrong offset!");
static_assert(offsetof(AGBCharacter, OnDeathStarted) == 0x0009B8, "Member 'AGBCharacter::OnDeathStarted' has a wrong offset!");
static_assert(offsetof(AGBCharacter, OnDeathFinished) == 0x0009C8, "Member 'AGBCharacter::OnDeathFinished' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LastTakeHitTime) == 0x0009D8, "Member 'AGBCharacter::LastTakeHitTime' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LastTakeHitReplicatedTime) == 0x0009DC, "Member 'AGBCharacter::LastTakeHitReplicatedTime' has a wrong offset!");
static_assert(offsetof(AGBCharacter, BodyImpactSoundSpeedSquared) == 0x0009E0, "Member 'AGBCharacter::BodyImpactSoundSpeedSquared' has a wrong offset!");
static_assert(offsetof(AGBCharacter, TimeBetweenBodyImpactSounds) == 0x0009E8, "Member 'AGBCharacter::TimeBetweenBodyImpactSounds' has a wrong offset!");
static_assert(offsetof(AGBCharacter, BoneDamageScaleMap) == 0x0009F0, "Member 'AGBCharacter::BoneDamageScaleMap' has a wrong offset!");
static_assert(offsetof(AGBCharacter, RootBone) == 0x000A40, "Member 'AGBCharacter::RootBone' has a wrong offset!");
static_assert(offsetof(AGBCharacter, PelvisBone) == 0x000A48, "Member 'AGBCharacter::PelvisBone' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LeftFootBone) == 0x000A50, "Member 'AGBCharacter::LeftFootBone' has a wrong offset!");
static_assert(offsetof(AGBCharacter, RightFootBone) == 0x000A58, "Member 'AGBCharacter::RightFootBone' has a wrong offset!");
static_assert(offsetof(AGBCharacter, EyesSocket) == 0x000A60, "Member 'AGBCharacter::EyesSocket' has a wrong offset!");
static_assert(offsetof(AGBCharacter, BodyCamSocket) == 0x000A68, "Member 'AGBCharacter::BodyCamSocket' has a wrong offset!");
static_assert(offsetof(AGBCharacter, HeadCamSocket) == 0x000A70, "Member 'AGBCharacter::HeadCamSocket' has a wrong offset!");
static_assert(offsetof(AGBCharacter, InventoryList) == 0x000A78, "Member 'AGBCharacter::InventoryList' has a wrong offset!");
static_assert(offsetof(AGBCharacter, InventoryItemAdded) == 0x000AA8, "Member 'AGBCharacter::InventoryItemAdded' has a wrong offset!");
static_assert(offsetof(AGBCharacter, InventoryItemRemoved) == 0x000AB8, "Member 'AGBCharacter::InventoryItemRemoved' has a wrong offset!");
static_assert(offsetof(AGBCharacter, OnCosmeticTagsUpdated) == 0x000AD0, "Member 'AGBCharacter::OnCosmeticTagsUpdated' has a wrong offset!");
static_assert(offsetof(AGBCharacter, CharVoiceInfo) == 0x000AE8, "Member 'AGBCharacter::CharVoiceInfo' has a wrong offset!");
static_assert(offsetof(AGBCharacter, CollisionTraceObjectTypes) == 0x000B20, "Member 'AGBCharacter::CollisionTraceObjectTypes' has a wrong offset!");
static_assert(offsetof(AGBCharacter, HeadCollisionBones) == 0x000B30, "Member 'AGBCharacter::HeadCollisionBones' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LeanLeftCollisionBones) == 0x000B50, "Member 'AGBCharacter::LeanLeftCollisionBones' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LeanRightCollisionBones) == 0x000B70, "Member 'AGBCharacter::LeanRightCollisionBones' has a wrong offset!");
static_assert(offsetof(AGBCharacter, bShouldUpdateSavedLagCompInfo) == 0x000BA0, "Member 'AGBCharacter::bShouldUpdateSavedLagCompInfo' has a wrong offset!");
static_assert(offsetof(AGBCharacter, MaxLagCompTime) == 0x000BA4, "Member 'AGBCharacter::MaxLagCompTime' has a wrong offset!");
static_assert(offsetof(AGBCharacter, BodyInstanceBones) == 0x000BA8, "Member 'AGBCharacter::BodyInstanceBones' has a wrong offset!");
static_assert(offsetof(AGBCharacter, RadialDamageBones) == 0x000BB8, "Member 'AGBCharacter::RadialDamageBones' has a wrong offset!");
static_assert(offsetof(AGBCharacter, BloodImpactEffect) == 0x000BC8, "Member 'AGBCharacter::BloodImpactEffect' has a wrong offset!");
static_assert(offsetof(AGBCharacter, BloodExitEffect) == 0x000BF0, "Member 'AGBCharacter::BloodExitEffect' has a wrong offset!");
static_assert(offsetof(AGBCharacter, NeckDeathEffect) == 0x000C18, "Member 'AGBCharacter::NeckDeathEffect' has a wrong offset!");
static_assert(offsetof(AGBCharacter, NeckDeathEffectLocationOffset) == 0x000C40, "Member 'AGBCharacter::NeckDeathEffectLocationOffset' has a wrong offset!");
static_assert(offsetof(AGBCharacter, NeckDeathEffectRotationOffset) == 0x000C4C, "Member 'AGBCharacter::NeckDeathEffectRotationOffset' has a wrong offset!");
static_assert(offsetof(AGBCharacter, BulletHitMap) == 0x000C58, "Member 'AGBCharacter::BulletHitMap' has a wrong offset!");
static_assert(offsetof(AGBCharacter, CharSightParts) == 0x000CA8, "Member 'AGBCharacter::CharSightParts' has a wrong offset!");
static_assert(offsetof(AGBCharacter, CharSightPartsCurve) == 0x000CB8, "Member 'AGBCharacter::CharSightPartsCurve' has a wrong offset!");
static_assert(offsetof(AGBCharacter, CharSightPartsCurveRef) == 0x000CD0, "Member 'AGBCharacter::CharSightPartsCurveRef' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LightLevelDistanceCurve) == 0x000CD8, "Member 'AGBCharacter::LightLevelDistanceCurve' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LightLevelDistanceCurveRef) == 0x000CF0, "Member 'AGBCharacter::LightLevelDistanceCurveRef' has a wrong offset!");
static_assert(offsetof(AGBCharacter, JumpResetTime) == 0x000CF8, "Member 'AGBCharacter::JumpResetTime' has a wrong offset!");
static_assert(offsetof(AGBCharacter, JumpHopTime) == 0x000CFC, "Member 'AGBCharacter::JumpHopTime' has a wrong offset!");
static_assert(offsetof(AGBCharacter, BulletIndex) == 0x000D00, "Member 'AGBCharacter::BulletIndex' has a wrong offset!");
static_assert(offsetof(AGBCharacter, OnTakeHit) == 0x000D08, "Member 'AGBCharacter::OnTakeHit' has a wrong offset!");
static_assert(offsetof(AGBCharacter, RagdollImpulseStrength) == 0x000D18, "Member 'AGBCharacter::RagdollImpulseStrength' has a wrong offset!");
static_assert(offsetof(AGBCharacter, SkinnedDecalSampler) == 0x000D20, "Member 'AGBCharacter::SkinnedDecalSampler' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LightDetectionComponent) == 0x000D28, "Member 'AGBCharacter::LightDetectionComponent' has a wrong offset!");
static_assert(offsetof(AGBCharacter, NVGBounce_WalkMultiplier) == 0x000D30, "Member 'AGBCharacter::NVGBounce_WalkMultiplier' has a wrong offset!");
static_assert(offsetof(AGBCharacter, NVGBounce_RunMultiplier) == 0x000D34, "Member 'AGBCharacter::NVGBounce_RunMultiplier' has a wrong offset!");
static_assert(offsetof(AGBCharacter, NVGBounce_SprintMultiplier) == 0x000D38, "Member 'AGBCharacter::NVGBounce_SprintMultiplier' has a wrong offset!");
static_assert(offsetof(AGBCharacter, NVGBounce_ImpulseDecayRate) == 0x000D3C, "Member 'AGBCharacter::NVGBounce_ImpulseDecayRate' has a wrong offset!");
static_assert(offsetof(AGBCharacter, NVGBounce_GlobalDecayRate) == 0x000D40, "Member 'AGBCharacter::NVGBounce_GlobalDecayRate' has a wrong offset!");
static_assert(offsetof(AGBCharacter, StandToCrouchPelvisHeightDifference) == 0x000D54, "Member 'AGBCharacter::StandToCrouchPelvisHeightDifference' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ProneYawOffCenterLimit) == 0x000D5C, "Member 'AGBCharacter::ProneYawOffCenterLimit' has a wrong offset!");
static_assert(offsetof(AGBCharacter, ProneMawYawForTurnInPlace) == 0x000D60, "Member 'AGBCharacter::ProneMawYawForTurnInPlace' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LastShotTime) == 0x000D64, "Member 'AGBCharacter::LastShotTime' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LastShotRadius) == 0x000D68, "Member 'AGBCharacter::LastShotRadius' has a wrong offset!");
static_assert(offsetof(AGBCharacter, LeanSpamThreshold) == 0x000D74, "Member 'AGBCharacter::LeanSpamThreshold' has a wrong offset!");
static_assert(offsetof(AGBCharacter, RunSpamThreshold) == 0x000D7C, "Member 'AGBCharacter::RunSpamThreshold' has a wrong offset!");
static_assert(offsetof(AGBCharacter, SprintSpamThreshold) == 0x000D84, "Member 'AGBCharacter::SprintSpamThreshold' has a wrong offset!");
static_assert(offsetof(AGBCharacter, SprintTimeoutDuration) == 0x000D8C, "Member 'AGBCharacter::SprintTimeoutDuration' has a wrong offset!");

// Class GroundBranch.GBAIBarkManager
// 0x0050 (0x0270 - 0x0220)
class AGBAIBarkManager final : public AActor
{
public:
	uint8                                         Pad_220[0x50];                                     // 0x0220(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Bark(class AGBKytController* AIController, class FName BarkType, class FName BarkKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAIBarkManager">();
	}
	static class AGBAIBarkManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBAIBarkManager>();
	}
};
static_assert(alignof(AGBAIBarkManager) == 0x000008, "Wrong alignment on AGBAIBarkManager");
static_assert(sizeof(AGBAIBarkManager) == 0x000270, "Wrong size on AGBAIBarkManager");

// Class GroundBranch.GBAIBehaviorBase
// 0x0018 (0x0040 - 0x0028)
class UGBAIBehaviorBase : public UObject
{
public:
	TArray<class UGBAIObjectiveBase*>             Objectives;                                        // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class AGBKytController*                       OwnerController;                                   // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnEnterState();
	void OnExitState();
	void TickState(float DeltaTime);

	class UKytBlackboard* GetCommandBlackboard() const;
	class UKytBlackboard* GetCommonBlackboard() const;
	float GetScore() const;
	bool PreCondition() const;
	class UGBAIObjectiveBase* TryGetCurrentObjective(TSubclassOf<class UGBAIObjectiveBase> ObjectiveClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAIBehaviorBase">();
	}
	static class UGBAIBehaviorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAIBehaviorBase>();
	}
};
static_assert(alignof(UGBAIBehaviorBase) == 0x000008, "Wrong alignment on UGBAIBehaviorBase");
static_assert(sizeof(UGBAIBehaviorBase) == 0x000040, "Wrong size on UGBAIBehaviorBase");
static_assert(offsetof(UGBAIBehaviorBase, Objectives) == 0x000028, "Member 'UGBAIBehaviorBase::Objectives' has a wrong offset!");
static_assert(offsetof(UGBAIBehaviorBase, OwnerController) == 0x000038, "Member 'UGBAIBehaviorBase::OwnerController' has a wrong offset!");

// Class GroundBranch.GBAIBehaviorSelectionComponent
// 0x0090 (0x0140 - 0x00B0)
class UGBAIBehaviorSelectionComponent final : public UActorComponent
{
public:
	TArray<TSubclassOf<class UGBAIBehaviorBase>>  InitialBehaviorClasses;                            // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UGBAIBehaviorBase*                      CurrentBehavior;                                   // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UGBAIBehaviorBase*>              Behaviors;                                         // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UGBAIObjectiveBase*>             Objectives;                                        // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UGBAIObjectiveGeneratorBase*            ObjectiveGenerator;                                // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x50];                                      // 0x00F0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBehavior(class UGBAIBehaviorBase* Behavior);
	void AddObjective(class UGBAIObjectiveBase* Objective);
	void SetCurrentBehavior(class UGBAIBehaviorBase* NewBehavior);
	void SetObjectiveGenerator(class UGBAIObjectiveGeneratorBase* Generator);

	TArray<class UGBAIBehaviorBase*> GetBehaviors() const;
	class UGBAIBehaviorBase* GetCurrentBehavior() const;
	class UGBAIObjectiveBase* TryGetCurrentObjective(TSubclassOf<class UGBAIObjectiveBase> ObjectiveClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAIBehaviorSelectionComponent">();
	}
	static class UGBAIBehaviorSelectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAIBehaviorSelectionComponent>();
	}
};
static_assert(alignof(UGBAIBehaviorSelectionComponent) == 0x000008, "Wrong alignment on UGBAIBehaviorSelectionComponent");
static_assert(sizeof(UGBAIBehaviorSelectionComponent) == 0x000140, "Wrong size on UGBAIBehaviorSelectionComponent");
static_assert(offsetof(UGBAIBehaviorSelectionComponent, InitialBehaviorClasses) == 0x0000B0, "Member 'UGBAIBehaviorSelectionComponent::InitialBehaviorClasses' has a wrong offset!");
static_assert(offsetof(UGBAIBehaviorSelectionComponent, CurrentBehavior) == 0x0000C0, "Member 'UGBAIBehaviorSelectionComponent::CurrentBehavior' has a wrong offset!");
static_assert(offsetof(UGBAIBehaviorSelectionComponent, Behaviors) == 0x0000C8, "Member 'UGBAIBehaviorSelectionComponent::Behaviors' has a wrong offset!");
static_assert(offsetof(UGBAIBehaviorSelectionComponent, Objectives) == 0x0000D8, "Member 'UGBAIBehaviorSelectionComponent::Objectives' has a wrong offset!");
static_assert(offsetof(UGBAIBehaviorSelectionComponent, ObjectiveGenerator) == 0x0000E8, "Member 'UGBAIBehaviorSelectionComponent::ObjectiveGenerator' has a wrong offset!");

// Class GroundBranch.GBCharacterMovement
// 0x0130 (0x0C30 - 0x0B00)
class UGBCharacterMovement final : public UCharacterMovementComponent
{
public:
	float                                         MaxWalkSpeedForward;                               // 0x0B00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedForwardLeftRight;                      // 0x0B04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedBackward;                              // 0x0B08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedLeftRight;                             // 0x0B0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedForward;                                // 0x0B10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedForwardCrouched;                       // 0x0B14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedForwardLeftRightCrouched;              // 0x0B18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedBackwardCrouched;                      // 0x0B1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedLeftRightCrouched;                     // 0x0B20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedForwardLeftRight;                       // 0x0B24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedBackward;                               // 0x0B28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedLeftRight;                              // 0x0B2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedForwardCrouched;                        // 0x0B30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedForwardLeftRightCrouched;               // 0x0B34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedBackwardCrouched;                       // 0x0B38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedLeftRightCrouched;                      // 0x0B3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedForwardReady;                           // 0x0B40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedForwardLeftRightReady;                  // 0x0B44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedBackwardReady;                          // 0x0B48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedLeftRightReady;                         // 0x0B4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedForwardCrouchedReady;                   // 0x0B50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedForwardLeftRightCrouchedReady;          // 0x0B54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedBackwardCrouchedReady;                  // 0x0B58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedLeftRightCrouchedReady;                 // 0x0B5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedForwardEngaged;                         // 0x0B60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedForwardLeftRightEngaged;                // 0x0B64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedBackwardEngaged;                        // 0x0B68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedLeftRightEngaged;                       // 0x0B6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedForwardCrouchedEngaged;                 // 0x0B70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedForwardLeftRightCrouchedEngaged;        // 0x0B74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedBackwardCrouchedEngaged;                // 0x0B78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedLeftRightCrouchedEngaged;               // 0x0B7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSprintSpeed;                                    // 0x0B80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSprintSpeedCrouched;                            // 0x0B84(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedProne;                                 // 0x0B88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeedProne;                                  // 0x0B8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProneDistanceRear;                              // 0x0B90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProneDistanceFront;                             // 0x0B94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B98[0x4];                                      // 0x0B98(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SideCheckOffset;                                   // 0x0B9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RearLateralCheckOffset;                            // 0x0BA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontLateralCheckOffset;                           // 0x0BA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLadderClimbSpeed;                               // 0x0BA8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLadderSlideSpeed;                               // 0x0BAC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LadderJumpOffSpeed;                                // 0x0BB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LadderJumpOffZSpeed;                               // 0x0BB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LadderRotationRate;                                // 0x0BB8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProneHalfHeight;                                   // 0x0BBC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWantsToProne : 1;                                 // 0x0BC0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWantsToRun : 1;                                   // 0x0BC0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWantsToSprint : 1;                                // 0x0BC0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_BC0_3 : 5;                                  // 0x0BC0(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_BC1[0x7];                                      // 0x0BC1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCanClimbLadders : 1;                              // 0x0BC8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_BC9[0x3];                                      // 0x0BC9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HopZVelocity;                                      // 0x0BCC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWantsToMantle : 1;                                // 0x0BD0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_BD1[0x7];                                      // 0x0BD1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBCharacter*                           GBCharacterOwner;                                  // 0x0BD8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BE0[0xC];                                      // 0x0BE0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LadderTopExitOffset;                               // 0x0BEC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MantleCheckDistance;                               // 0x0BF0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MantleMaxHeight;                                   // 0x0BF4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MantleClimbSpeed;                                  // 0x0BF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BFC[0x2C];                                     // 0x0BFC(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveCurviest*                         WaterDepthScalingCurve;                            // 0x0C28(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float FallingDamageReduction(float FallingDamage, const struct FHitResult& Hit);

	float GetEngagedAlpha() const;
	bool GetFirearmEquipped() const;
	class UGBLadderComponent* GetLadderComponent() const;
	float GetMaxRunningSpeed() const;
	float GetMaxSprintingSpeed() const;
	float GetMaxWalkingSpeed() const;
	float GetMovementDirection() const;
	float GetOffTargetAlpha() const;
	float GetWaterDepth() const;
	float GetWaterDepthJumpScale() const;
	float GetWaterDepthMaxSpeedScale() const;
	bool IsProne() const;
	bool WantsToLean() const;
	bool WantsToRun() const;
	bool WantsToSprint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBCharacterMovement">();
	}
	static class UGBCharacterMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBCharacterMovement>();
	}
};
static_assert(alignof(UGBCharacterMovement) == 0x000010, "Wrong alignment on UGBCharacterMovement");
static_assert(sizeof(UGBCharacterMovement) == 0x000C30, "Wrong size on UGBCharacterMovement");
static_assert(offsetof(UGBCharacterMovement, MaxWalkSpeedForward) == 0x000B00, "Member 'UGBCharacterMovement::MaxWalkSpeedForward' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxWalkSpeedForwardLeftRight) == 0x000B04, "Member 'UGBCharacterMovement::MaxWalkSpeedForwardLeftRight' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxWalkSpeedBackward) == 0x000B08, "Member 'UGBCharacterMovement::MaxWalkSpeedBackward' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxWalkSpeedLeftRight) == 0x000B0C, "Member 'UGBCharacterMovement::MaxWalkSpeedLeftRight' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedForward) == 0x000B10, "Member 'UGBCharacterMovement::MaxRunSpeedForward' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxWalkSpeedForwardCrouched) == 0x000B14, "Member 'UGBCharacterMovement::MaxWalkSpeedForwardCrouched' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxWalkSpeedForwardLeftRightCrouched) == 0x000B18, "Member 'UGBCharacterMovement::MaxWalkSpeedForwardLeftRightCrouched' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxWalkSpeedBackwardCrouched) == 0x000B1C, "Member 'UGBCharacterMovement::MaxWalkSpeedBackwardCrouched' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxWalkSpeedLeftRightCrouched) == 0x000B20, "Member 'UGBCharacterMovement::MaxWalkSpeedLeftRightCrouched' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedForwardLeftRight) == 0x000B24, "Member 'UGBCharacterMovement::MaxRunSpeedForwardLeftRight' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedBackward) == 0x000B28, "Member 'UGBCharacterMovement::MaxRunSpeedBackward' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedLeftRight) == 0x000B2C, "Member 'UGBCharacterMovement::MaxRunSpeedLeftRight' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedForwardCrouched) == 0x000B30, "Member 'UGBCharacterMovement::MaxRunSpeedForwardCrouched' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedForwardLeftRightCrouched) == 0x000B34, "Member 'UGBCharacterMovement::MaxRunSpeedForwardLeftRightCrouched' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedBackwardCrouched) == 0x000B38, "Member 'UGBCharacterMovement::MaxRunSpeedBackwardCrouched' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedLeftRightCrouched) == 0x000B3C, "Member 'UGBCharacterMovement::MaxRunSpeedLeftRightCrouched' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedForwardReady) == 0x000B40, "Member 'UGBCharacterMovement::MaxRunSpeedForwardReady' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedForwardLeftRightReady) == 0x000B44, "Member 'UGBCharacterMovement::MaxRunSpeedForwardLeftRightReady' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedBackwardReady) == 0x000B48, "Member 'UGBCharacterMovement::MaxRunSpeedBackwardReady' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedLeftRightReady) == 0x000B4C, "Member 'UGBCharacterMovement::MaxRunSpeedLeftRightReady' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedForwardCrouchedReady) == 0x000B50, "Member 'UGBCharacterMovement::MaxRunSpeedForwardCrouchedReady' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedForwardLeftRightCrouchedReady) == 0x000B54, "Member 'UGBCharacterMovement::MaxRunSpeedForwardLeftRightCrouchedReady' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedBackwardCrouchedReady) == 0x000B58, "Member 'UGBCharacterMovement::MaxRunSpeedBackwardCrouchedReady' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedLeftRightCrouchedReady) == 0x000B5C, "Member 'UGBCharacterMovement::MaxRunSpeedLeftRightCrouchedReady' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedForwardEngaged) == 0x000B60, "Member 'UGBCharacterMovement::MaxRunSpeedForwardEngaged' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedForwardLeftRightEngaged) == 0x000B64, "Member 'UGBCharacterMovement::MaxRunSpeedForwardLeftRightEngaged' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedBackwardEngaged) == 0x000B68, "Member 'UGBCharacterMovement::MaxRunSpeedBackwardEngaged' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedLeftRightEngaged) == 0x000B6C, "Member 'UGBCharacterMovement::MaxRunSpeedLeftRightEngaged' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedForwardCrouchedEngaged) == 0x000B70, "Member 'UGBCharacterMovement::MaxRunSpeedForwardCrouchedEngaged' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedForwardLeftRightCrouchedEngaged) == 0x000B74, "Member 'UGBCharacterMovement::MaxRunSpeedForwardLeftRightCrouchedEngaged' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedBackwardCrouchedEngaged) == 0x000B78, "Member 'UGBCharacterMovement::MaxRunSpeedBackwardCrouchedEngaged' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedLeftRightCrouchedEngaged) == 0x000B7C, "Member 'UGBCharacterMovement::MaxRunSpeedLeftRightCrouchedEngaged' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxSprintSpeed) == 0x000B80, "Member 'UGBCharacterMovement::MaxSprintSpeed' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxSprintSpeedCrouched) == 0x000B84, "Member 'UGBCharacterMovement::MaxSprintSpeedCrouched' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxWalkSpeedProne) == 0x000B88, "Member 'UGBCharacterMovement::MaxWalkSpeedProne' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxRunSpeedProne) == 0x000B8C, "Member 'UGBCharacterMovement::MaxRunSpeedProne' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MinProneDistanceRear) == 0x000B90, "Member 'UGBCharacterMovement::MinProneDistanceRear' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MinProneDistanceFront) == 0x000B94, "Member 'UGBCharacterMovement::MinProneDistanceFront' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, SideCheckOffset) == 0x000B9C, "Member 'UGBCharacterMovement::SideCheckOffset' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, RearLateralCheckOffset) == 0x000BA0, "Member 'UGBCharacterMovement::RearLateralCheckOffset' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, FrontLateralCheckOffset) == 0x000BA4, "Member 'UGBCharacterMovement::FrontLateralCheckOffset' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxLadderClimbSpeed) == 0x000BA8, "Member 'UGBCharacterMovement::MaxLadderClimbSpeed' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MaxLadderSlideSpeed) == 0x000BAC, "Member 'UGBCharacterMovement::MaxLadderSlideSpeed' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, LadderJumpOffSpeed) == 0x000BB0, "Member 'UGBCharacterMovement::LadderJumpOffSpeed' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, LadderJumpOffZSpeed) == 0x000BB4, "Member 'UGBCharacterMovement::LadderJumpOffZSpeed' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, LadderRotationRate) == 0x000BB8, "Member 'UGBCharacterMovement::LadderRotationRate' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, ProneHalfHeight) == 0x000BBC, "Member 'UGBCharacterMovement::ProneHalfHeight' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, HopZVelocity) == 0x000BCC, "Member 'UGBCharacterMovement::HopZVelocity' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, GBCharacterOwner) == 0x000BD8, "Member 'UGBCharacterMovement::GBCharacterOwner' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, LadderTopExitOffset) == 0x000BEC, "Member 'UGBCharacterMovement::LadderTopExitOffset' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MantleCheckDistance) == 0x000BF0, "Member 'UGBCharacterMovement::MantleCheckDistance' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MantleMaxHeight) == 0x000BF4, "Member 'UGBCharacterMovement::MantleMaxHeight' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, MantleClimbSpeed) == 0x000BF8, "Member 'UGBCharacterMovement::MantleClimbSpeed' has a wrong offset!");
static_assert(offsetof(UGBCharacterMovement, WaterDepthScalingCurve) == 0x000C28, "Member 'UGBCharacterMovement::WaterDepthScalingCurve' has a wrong offset!");

// Class GroundBranch.GBAIController
// 0x01D0 (0x04F8 - 0x0328)
class AGBAIController final : public AAIController
{
public:
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0328(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTreeComponent*                 BehaviorComp;                                      // 0x0330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         IgnoreIncomingFireRangeSquared;                    // 0x0338(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C[0x14];                                     // 0x033C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBCharacter*                           GBCharacter;                                       // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x18];                                     // 0x0358(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkipBulletWarnOccculusionTime;                     // 0x0370(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_374[0x14];                                     // 0x0374(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeadShotAimErrorMuliplier;                         // 0x0388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilCompensationSkill;                           // 0x038C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReactionTimeBase;                                  // 0x0390(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReactionTimeRandom;                                // 0x0394(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxSemiAutoBurst;                                  // 0x0398(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinFullAutoBurst;                                  // 0x039C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxFullAutoBurst;                                  // 0x03A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDelayBetweenBursts;                             // 0x03A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDelayBetweenBursts;                             // 0x03A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeanChance;                                        // 0x03AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x10];                                     // 0x03B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           AimErrorAngleDifferenceEngagedCurve;               // 0x03C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           AimErrorAngleDifferenceCurve;                      // 0x03C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           AimErrorDistanceEngagedCurve;                      // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           AimErrorDistanceCurve;                             // 0x03D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           AimErrorTargetVelocityEngagedCurve;                // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           AimErrorTargetVelocityCurve;                       // 0x03E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F0[0x30];                                     // 0x03F0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ThreatRatingDistanceCurve;                         // 0x0420(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanSuppressEnemy;                                 // 0x0428(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_429[0x67];                                     // 0x0429(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ViewPitchMin;                                      // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewPitchMax;                                      // 0x0494(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAIBark>                        ReceivedBarks;                                     // 0x0498(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FAIBark                                LastBark;                                          // 0x04A8(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AGBAISquad*                             Squad;                                             // 0x04B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x14];                                     // 0x04C0(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleHearingThreshold;                              // 0x04D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AlertHearingThreshold;                             // 0x04D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IdleAffiliationSightThreshold;                     // 0x04DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AlertAffiliationSightThreshold;                    // 0x04E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IdleSuspicionSightThreshold;                       // 0x04E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AlertSuspicionSightThreshold;                      // 0x04E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EC[0xC];                                      // 0x04EC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Bark(class FName Key, int32 Priority, float Timeout, bool bIsRadioMessage);
	void BulletWarn(class AActor* Bullet, bool bSubSonic);
	void ClearDesiredAimRotationOverride();
	void ClearDesiredViewRotationOffset();
	void ClearSquad();
	void ClearUsableActor();
	void DebugFreeze(bool bShouldFreeze);
	void Freeze(float FreezeTime);
	float FrozenTimeLeft();
	bool GetCurrentPathCorridorIndex(int32* CorridorIndex);
	class AGBCharacter* GetGBCharacter();
	bool GetNavLinkPoints(int32 CorridorIndex, struct FVector* LinkStart, struct FVector* LinkEnd);
	bool IsFrozen();
	bool NeedsReload();
	void NotifyBump(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void NotifyTakeHit(class AController* InstigatedBy, int32 Damage, const struct FVector& Momentum, const struct FDamageEvent& DamageEvent);
	void NotifyWalkingOffLedge();
	void OnLoadoutApplied();
	void OnNoLongerSensingEnemyEvent();
	void OnSensingEnemyDeathEvent();
	void OnSensingNewEnemyEvent(bool bHasLineOfSight);
	void OnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus);
	void Reload();
	void SetAIState(EGBAIState NewState);
	void SetAlertAffiliationSightThreshold(const float NewAlertAffiliationSightThreshold);
	void SetAlertHearingThreshold(const float NewAlertHearingThreshold);
	void SetAlertSuspicionSightThreshold(const float NewAlertSuspicionSightThreshold);
	void SetDesiredAimRotationOverride(const struct FRotator& NewRotation, float NewRate);
	void SetDesiredViewRotationOffset(const struct FRotator& NewRotation);
	void SetEnemy(class AGBCharacter* NewEnemy);
	void SetEnemyDistance(float NewValue);
	void SetEnemyLastHeard(float NewValue);
	void SetEnemyLastKnownDirection(const struct FVector& NewValue);
	void SetEnemyLastKnownLocation(const struct FVector& NewValue);
	void SetEnemyLastSeen(float NewValue);
	void SetEnemyLastStimulusTime(float NewValue);
	void SetEnemyLOS(bool bNewValue);
	void SetEnemyPartSeen(class FName NewEnemyPartSeen);
	void SetIdleAffiliationSightThreshold(const float NewIdleAffiliationSightThreshold);
	void SetIdleHearingThreshold(const float NewIdleHearingThreshold);
	void SetIdleSuspicionSightThreshold(const float NewIdleSuspicionSightThreshold);
	void SetSearchTime(float NewValue);
	void SetSquad(class AGBAISquad* NewSquad);
	void SetUsableActor(class AActor* NewUsableActor);
	void SetUsableActorNavDir(const struct FVector& NewValue);
	void SetUsableActorNavEnd(const struct FVector& NewValue);
	void SetUsableActorNavStart(const struct FVector& NewValue);
	void SetUsableActorState(EGBAIUsableActorState NewValue);
	void SetUsableActorType(class FName NewUsableActorType);
	void SetUsableActorUseEnd(const struct FVector& NewValue);
	void SetUsableActorUseStart(const struct FVector& NewValue);
	void SetUsableActorUseWaitLocation(const struct FVector& NewValue);
	void SetViewRotation(const struct FRotator& NewRotation);
	void ShowDebugInfoEvent();
	void StartFiring();
	void StopFiring();
	void UnFreeze();
	void UpdateEquippedType();

	EGBAIState GetAIState() const;
	class UBehaviorTreeComponent* GetBehaviorComp() const;
	bool GetCanSuppressEnemy() const;
	class AGBCharacter* GetEnemy() const;
	float GetEnemyDistance() const;
	float GetEnemyLastHeard() const;
	struct FVector GetEnemyLastKnownDirection() const;
	struct FVector GetEnemyLastKnownLocation() const;
	float GetEnemyLastSeen() const;
	float GetEnemyLastStimulusTime() const;
	bool GetEnemyLOS() const;
	class FName GetEnemyPartSeen() const;
	struct FAIBark GetLastBark() const;
	float GetMaxDelayBetweenBursts() const;
	int32 GetMaxFullAutoBurst() const;
	int32 GetMaxSemiAutoBurst() const;
	float GetMinDelayBetweenBursts() const;
	int32 GetMinFullAutoBurst() const;
	struct FVector GetNextPathCorridorPoint() const;
	struct FVector GetNextPathLocation() const;
	bool GetOnTarget() const;
	TArray<struct FVector> GetPathCorridorPoints() const;
	float GetReactionTimeBase() const;
	float GetReactionTimeRandom() const;
	float GetSearchTime() const;
	class AGBAISquad* GetSquad() const;
	class AActor* GetUsableActor() const;
	struct FVector GetUsableActorNavDir() const;
	struct FVector GetUsableActorNavEnd() const;
	struct FVector GetUsableActorNavStart() const;
	EGBAIUsableActorState GetUsableActorState() const;
	class FName GetUsableActorType() const;
	struct FVector GetUsableActorUseEnd() const;
	struct FVector GetUsableActorUseStart() const;
	struct FVector GetUsableActorUseWaitLocation() const;
	struct FRotator GetViewRotation() const;
	struct FRotator GetViewRotationOffset() const;
	bool IsAlive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAIController">();
	}
	static class AGBAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBAIController>();
	}
};
static_assert(alignof(AGBAIController) == 0x000008, "Wrong alignment on AGBAIController");
static_assert(sizeof(AGBAIController) == 0x0004F8, "Wrong size on AGBAIController");
static_assert(offsetof(AGBAIController, BehaviorTree) == 0x000328, "Member 'AGBAIController::BehaviorTree' has a wrong offset!");
static_assert(offsetof(AGBAIController, BehaviorComp) == 0x000330, "Member 'AGBAIController::BehaviorComp' has a wrong offset!");
static_assert(offsetof(AGBAIController, IgnoreIncomingFireRangeSquared) == 0x000338, "Member 'AGBAIController::IgnoreIncomingFireRangeSquared' has a wrong offset!");
static_assert(offsetof(AGBAIController, GBCharacter) == 0x000350, "Member 'AGBAIController::GBCharacter' has a wrong offset!");
static_assert(offsetof(AGBAIController, SkipBulletWarnOccculusionTime) == 0x000370, "Member 'AGBAIController::SkipBulletWarnOccculusionTime' has a wrong offset!");
static_assert(offsetof(AGBAIController, HeadShotAimErrorMuliplier) == 0x000388, "Member 'AGBAIController::HeadShotAimErrorMuliplier' has a wrong offset!");
static_assert(offsetof(AGBAIController, RecoilCompensationSkill) == 0x00038C, "Member 'AGBAIController::RecoilCompensationSkill' has a wrong offset!");
static_assert(offsetof(AGBAIController, ReactionTimeBase) == 0x000390, "Member 'AGBAIController::ReactionTimeBase' has a wrong offset!");
static_assert(offsetof(AGBAIController, ReactionTimeRandom) == 0x000394, "Member 'AGBAIController::ReactionTimeRandom' has a wrong offset!");
static_assert(offsetof(AGBAIController, MaxSemiAutoBurst) == 0x000398, "Member 'AGBAIController::MaxSemiAutoBurst' has a wrong offset!");
static_assert(offsetof(AGBAIController, MinFullAutoBurst) == 0x00039C, "Member 'AGBAIController::MinFullAutoBurst' has a wrong offset!");
static_assert(offsetof(AGBAIController, MaxFullAutoBurst) == 0x0003A0, "Member 'AGBAIController::MaxFullAutoBurst' has a wrong offset!");
static_assert(offsetof(AGBAIController, MinDelayBetweenBursts) == 0x0003A4, "Member 'AGBAIController::MinDelayBetweenBursts' has a wrong offset!");
static_assert(offsetof(AGBAIController, MaxDelayBetweenBursts) == 0x0003A8, "Member 'AGBAIController::MaxDelayBetweenBursts' has a wrong offset!");
static_assert(offsetof(AGBAIController, LeanChance) == 0x0003AC, "Member 'AGBAIController::LeanChance' has a wrong offset!");
static_assert(offsetof(AGBAIController, AimErrorAngleDifferenceEngagedCurve) == 0x0003C0, "Member 'AGBAIController::AimErrorAngleDifferenceEngagedCurve' has a wrong offset!");
static_assert(offsetof(AGBAIController, AimErrorAngleDifferenceCurve) == 0x0003C8, "Member 'AGBAIController::AimErrorAngleDifferenceCurve' has a wrong offset!");
static_assert(offsetof(AGBAIController, AimErrorDistanceEngagedCurve) == 0x0003D0, "Member 'AGBAIController::AimErrorDistanceEngagedCurve' has a wrong offset!");
static_assert(offsetof(AGBAIController, AimErrorDistanceCurve) == 0x0003D8, "Member 'AGBAIController::AimErrorDistanceCurve' has a wrong offset!");
static_assert(offsetof(AGBAIController, AimErrorTargetVelocityEngagedCurve) == 0x0003E0, "Member 'AGBAIController::AimErrorTargetVelocityEngagedCurve' has a wrong offset!");
static_assert(offsetof(AGBAIController, AimErrorTargetVelocityCurve) == 0x0003E8, "Member 'AGBAIController::AimErrorTargetVelocityCurve' has a wrong offset!");
static_assert(offsetof(AGBAIController, ThreatRatingDistanceCurve) == 0x000420, "Member 'AGBAIController::ThreatRatingDistanceCurve' has a wrong offset!");
static_assert(offsetof(AGBAIController, bCanSuppressEnemy) == 0x000428, "Member 'AGBAIController::bCanSuppressEnemy' has a wrong offset!");
static_assert(offsetof(AGBAIController, ViewPitchMin) == 0x000490, "Member 'AGBAIController::ViewPitchMin' has a wrong offset!");
static_assert(offsetof(AGBAIController, ViewPitchMax) == 0x000494, "Member 'AGBAIController::ViewPitchMax' has a wrong offset!");
static_assert(offsetof(AGBAIController, ReceivedBarks) == 0x000498, "Member 'AGBAIController::ReceivedBarks' has a wrong offset!");
static_assert(offsetof(AGBAIController, LastBark) == 0x0004A8, "Member 'AGBAIController::LastBark' has a wrong offset!");
static_assert(offsetof(AGBAIController, Squad) == 0x0004B8, "Member 'AGBAIController::Squad' has a wrong offset!");
static_assert(offsetof(AGBAIController, IdleHearingThreshold) == 0x0004D4, "Member 'AGBAIController::IdleHearingThreshold' has a wrong offset!");
static_assert(offsetof(AGBAIController, AlertHearingThreshold) == 0x0004D8, "Member 'AGBAIController::AlertHearingThreshold' has a wrong offset!");
static_assert(offsetof(AGBAIController, IdleAffiliationSightThreshold) == 0x0004DC, "Member 'AGBAIController::IdleAffiliationSightThreshold' has a wrong offset!");
static_assert(offsetof(AGBAIController, AlertAffiliationSightThreshold) == 0x0004E0, "Member 'AGBAIController::AlertAffiliationSightThreshold' has a wrong offset!");
static_assert(offsetof(AGBAIController, IdleSuspicionSightThreshold) == 0x0004E4, "Member 'AGBAIController::IdleSuspicionSightThreshold' has a wrong offset!");
static_assert(offsetof(AGBAIController, AlertSuspicionSightThreshold) == 0x0004E8, "Member 'AGBAIController::AlertSuspicionSightThreshold' has a wrong offset!");

// Class GroundBranch.GBCharacterProneIK
// 0x0010 (0x02D0 - 0x02C0)
class UGBCharacterProneIK final : public UAnimInstance
{
public:
	class AGBCharacter*                           GBCharacterOwner;                                  // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoProneIK;                                        // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0xF];                                      // 0x02C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBCharacterProneIK">();
	}
	static class UGBCharacterProneIK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBCharacterProneIK>();
	}
};
static_assert(alignof(UGBCharacterProneIK) == 0x000010, "Wrong alignment on UGBCharacterProneIK");
static_assert(sizeof(UGBCharacterProneIK) == 0x0002D0, "Wrong size on UGBCharacterProneIK");
static_assert(offsetof(UGBCharacterProneIK, GBCharacterOwner) == 0x0002B8, "Member 'UGBCharacterProneIK::GBCharacterOwner' has a wrong offset!");
static_assert(offsetof(UGBCharacterProneIK, bDoProneIK) == 0x0002C0, "Member 'UGBCharacterProneIK::bDoProneIK' has a wrong offset!");

// Class GroundBranch.GBAICoordinatorSubsystem
// 0x0010 (0x0040 - 0x0030)
class UGBAICoordinatorSubsystem final : public UWorldSubsystem
{
public:
	TArray<struct FAITargetData>                  EngagedEnemies;                                    // 0x0030(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void AddTargetingData(class AActor* Target, class AGBKytController* TargetingAI);
	void DisableFleeState();
	int32 GetCountForTarget(class AActor* Target);
	void RemoveTargetingData(class AGBKytController* TargetingAI);
	void TriggerFleeState(const struct FVector& FleeFromLoc);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAICoordinatorSubsystem">();
	}
	static class UGBAICoordinatorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAICoordinatorSubsystem>();
	}
};
static_assert(alignof(UGBAICoordinatorSubsystem) == 0x000008, "Wrong alignment on UGBAICoordinatorSubsystem");
static_assert(sizeof(UGBAICoordinatorSubsystem) == 0x000040, "Wrong size on UGBAICoordinatorSubsystem");
static_assert(offsetof(UGBAICoordinatorSubsystem, EngagedEnemies) == 0x000030, "Member 'UGBAICoordinatorSubsystem::EngagedEnemies' has a wrong offset!");

// Class GroundBranch.GBCharAnimInstance
// 0x09D0 (0x0C90 - 0x02C0)
class UGBCharAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGBCharAnimInstanceProxy               Proxy;                                             // 0x02C0(0x0960)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPrivate)
	float                                         AnimDirectionDeadZone;                             // 0x0C20(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              RootYawOffsetAngleClampStanding;                   // 0x0C24(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              RootYawOffsetAngleClampCrouching;                  // 0x0C2C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              RootYawOffsetAngleClampProne;                      // 0x0C34(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C3C[0x35];                                     // 0x0C3C(0x0035)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUpdateFirearmData;                                // 0x0C71(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C72[0x2];                                      // 0x0C72(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationalInertiaExpConstant;                      // 0x0C74(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationalInertiaRecoverySpeed;                    // 0x0C78(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               MaxEquippedRotationalInertiaOffset;                // 0x0C7C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         RotationalInertiaYawToRollScalar;                  // 0x0C88(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8C[0x4];                                      // 0x0C8C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDynamicLeftHandIKRoot(class FName BoneName);
	void SetDynamicLeftHandIKRootLocOffset(const struct FVector& LocOffset);
	void SetDynamicLeftHandIKRootRotOffset(const struct FRotator& RotOffset);
	void SetDynamicRightHandIKRoot(class FName BoneName);
	void SetDynamicRightItemRoot(class FName BoneName);
	void SetRecoilBlendAlpha(float NewRecoilBlendAlpha);
	void SetTurningInPlace(bool bValue);

	class FName GetDynamicLeftHandIKRoot() const;
	class FName GetDynamicRightHandIKRoot() const;
	class UAnimMontage* GetMontageFromLinkedLayer(TSubclassOf<class UAnimInstance> InCurrentAnimLayerClass, class FName InMontageName) const;
	bool GetTurningInPlace() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBCharAnimInstance">();
	}
	static class UGBCharAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBCharAnimInstance>();
	}
};
static_assert(alignof(UGBCharAnimInstance) == 0x000010, "Wrong alignment on UGBCharAnimInstance");
static_assert(sizeof(UGBCharAnimInstance) == 0x000C90, "Wrong size on UGBCharAnimInstance");
static_assert(offsetof(UGBCharAnimInstance, Proxy) == 0x0002C0, "Member 'UGBCharAnimInstance::Proxy' has a wrong offset!");
static_assert(offsetof(UGBCharAnimInstance, AnimDirectionDeadZone) == 0x000C20, "Member 'UGBCharAnimInstance::AnimDirectionDeadZone' has a wrong offset!");
static_assert(offsetof(UGBCharAnimInstance, RootYawOffsetAngleClampStanding) == 0x000C24, "Member 'UGBCharAnimInstance::RootYawOffsetAngleClampStanding' has a wrong offset!");
static_assert(offsetof(UGBCharAnimInstance, RootYawOffsetAngleClampCrouching) == 0x000C2C, "Member 'UGBCharAnimInstance::RootYawOffsetAngleClampCrouching' has a wrong offset!");
static_assert(offsetof(UGBCharAnimInstance, RootYawOffsetAngleClampProne) == 0x000C34, "Member 'UGBCharAnimInstance::RootYawOffsetAngleClampProne' has a wrong offset!");
static_assert(offsetof(UGBCharAnimInstance, bUpdateFirearmData) == 0x000C71, "Member 'UGBCharAnimInstance::bUpdateFirearmData' has a wrong offset!");
static_assert(offsetof(UGBCharAnimInstance, RotationalInertiaExpConstant) == 0x000C74, "Member 'UGBCharAnimInstance::RotationalInertiaExpConstant' has a wrong offset!");
static_assert(offsetof(UGBCharAnimInstance, RotationalInertiaRecoverySpeed) == 0x000C78, "Member 'UGBCharAnimInstance::RotationalInertiaRecoverySpeed' has a wrong offset!");
static_assert(offsetof(UGBCharAnimInstance, MaxEquippedRotationalInertiaOffset) == 0x000C7C, "Member 'UGBCharAnimInstance::MaxEquippedRotationalInertiaOffset' has a wrong offset!");
static_assert(offsetof(UGBCharAnimInstance, RotationalInertiaYawToRollScalar) == 0x000C88, "Member 'UGBCharAnimInstance::RotationalInertiaYawToRollScalar' has a wrong offset!");

// Class GroundBranch.GBAIDirector
// 0x0000 (0x0220 - 0x0220)
class AGBAIDirector final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAIDirector">();
	}
	static class AGBAIDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBAIDirector>();
	}
};
static_assert(alignof(AGBAIDirector) == 0x000008, "Wrong alignment on AGBAIDirector");
static_assert(sizeof(AGBAIDirector) == 0x000220, "Wrong size on AGBAIDirector");

// Class GroundBranch.GBAIExtensionComponent
// 0x0010 (0x00C0 - 0x00B0)
class UGBAIExtensionComponent final : public UActorComponent
{
public:
	FMulticastSparseDelegateProperty_             OnAIInitialized;                                   // 0x00B0(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0xF];                                       // 0x00B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGBAIExtensionComponent* FindPawnExtensionComponent(const class AActor* Actor);

	void InitAI(const class FName AIControllerTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAIExtensionComponent">();
	}
	static class UGBAIExtensionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAIExtensionComponent>();
	}
};
static_assert(alignof(UGBAIExtensionComponent) == 0x000008, "Wrong alignment on UGBAIExtensionComponent");
static_assert(sizeof(UGBAIExtensionComponent) == 0x0000C0, "Wrong size on UGBAIExtensionComponent");
static_assert(offsetof(UGBAIExtensionComponent, OnAIInitialized) == 0x0000B0, "Member 'UGBAIExtensionComponent::OnAIInitialized' has a wrong offset!");

// Class GroundBranch.GBAIFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGBAIFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ForgetAll(class UAIPerceptionComponent* PerceptionComponent);
	static void GetAIControllersOfClass(class UObject* WorldContextObject, TSubclassOf<class AAIController> AIControllerClass, TArray<class AAIController*>* OutAIControllers);
	static struct FVector GetBlackboardValueAsDirection(class UBTNode* NodeOwner, const struct FBlackboardKeySelector& Key, bool bAs2d);
	static struct FVector GetBlackboardValueAsLocation(class UBTNode* NodeOwner, const struct FBlackboardKeySelector& Key);
	static class AGBCharacter* SpawnDefaultKytAI(class UObject* WorldContextObject, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, class UClass* Class_0, TSoftClassPtr<class UClass> ControllerOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAIFunctionLibrary">();
	}
	static class UGBAIFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAIFunctionLibrary>();
	}
};
static_assert(alignof(UGBAIFunctionLibrary) == 0x000008, "Wrong alignment on UGBAIFunctionLibrary");
static_assert(sizeof(UGBAIFunctionLibrary) == 0x000028, "Wrong size on UGBAIFunctionLibrary");

// Class GroundBranch.GBAIGuardPoint
// 0x0060 (0x02A8 - 0x0248)
class AGBAIGuardPoint final : public ANavigationObjectBase
{
public:
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBillboardComponent*                    SpriteComponent;                                   // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       SphereComponent;                                   // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   GroupName;                                         // 0x0268(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGBGuardPointType                             GuardPointType;                                    // 0x0270(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementRadius;                                    // 0x0274(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SweepAngle;                                        // 0x0278(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchBias;                                         // 0x027C(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScanDuration;                                      // 0x0280(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Deviation;                                         // 0x0284(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoldTime;                                          // 0x0288(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoldDeviation;                                     // 0x028C(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnRate;                                          // 0x0290(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsActive;                                         // 0x0294(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_295[0x3];                                      // 0x0295(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           CustomDetailWidgets;                               // 0x0298(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void UpdateGuardPointRadiusSphere(const bool bHideSphere);

	struct FRotator GetBaseViewRoation() const;
	float GetDeviation() const;
	class FName GetGroupName() const;
	EGBGuardPointType GetGuardPointType() const;
	float GetHoldDeviation() const;
	float GetHoldTime() const;
	float GetMovementRadius() const;
	float GetScanDuration() const;
	float GetSweepAngle() const;
	float GetTurnRate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAIGuardPoint">();
	}
	static class AGBAIGuardPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBAIGuardPoint>();
	}
};
static_assert(alignof(AGBAIGuardPoint) == 0x000008, "Wrong alignment on AGBAIGuardPoint");
static_assert(sizeof(AGBAIGuardPoint) == 0x0002A8, "Wrong size on AGBAIGuardPoint");
static_assert(offsetof(AGBAIGuardPoint, SpriteComponent) == 0x000258, "Member 'AGBAIGuardPoint::SpriteComponent' has a wrong offset!");
static_assert(offsetof(AGBAIGuardPoint, SphereComponent) == 0x000260, "Member 'AGBAIGuardPoint::SphereComponent' has a wrong offset!");
static_assert(offsetof(AGBAIGuardPoint, GroupName) == 0x000268, "Member 'AGBAIGuardPoint::GroupName' has a wrong offset!");
static_assert(offsetof(AGBAIGuardPoint, GuardPointType) == 0x000270, "Member 'AGBAIGuardPoint::GuardPointType' has a wrong offset!");
static_assert(offsetof(AGBAIGuardPoint, MovementRadius) == 0x000274, "Member 'AGBAIGuardPoint::MovementRadius' has a wrong offset!");
static_assert(offsetof(AGBAIGuardPoint, SweepAngle) == 0x000278, "Member 'AGBAIGuardPoint::SweepAngle' has a wrong offset!");
static_assert(offsetof(AGBAIGuardPoint, PitchBias) == 0x00027C, "Member 'AGBAIGuardPoint::PitchBias' has a wrong offset!");
static_assert(offsetof(AGBAIGuardPoint, ScanDuration) == 0x000280, "Member 'AGBAIGuardPoint::ScanDuration' has a wrong offset!");
static_assert(offsetof(AGBAIGuardPoint, Deviation) == 0x000284, "Member 'AGBAIGuardPoint::Deviation' has a wrong offset!");
static_assert(offsetof(AGBAIGuardPoint, HoldTime) == 0x000288, "Member 'AGBAIGuardPoint::HoldTime' has a wrong offset!");
static_assert(offsetof(AGBAIGuardPoint, HoldDeviation) == 0x00028C, "Member 'AGBAIGuardPoint::HoldDeviation' has a wrong offset!");
static_assert(offsetof(AGBAIGuardPoint, TurnRate) == 0x000290, "Member 'AGBAIGuardPoint::TurnRate' has a wrong offset!");
static_assert(offsetof(AGBAIGuardPoint, bIsActive) == 0x000294, "Member 'AGBAIGuardPoint::bIsActive' has a wrong offset!");
static_assert(offsetof(AGBAIGuardPoint, CustomDetailWidgets) == 0x000298, "Member 'AGBAIGuardPoint::CustomDetailWidgets' has a wrong offset!");

// Class GroundBranch.GBMissionVolume
// 0x0028 (0x0248 - 0x0220)
class AGBMissionVolume : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          MissionVolume;                                     // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSelected;                                       // 0x0230(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 SelectedBoxColour;                                 // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UClass>>           CustomDetailWidgets;                               // 0x0238(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBMissionVolume">();
	}
	static class AGBMissionVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBMissionVolume>();
	}
};
static_assert(alignof(AGBMissionVolume) == 0x000008, "Wrong alignment on AGBMissionVolume");
static_assert(sizeof(AGBMissionVolume) == 0x000248, "Wrong size on AGBMissionVolume");
static_assert(offsetof(AGBMissionVolume, MissionVolume) == 0x000228, "Member 'AGBMissionVolume::MissionVolume' has a wrong offset!");
static_assert(offsetof(AGBMissionVolume, bIsSelected) == 0x000230, "Member 'AGBMissionVolume::bIsSelected' has a wrong offset!");
static_assert(offsetof(AGBMissionVolume, SelectedBoxColour) == 0x000234, "Member 'AGBMissionVolume::SelectedBoxColour' has a wrong offset!");
static_assert(offsetof(AGBMissionVolume, CustomDetailWidgets) == 0x000238, "Member 'AGBMissionVolume::CustomDetailWidgets' has a wrong offset!");

// Class GroundBranch.GBAIHotspot
// 0x0018 (0x0260 - 0x0248)
class AGBAIHotspot final : public AGBMissionVolume
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HotspotName;                                       // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsActive;                                         // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHotspotName(class FName NewHotspotName);

	class FName GetHotspotName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAIHotspot">();
	}
	static class AGBAIHotspot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBAIHotspot>();
	}
};
static_assert(alignof(AGBAIHotspot) == 0x000008, "Wrong alignment on AGBAIHotspot");
static_assert(sizeof(AGBAIHotspot) == 0x000260, "Wrong size on AGBAIHotspot");
static_assert(offsetof(AGBAIHotspot, HotspotName) == 0x000250, "Member 'AGBAIHotspot::HotspotName' has a wrong offset!");
static_assert(offsetof(AGBAIHotspot, bIsActive) == 0x000258, "Member 'AGBAIHotspot::bIsActive' has a wrong offset!");

// Class GroundBranch.GBAIObjectiveBase
// 0x0010 (0x0038 - 0x0028)
class UGBAIObjectiveBase final : public UObject
{
public:
	class FString                                 ObjectiveDescription;                              // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EvaluateObjective();

	class FString GetObjectiveDescription() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAIObjectiveBase">();
	}
	static class UGBAIObjectiveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAIObjectiveBase>();
	}
};
static_assert(alignof(UGBAIObjectiveBase) == 0x000008, "Wrong alignment on UGBAIObjectiveBase");
static_assert(sizeof(UGBAIObjectiveBase) == 0x000038, "Wrong size on UGBAIObjectiveBase");
static_assert(offsetof(UGBAIObjectiveBase, ObjectiveDescription) == 0x000028, "Member 'UGBAIObjectiveBase::ObjectiveDescription' has a wrong offset!");

// Class GroundBranch.GBAIObjectiveGeneratorBase
// 0x0000 (0x0028 - 0x0028)
class UGBAIObjectiveGeneratorBase final : public UObject
{
public:
	void GenerateObjectives(TArray<class UGBAIObjectiveBase*>* Objectives);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAIObjectiveGeneratorBase">();
	}
	static class UGBAIObjectiveGeneratorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAIObjectiveGeneratorBase>();
	}
};
static_assert(alignof(UGBAIObjectiveGeneratorBase) == 0x000008, "Wrong alignment on UGBAIObjectiveGeneratorBase");
static_assert(sizeof(UGBAIObjectiveGeneratorBase) == 0x000028, "Wrong size on UGBAIObjectiveGeneratorBase");

// Class GroundBranch.GBAIPatrolRoute
// 0x0050 (0x0298 - 0x0248)
class AGBAIPatrolRoute final : public ANavigationObjectBase
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBillboardComponent*                    SpriteComponent;                                   // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UClass>>           CustomDetailWidgets;                               // 0x0258(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class AGBAIPatrolRoute*>               LinkedPatrolRoutes;                                // 0x0268(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AGBAIPatrolRoute*>               RecentlyUsedPatrolRoutes;                          // 0x0278(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           NextRouteTags;                                     // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, SaveGame, NativeAccessSpecifierPublic)

public:
	void AddRecentlyUsedPatrolRoute(class AGBAIPatrolRoute* PatrolRoute);
	void GenerateLinkedPatrolRoutes();

	TArray<class AGBAIPatrolRoute*> GetLinkedPatrolRoutes() const;
	int32 GetNumberOfLinkedPatrolRoutes() const;
	const TArray<class AGBAIPatrolRoute*> GetRecentlyUsedPatrolRoutes() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAIPatrolRoute">();
	}
	static class AGBAIPatrolRoute* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBAIPatrolRoute>();
	}
};
static_assert(alignof(AGBAIPatrolRoute) == 0x000008, "Wrong alignment on AGBAIPatrolRoute");
static_assert(sizeof(AGBAIPatrolRoute) == 0x000298, "Wrong size on AGBAIPatrolRoute");
static_assert(offsetof(AGBAIPatrolRoute, SpriteComponent) == 0x000250, "Member 'AGBAIPatrolRoute::SpriteComponent' has a wrong offset!");
static_assert(offsetof(AGBAIPatrolRoute, CustomDetailWidgets) == 0x000258, "Member 'AGBAIPatrolRoute::CustomDetailWidgets' has a wrong offset!");
static_assert(offsetof(AGBAIPatrolRoute, LinkedPatrolRoutes) == 0x000268, "Member 'AGBAIPatrolRoute::LinkedPatrolRoutes' has a wrong offset!");
static_assert(offsetof(AGBAIPatrolRoute, RecentlyUsedPatrolRoutes) == 0x000278, "Member 'AGBAIPatrolRoute::RecentlyUsedPatrolRoutes' has a wrong offset!");
static_assert(offsetof(AGBAIPatrolRoute, NextRouteTags) == 0x000288, "Member 'AGBAIPatrolRoute::NextRouteTags' has a wrong offset!");

// Class GroundBranch.GBAISense_Hearing
// 0x0068 (0x00E8 - 0x0080)
class UGBAISense_Hearing final : public UAISense
{
public:
	TArray<struct FGBAINoiseEvent>                NoiseEvents;                                       // 0x0080(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         SpeedOfSoundSq;                                    // 0x0090(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94[0x54];                                      // 0x0094(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void RegisterNonAIListener(class AActor* RegisteredActor, TDelegate<void(const struct FVector& NoiseOrigin, float Loudness)> OnNonAIListenerAlert, float ThresholdSoundIntensity, float RetriggerDelay);
	static void ReportNoiseEvent(class UObject* WorldContextObject, const struct FVector& NoiseLocation, float Loudness, class AActor* Instigator, class FName Tag);
	static void ReportNoiseEventDistance(class UObject* WorldContextObject, const struct FVector& NoiseLocation, float AudioSignalRadius, class AActor* Instigator, class FName Tag);
	static void UnregisterNonAIListener(class AActor* RegisteredActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAISense_Hearing">();
	}
	static class UGBAISense_Hearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAISense_Hearing>();
	}
};
static_assert(alignof(UGBAISense_Hearing) == 0x000008, "Wrong alignment on UGBAISense_Hearing");
static_assert(sizeof(UGBAISense_Hearing) == 0x0000E8, "Wrong size on UGBAISense_Hearing");
static_assert(offsetof(UGBAISense_Hearing, NoiseEvents) == 0x000080, "Member 'UGBAISense_Hearing::NoiseEvents' has a wrong offset!");
static_assert(offsetof(UGBAISense_Hearing, SpeedOfSoundSq) == 0x000090, "Member 'UGBAISense_Hearing::SpeedOfSoundSq' has a wrong offset!");

// Class GroundBranch.GBAISense_Sight
// 0x00E8 (0x0168 - 0x0080)
class UGBAISense_Sight final : public UAISense
{
public:
	uint8                                         Pad_80[0xB0];                                      // 0x0080(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGBAISightEvent>                RegisteredEvents;                                  // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MaxTracesPerTick;                                  // 0x0140(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinQueriesPerTimeSliceCheck;                       // 0x0144(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MaxTimeSlicePerTick;                               // 0x0148(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HighImportanceQueryDistanceThreshold;              // 0x0150(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxQueryImportance;                                // 0x0158(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SightLimitQueryImportance;                         // 0x015C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ReportSightEvent(class AActor* Observer, class AActor* SeenActor, const struct FVector& EventLocation, class FName Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAISense_Sight">();
	}
	static class UGBAISense_Sight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAISense_Sight>();
	}
};
static_assert(alignof(UGBAISense_Sight) == 0x000008, "Wrong alignment on UGBAISense_Sight");
static_assert(sizeof(UGBAISense_Sight) == 0x000168, "Wrong size on UGBAISense_Sight");
static_assert(offsetof(UGBAISense_Sight, RegisteredEvents) == 0x000130, "Member 'UGBAISense_Sight::RegisteredEvents' has a wrong offset!");
static_assert(offsetof(UGBAISense_Sight, MaxTracesPerTick) == 0x000140, "Member 'UGBAISense_Sight::MaxTracesPerTick' has a wrong offset!");
static_assert(offsetof(UGBAISense_Sight, MinQueriesPerTimeSliceCheck) == 0x000144, "Member 'UGBAISense_Sight::MinQueriesPerTimeSliceCheck' has a wrong offset!");
static_assert(offsetof(UGBAISense_Sight, MaxTimeSlicePerTick) == 0x000148, "Member 'UGBAISense_Sight::MaxTimeSlicePerTick' has a wrong offset!");
static_assert(offsetof(UGBAISense_Sight, HighImportanceQueryDistanceThreshold) == 0x000150, "Member 'UGBAISense_Sight::HighImportanceQueryDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UGBAISense_Sight, MaxQueryImportance) == 0x000158, "Member 'UGBAISense_Sight::MaxQueryImportance' has a wrong offset!");
static_assert(offsetof(UGBAISense_Sight, SightLimitQueryImportance) == 0x00015C, "Member 'UGBAISense_Sight::SightLimitQueryImportance' has a wrong offset!");

// Class GroundBranch.GBAISenseConfig_Hearing
// 0x0060 (0x00A8 - 0x0048)
class UGBAISenseConfig_Hearing final : public UAISenseConfig
{
public:
	TSubclassOf<class UGBAISense_Hearing>         Implementation;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftObjectPtr<class UCurveFloat>> CurveMap;                                   // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAISenseConfig_Hearing">();
	}
	static class UGBAISenseConfig_Hearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAISenseConfig_Hearing>();
	}
};
static_assert(alignof(UGBAISenseConfig_Hearing) == 0x000008, "Wrong alignment on UGBAISenseConfig_Hearing");
static_assert(sizeof(UGBAISenseConfig_Hearing) == 0x0000A8, "Wrong size on UGBAISenseConfig_Hearing");
static_assert(offsetof(UGBAISenseConfig_Hearing, Implementation) == 0x000048, "Member 'UGBAISenseConfig_Hearing::Implementation' has a wrong offset!");
static_assert(offsetof(UGBAISenseConfig_Hearing, CurveMap) == 0x000050, "Member 'UGBAISenseConfig_Hearing::CurveMap' has a wrong offset!");
static_assert(offsetof(UGBAISenseConfig_Hearing, DetectionByAffiliation) == 0x0000A0, "Member 'UGBAISenseConfig_Hearing::DetectionByAffiliation' has a wrong offset!");

// Class GroundBranch.GBAISenseConfig_Sight
// 0x0038 (0x0080 - 0x0048)
class UGBAISenseConfig_Sight final : public UAISenseConfig
{
public:
	TSubclassOf<class UGBAISense_Sight>           Implementation;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SightValuesCurve;                                  // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SightValueName;                                    // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoseSightValueName;                                // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AutoSuccessRangeFromLastSeenLocation;              // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAISenseConfig_Sight">();
	}
	static class UGBAISenseConfig_Sight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAISenseConfig_Sight>();
	}
};
static_assert(alignof(UGBAISenseConfig_Sight) == 0x000008, "Wrong alignment on UGBAISenseConfig_Sight");
static_assert(sizeof(UGBAISenseConfig_Sight) == 0x000080, "Wrong size on UGBAISenseConfig_Sight");
static_assert(offsetof(UGBAISenseConfig_Sight, Implementation) == 0x000048, "Member 'UGBAISenseConfig_Sight::Implementation' has a wrong offset!");
static_assert(offsetof(UGBAISenseConfig_Sight, SightValuesCurve) == 0x000050, "Member 'UGBAISenseConfig_Sight::SightValuesCurve' has a wrong offset!");
static_assert(offsetof(UGBAISenseConfig_Sight, SightValueName) == 0x000068, "Member 'UGBAISenseConfig_Sight::SightValueName' has a wrong offset!");
static_assert(offsetof(UGBAISenseConfig_Sight, LoseSightValueName) == 0x000070, "Member 'UGBAISenseConfig_Sight::LoseSightValueName' has a wrong offset!");
static_assert(offsetof(UGBAISenseConfig_Sight, DetectionByAffiliation) == 0x000078, "Member 'UGBAISenseConfig_Sight::DetectionByAffiliation' has a wrong offset!");
static_assert(offsetof(UGBAISenseConfig_Sight, AutoSuccessRangeFromLastSeenLocation) == 0x00007C, "Member 'UGBAISenseConfig_Sight::AutoSuccessRangeFromLastSeenLocation' has a wrong offset!");

// Class GroundBranch.GBAISenseEvent_Hearing
// 0x0030 (0x0058 - 0x0028)
class UGBAISenseEvent_Hearing final : public UAISenseEvent
{
public:
	struct FGBAINoiseEvent                        Event;                                             // 0x0028(0x0030)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAISenseEvent_Hearing">();
	}
	static class UGBAISenseEvent_Hearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAISenseEvent_Hearing>();
	}
};
static_assert(alignof(UGBAISenseEvent_Hearing) == 0x000008, "Wrong alignment on UGBAISenseEvent_Hearing");
static_assert(sizeof(UGBAISenseEvent_Hearing) == 0x000058, "Wrong size on UGBAISenseEvent_Hearing");
static_assert(offsetof(UGBAISenseEvent_Hearing, Event) == 0x000028, "Member 'UGBAISenseEvent_Hearing::Event' has a wrong offset!");

// Class GroundBranch.GBAISettings
// 0x0078 (0x00A0 - 0x0028)
class UGBAISettings final : public UObject
{
public:
	uint8                                         Pad_28[0x78];                                      // 0x0028(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void FlushConfigAfterSavingAISettings();
	static struct FGBAISettingsInfo GetAISettingsForSkillLevel(int32 SkillLevel);
	static void SetAISettingsForSkillLevel(int32 InSkillLevel, class FName SettingName, const float InFloat, const class FString& inString, const bool bFlushAfterSaving);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAISettings">();
	}
	static class UGBAISettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAISettings>();
	}
};
static_assert(alignof(UGBAISettings) == 0x000008, "Wrong alignment on UGBAISettings");
static_assert(sizeof(UGBAISettings) == 0x0000A0, "Wrong size on UGBAISettings");

// Class GroundBranch.GBAISightTargetInterface
// 0x0000 (0x0000 - 0x0000)
class IGBAISightTargetInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAISightTargetInterface">();
	}
	static class IGBAISightTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGBAISightTargetInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGBAISightTargetInterface) == 0x000001, "Wrong alignment on IGBAISightTargetInterface");
static_assert(sizeof(IGBAISightTargetInterface) == 0x000001, "Wrong size on IGBAISightTargetInterface");

// Class GroundBranch.GBAISpawnManager
// 0x0040 (0x0260 - 0x0220)
class AGBAISpawnManager final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGBAISpawnPoint*>                CreateOverDurationSpawnPoints;                     // 0x0228(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x28];                                     // 0x0238(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CleanUpAI(class FName AIControllerTag);
	void CreateAIOverDuration(float Duration, int32 Count, const TArray<class AGBAISpawnPoint*>& OrderedSpawnPoints, class FName Tag);
	void CreateOverDurationTimer();
	TArray<class AGBKytController*> GetAIControllers(TSubclassOf<class AGBKytController> ControllerClass, class FName Tag, uint8 TeamId, uint8 SquadId);
	TArray<class AController*> GetGenericAIControllers(TSubclassOf<class AController> ControllerClass, class FName Tag, uint8 TeamId);
	void KillAI(class AGBKytController* AIController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAISpawnManager">();
	}
	static class AGBAISpawnManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBAISpawnManager>();
	}
};
static_assert(alignof(AGBAISpawnManager) == 0x000008, "Wrong alignment on AGBAISpawnManager");
static_assert(sizeof(AGBAISpawnManager) == 0x000260, "Wrong size on AGBAISpawnManager");
static_assert(offsetof(AGBAISpawnManager, CreateOverDurationSpawnPoints) == 0x000228, "Member 'AGBAISpawnManager::CreateOverDurationSpawnPoints' has a wrong offset!");

// Class GroundBranch.GBAISpawnPoint
// 0x0160 (0x03A8 - 0x0248)
class AGBAISpawnPoint final : public ANavigationObjectBase
{
public:
	uint8                                         Pad_248[0x18];                                     // 0x0248(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   AIControllerClass;                                 // 0x0260(0x0028)(Edit, SaveGame, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DefaultCharacterClass;                             // 0x0288(0x0028)(Edit, SaveGame, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   CharacterClass;                                    // 0x02B0(0x0028)(Edit, SaveGame, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x28];                                     // 0x02D8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LoadoutFileName;                                   // 0x0300(0x0010)(Edit, ZeroConstructor, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBKitInfo*                             LoadoutInfo;                                       // 0x0310(0x0008)(ZeroConstructor, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         TeamId;                                            // 0x0318(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         SquadId;                                           // 0x0319(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31A[0x2];                                      // 0x031A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SquadOrders;                                       // 0x031C(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDaySpawn;                                         // 0x0324(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNightSpawn;                                       // 0x0325(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_326[0x2];                                      // 0x0326(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GuardpointOverride;                                // 0x0328(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SupportingBed;                                     // 0x0330(0x0028)(Edit, SaveGame, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AIIdleAction;                                      // 0x0358(0x0010)(Edit, ZeroConstructor, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBillboardComponent*                    SpriteComponent;                                   // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AStaticMeshActor*                       SpawnedSupportingBed;                              // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsActive;                                         // 0x0378(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBCharacter*                           DisplayCharacter;                                  // 0x0380(0x0008)(ZeroConstructor, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           CustomDetailWidgets;                               // 0x0388(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class AGBAISquad*                             Squad;                                             // 0x0398(0x0008)(ZeroConstructor, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSelected;                                       // 0x03A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A1[0x7];                                      // 0x03A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyAITagsToCharacter(class AGBCharacter* NewCharacter);
	void CreateAI(class FName Tag);
	class AGBCharacter* CreateCharacter(const TSoftClassPtr<class UClass>& DesiredCharacterClass);
	void EnsureCharacterClassesLoaded();
	class AGBKitInfo* GetLoadoutInfo();
	void OnAIInitializedHandler(class AGBKytController* NewAIController);
	void OnInitialTimeOfDayChanged(class AGBSky* SkyActor);
	void SetLoadoutFileName(const class FString& NewLoadoutFileName);
	void SetSquadId(int32 NewSquadId);
	void SetSquadOrders(class FName NewSquadOrders);
	void UpdateShapeColour();

	TSoftClassPtr<class UClass> GetAIControllerClass() const;
	bool GetIsActiveAtCurrentTimeOfDay() const;
	bool GetIsDaySpawn() const;
	bool GetIsNightSpawn() const;
	class FString GetLoadoutFileName() const;
	int32 GetSquadId() const;
	class FName GetSquadOrders() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAISpawnPoint">();
	}
	static class AGBAISpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBAISpawnPoint>();
	}
};
static_assert(alignof(AGBAISpawnPoint) == 0x000008, "Wrong alignment on AGBAISpawnPoint");
static_assert(sizeof(AGBAISpawnPoint) == 0x0003A8, "Wrong size on AGBAISpawnPoint");
static_assert(offsetof(AGBAISpawnPoint, AIControllerClass) == 0x000260, "Member 'AGBAISpawnPoint::AIControllerClass' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, DefaultCharacterClass) == 0x000288, "Member 'AGBAISpawnPoint::DefaultCharacterClass' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, CharacterClass) == 0x0002B0, "Member 'AGBAISpawnPoint::CharacterClass' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, LoadoutFileName) == 0x000300, "Member 'AGBAISpawnPoint::LoadoutFileName' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, LoadoutInfo) == 0x000310, "Member 'AGBAISpawnPoint::LoadoutInfo' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, TeamId) == 0x000318, "Member 'AGBAISpawnPoint::TeamId' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, SquadId) == 0x000319, "Member 'AGBAISpawnPoint::SquadId' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, SquadOrders) == 0x00031C, "Member 'AGBAISpawnPoint::SquadOrders' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, bDaySpawn) == 0x000324, "Member 'AGBAISpawnPoint::bDaySpawn' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, bNightSpawn) == 0x000325, "Member 'AGBAISpawnPoint::bNightSpawn' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, GuardpointOverride) == 0x000328, "Member 'AGBAISpawnPoint::GuardpointOverride' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, SupportingBed) == 0x000330, "Member 'AGBAISpawnPoint::SupportingBed' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, AIIdleAction) == 0x000358, "Member 'AGBAISpawnPoint::AIIdleAction' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, SpriteComponent) == 0x000368, "Member 'AGBAISpawnPoint::SpriteComponent' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, SpawnedSupportingBed) == 0x000370, "Member 'AGBAISpawnPoint::SpawnedSupportingBed' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, bIsActive) == 0x000378, "Member 'AGBAISpawnPoint::bIsActive' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, DisplayCharacter) == 0x000380, "Member 'AGBAISpawnPoint::DisplayCharacter' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, CustomDetailWidgets) == 0x000388, "Member 'AGBAISpawnPoint::CustomDetailWidgets' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, Squad) == 0x000398, "Member 'AGBAISpawnPoint::Squad' has a wrong offset!");
static_assert(offsetof(AGBAISpawnPoint, bIsSelected) == 0x0003A0, "Member 'AGBAISpawnPoint::bIsSelected' has a wrong offset!");

// Class GroundBranch.GBAISquad
// 0x0080 (0x02A0 - 0x0220)
class AGBAISquad final : public AActor
{
public:
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AController*>                    SquadMembers;                                      // 0x0230(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AController*                            SquadLeader;                                       // 0x0240(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SquadOrdersTarget;                                 // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBAIPatrolRoute*                       PatrolRoute;                                       // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBAIPatrolRoute*                       PrevPatrolRoute;                                   // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              PatrolOffsetDistance;                              // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GuardPointVisitTimeOut;                            // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x1C];                                     // 0x0284(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSearchedLocation(const struct FVector& NewLocation);
	void AddSquadMember(class AController* Controller);
	void ClearSearchedLocations();
	void EmptySquad();
	class AGBAIPatrolRoute* FindNearestPatrolRoute(const struct FVector& Location);
	class AGBAIGuardPoint* GetNextGuardPoint(class AGBKytController* AIController);
	struct FVector GetNextPatrolPosition(class AController* Controller);
	void InternalUpdateSquadSeparationWeights();
	void RemoveSquadMember(class AController* Controller);
	bool SetAIStateBySquadOrders(class AGBKytController* AIController);
	void SetGuardPointVisitedBy(class AGBAIGuardPoint* GuardPoint, class AGBKytController* AIController);
	void SetPatrolRoute(class AGBAIPatrolRoute* NewPatrolRoute);
	void SetSquadId(uint8 NewSquadId);
	void SetSquadLeader(class AController* Controller);
	void SetSquadOrders(class FName NewOrders);
	void SetSquadOrdersTarget(class AActor* NewTarget);
	void UpdateSquadObjective();

	class AGBAIPatrolRoute* GetPatrolRoute() const;
	TArray<struct FVector> GetSearchedLocations() const;
	uint8 GetSquadId() const;
	class AController* GetSquadLeader() const;
	TArray<class AController*> GetSquadMembers() const;
	class FName GetSquadOrders() const;
	class AActor* GetSquadOrdersTarget() const;
	uint8 GetSquadSize() const;
	bool IsSquadMember(class AController* Controller) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAISquad">();
	}
	static class AGBAISquad* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBAISquad>();
	}
};
static_assert(alignof(AGBAISquad) == 0x000008, "Wrong alignment on AGBAISquad");
static_assert(sizeof(AGBAISquad) == 0x0002A0, "Wrong size on AGBAISquad");
static_assert(offsetof(AGBAISquad, SquadMembers) == 0x000230, "Member 'AGBAISquad::SquadMembers' has a wrong offset!");
static_assert(offsetof(AGBAISquad, SquadLeader) == 0x000240, "Member 'AGBAISquad::SquadLeader' has a wrong offset!");
static_assert(offsetof(AGBAISquad, SquadOrdersTarget) == 0x000250, "Member 'AGBAISquad::SquadOrdersTarget' has a wrong offset!");
static_assert(offsetof(AGBAISquad, PatrolRoute) == 0x000258, "Member 'AGBAISquad::PatrolRoute' has a wrong offset!");
static_assert(offsetof(AGBAISquad, PrevPatrolRoute) == 0x000260, "Member 'AGBAISquad::PrevPatrolRoute' has a wrong offset!");
static_assert(offsetof(AGBAISquad, PatrolOffsetDistance) == 0x000268, "Member 'AGBAISquad::PatrolOffsetDistance' has a wrong offset!");
static_assert(offsetof(AGBAISquad, GuardPointVisitTimeOut) == 0x000280, "Member 'AGBAISquad::GuardPointVisitTimeOut' has a wrong offset!");

// Class GroundBranch.GBPlayerLoadingScreenComponent
// 0x0020 (0x00D0 - 0x00B0)
class UGBPlayerLoadingScreenComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideLoadingScreen();
	void SetCustomLoadingScreenText(const class FString& NewText);
	void SetLoadingScreenInfo(const class FString& ServerName, const class FString& MissionTitle, const class FString& MapTitle, const class FString& MapAuthor, const class FString& MissionAuthor, const class FString& GameModeAuthor, const struct FUInt64& GameModeModID, const bool bMapModded, const bool bMissionModded);
	void ShowLoadingScreen(const class FString& NewLoadingScreenReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPlayerLoadingScreenComponent">();
	}
	static class UGBPlayerLoadingScreenComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBPlayerLoadingScreenComponent>();
	}
};
static_assert(alignof(UGBPlayerLoadingScreenComponent) == 0x000008, "Wrong alignment on UGBPlayerLoadingScreenComponent");
static_assert(sizeof(UGBPlayerLoadingScreenComponent) == 0x0000D0, "Wrong size on UGBPlayerLoadingScreenComponent");

// Class GroundBranch.GBPouch
// 0x0030 (0x0478 - 0x0448)
class AGBPouch : public AGBInvItem
{
public:
	class UStaticMeshComponent*                   PouchMeshComponent;                                // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0x28];                                     // 0x0450(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FillWith(const struct FPrimaryAssetId& InvItemId, const struct FPrimaryAssetId& InvSkinId);

	int32 GetFillCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPouch">();
	}
	static class AGBPouch* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBPouch>();
	}
};
static_assert(alignof(AGBPouch) == 0x000008, "Wrong alignment on AGBPouch");
static_assert(sizeof(AGBPouch) == 0x000478, "Wrong size on AGBPouch");
static_assert(offsetof(AGBPouch, PouchMeshComponent) == 0x000448, "Member 'AGBPouch::PouchMeshComponent' has a wrong offset!");

// Class GroundBranch.GBAmmoPouch
// 0x0040 (0x04B8 - 0x0478)
class AGBAmmoPouch : public AGBPouch
{
public:
	uint8                                         Pad_478[0x40];                                     // 0x0478(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool GetBestMatchingAmmoPouchId(const TArray<struct FPrimaryAssetId>& PouchItemAssetIds, EGBAmmoPouchModularity DesiredModularity, const struct FPrimaryAssetId& CurrentAmmoPouchId, struct FPrimaryAssetId* OutAmmoPouchId);

	void DelayedInit();
	void InitReplacement(EGBAmmoPouchModularity NewModularity);
	void InventoryItemAdded(class AGBCharacter* Character, class AGBInvItem* InvItem);
	void OnLoadReplacementAmmoPouchAssetId();
	void SetModularity(EGBAmmoPouchModularity NewModularity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAmmoPouch">();
	}
	static class AGBAmmoPouch* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBAmmoPouch>();
	}
};
static_assert(alignof(AGBAmmoPouch) == 0x000008, "Wrong alignment on AGBAmmoPouch");
static_assert(sizeof(AGBAmmoPouch) == 0x0004B8, "Wrong size on AGBAmmoPouch");

// Class GroundBranch.GBInvItemDragDropPayloadBase
// 0x0050 (0x0078 - 0x0028)
class UGBInvItemDragDropPayloadBase : public UObject
{
public:
	class FText                                   DisplayName;                                       // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 Icon;                                              // 0x0040(0x0028)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UGBInvItemDragDropPayloadBase* GBInvItemDragDropPayloadBase)> OnLoadAssetsCompleteDelegate; // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class AGBInvItem* GetInvItem() const;
	class AGBInvItem* GetRootInvItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBInvItemDragDropPayloadBase">();
	}
	static class UGBInvItemDragDropPayloadBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBInvItemDragDropPayloadBase>();
	}
};
static_assert(alignof(UGBInvItemDragDropPayloadBase) == 0x000008, "Wrong alignment on UGBInvItemDragDropPayloadBase");
static_assert(sizeof(UGBInvItemDragDropPayloadBase) == 0x000078, "Wrong size on UGBInvItemDragDropPayloadBase");
static_assert(offsetof(UGBInvItemDragDropPayloadBase, DisplayName) == 0x000028, "Member 'UGBInvItemDragDropPayloadBase::DisplayName' has a wrong offset!");
static_assert(offsetof(UGBInvItemDragDropPayloadBase, Icon) == 0x000040, "Member 'UGBInvItemDragDropPayloadBase::Icon' has a wrong offset!");
static_assert(offsetof(UGBInvItemDragDropPayloadBase, OnLoadAssetsCompleteDelegate) == 0x000068, "Member 'UGBInvItemDragDropPayloadBase::OnLoadAssetsCompleteDelegate' has a wrong offset!");

// Class GroundBranch.GBInvItemDragDropPayload
// 0x00A8 (0x0120 - 0x0078)
class UGBInvItemDragDropPayload : public UGBInvItemDragDropPayloadBase
{
public:
	TSoftClassPtr<class UClass>                   DragDropOperation;                                 // 0x0078(0x0028)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        InvItemAssetId;                                    // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUInt64                                InvItemModId;                                      // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        InvItemSkinAssetId;                                // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUInt64                                InvItemSkinModId;                                  // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x00D0(0x0020)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          bLoadingAssetsComplete;                            // 0x00F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                AssetsToLoad;                                      // 0x00F8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBInvItem*                             InvItem;                                           // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Init();
	void InitModInfo();
	void LoadingAssetsComplete();
	void OnInit();
	void OnLoadAssetsComplete();
	void SetInvItemSkinAssetId(const struct FPrimaryAssetId& NewInvItemSkinAssetId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBInvItemDragDropPayload">();
	}
	static class UGBInvItemDragDropPayload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBInvItemDragDropPayload>();
	}
};
static_assert(alignof(UGBInvItemDragDropPayload) == 0x000008, "Wrong alignment on UGBInvItemDragDropPayload");
static_assert(sizeof(UGBInvItemDragDropPayload) == 0x000120, "Wrong size on UGBInvItemDragDropPayload");
static_assert(offsetof(UGBInvItemDragDropPayload, DragDropOperation) == 0x000078, "Member 'UGBInvItemDragDropPayload::DragDropOperation' has a wrong offset!");
static_assert(offsetof(UGBInvItemDragDropPayload, InvItemAssetId) == 0x0000A0, "Member 'UGBInvItemDragDropPayload::InvItemAssetId' has a wrong offset!");
static_assert(offsetof(UGBInvItemDragDropPayload, InvItemModId) == 0x0000B0, "Member 'UGBInvItemDragDropPayload::InvItemModId' has a wrong offset!");
static_assert(offsetof(UGBInvItemDragDropPayload, InvItemSkinAssetId) == 0x0000B8, "Member 'UGBInvItemDragDropPayload::InvItemSkinAssetId' has a wrong offset!");
static_assert(offsetof(UGBInvItemDragDropPayload, InvItemSkinModId) == 0x0000C8, "Member 'UGBInvItemDragDropPayload::InvItemSkinModId' has a wrong offset!");
static_assert(offsetof(UGBInvItemDragDropPayload, GameplayTags) == 0x0000D0, "Member 'UGBInvItemDragDropPayload::GameplayTags' has a wrong offset!");
static_assert(offsetof(UGBInvItemDragDropPayload, bLoadingAssetsComplete) == 0x0000F0, "Member 'UGBInvItemDragDropPayload::bLoadingAssetsComplete' has a wrong offset!");
static_assert(offsetof(UGBInvItemDragDropPayload, AssetsToLoad) == 0x0000F8, "Member 'UGBInvItemDragDropPayload::AssetsToLoad' has a wrong offset!");
static_assert(offsetof(UGBInvItemDragDropPayload, InvItem) == 0x000118, "Member 'UGBInvItemDragDropPayload::InvItem' has a wrong offset!");

// Class GroundBranch.GBPlayerStart
// 0x0060 (0x02B0 - 0x0250)
class AGBPlayerStart final : public APlayerStart
{
public:
	uint8                                         Pad_250[0x18];                                     // 0x0250(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         TeamId;                                            // 0x0268(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Group;                                             // 0x026C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsActive;                                         // 0x0274(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGBPlayerStance                               StartingStance;                                    // 0x0275(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_276[0x2];                                      // 0x0276(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextRenderComponent*                   TextRender;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           CustomDetailWidgets;                               // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class AGBCharacter*                           DisplayCharacter;                                  // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsValidFor(class AController* Controller);
	void SetGroup(class FName NewGroupName);

	class FName GetGroup() const;
	EGBPlayerStance GetStartingStance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPlayerStart">();
	}
	static class AGBPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBPlayerStart>();
	}
};
static_assert(alignof(AGBPlayerStart) == 0x000008, "Wrong alignment on AGBPlayerStart");
static_assert(sizeof(AGBPlayerStart) == 0x0002B0, "Wrong size on AGBPlayerStart");
static_assert(offsetof(AGBPlayerStart, TeamId) == 0x000268, "Member 'AGBPlayerStart::TeamId' has a wrong offset!");
static_assert(offsetof(AGBPlayerStart, Group) == 0x00026C, "Member 'AGBPlayerStart::Group' has a wrong offset!");
static_assert(offsetof(AGBPlayerStart, bIsActive) == 0x000274, "Member 'AGBPlayerStart::bIsActive' has a wrong offset!");
static_assert(offsetof(AGBPlayerStart, StartingStance) == 0x000275, "Member 'AGBPlayerStart::StartingStance' has a wrong offset!");
static_assert(offsetof(AGBPlayerStart, TextRender) == 0x000278, "Member 'AGBPlayerStart::TextRender' has a wrong offset!");
static_assert(offsetof(AGBPlayerStart, CustomDetailWidgets) == 0x000280, "Member 'AGBPlayerStart::CustomDetailWidgets' has a wrong offset!");
static_assert(offsetof(AGBPlayerStart, DisplayCharacter) == 0x000290, "Member 'AGBPlayerStart::DisplayCharacter' has a wrong offset!");

// Class GroundBranch.GBPouchDragDropPayload
// 0x0028 (0x0148 - 0x0120)
class UGBPouchDragDropPayload : public UGBInvItemDragDropPayload
{
public:
	struct FPrimaryAssetId                        FillWithInvItemAssetId;                            // 0x0120(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        FillWithInvItemSkinAssetId;                        // 0x0130(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGBInvItem>                 FillWithClass;                                     // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TSubclassOf<class AGBInvItem> GetFillWithClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPouchDragDropPayload">();
	}
	static class UGBPouchDragDropPayload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBPouchDragDropPayload>();
	}
};
static_assert(alignof(UGBPouchDragDropPayload) == 0x000008, "Wrong alignment on UGBPouchDragDropPayload");
static_assert(sizeof(UGBPouchDragDropPayload) == 0x000148, "Wrong size on UGBPouchDragDropPayload");
static_assert(offsetof(UGBPouchDragDropPayload, FillWithInvItemAssetId) == 0x000120, "Member 'UGBPouchDragDropPayload::FillWithInvItemAssetId' has a wrong offset!");
static_assert(offsetof(UGBPouchDragDropPayload, FillWithInvItemSkinAssetId) == 0x000130, "Member 'UGBPouchDragDropPayload::FillWithInvItemSkinAssetId' has a wrong offset!");
static_assert(offsetof(UGBPouchDragDropPayload, FillWithClass) == 0x000140, "Member 'UGBPouchDragDropPayload::FillWithClass' has a wrong offset!");

// Class GroundBranch.GBAmmoPouchDragDropPayload
// 0x0008 (0x0150 - 0x0148)
class UGBAmmoPouchDragDropPayload final : public UGBPouchDragDropPayload
{
public:
	EGBAmmoPouchModularity                        Modularity;                                        // 0x0148(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAmmoPouchDragDropPayload">();
	}
	static class UGBAmmoPouchDragDropPayload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAmmoPouchDragDropPayload>();
	}
};
static_assert(alignof(UGBAmmoPouchDragDropPayload) == 0x000008, "Wrong alignment on UGBAmmoPouchDragDropPayload");
static_assert(sizeof(UGBAmmoPouchDragDropPayload) == 0x000150, "Wrong size on UGBAmmoPouchDragDropPayload");
static_assert(offsetof(UGBAmmoPouchDragDropPayload, Modularity) == 0x000148, "Member 'UGBAmmoPouchDragDropPayload::Modularity' has a wrong offset!");

// Class GroundBranch.GBAmmunitionFeedComponent
// 0x0010 (0x0210 - 0x0200)
#pragma pack(push, 0x1)
class alignas(0x10) UGBAmmunitionFeedComponent : public USceneComponent
{
public:
	uint8                                         Pad_1F8[0x10];                                     // 0x01F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DecodeKit(class UVaRestJsonObject* ItemAsJson);
	void EncodeKit(class UVaRestJsonObject* ItemAsJson);
	void Fill();
	void SetCurrentAmmoId(const struct FPrimaryAssetId& NewCurrentAmmoId);
	void UseRound();

	TSubclassOf<class AGBBulletProjectile> GetBulletProjectileClass() const;
	struct FPrimaryAssetId GetCurrentAmmoId() const;
	int32 GetTotalAvailableCount() const;
	bool IsEmpty() const;
	bool ShouldMagicallyCreateAmmo(const class AGBCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAmmunitionFeedComponent">();
	}
	static class UGBAmmunitionFeedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAmmunitionFeedComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGBAmmunitionFeedComponent) == 0x000010, "Wrong alignment on UGBAmmunitionFeedComponent");
static_assert(sizeof(UGBAmmunitionFeedComponent) == 0x000210, "Wrong size on UGBAmmunitionFeedComponent");

// Class GroundBranch.GBPostProcessCameraModifier
// 0x0568 (0x05B0 - 0x0048)
class UGBPostProcessCameraModifier final : public UGBCameraModifier
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   CameraModifierPostProcessSettings;                 // 0x0050(0x0560)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPostProcessCameraModifier">();
	}
	static class UGBPostProcessCameraModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBPostProcessCameraModifier>();
	}
};
static_assert(alignof(UGBPostProcessCameraModifier) == 0x000010, "Wrong alignment on UGBPostProcessCameraModifier");
static_assert(sizeof(UGBPostProcessCameraModifier) == 0x0005B0, "Wrong size on UGBPostProcessCameraModifier");
static_assert(offsetof(UGBPostProcessCameraModifier, CameraModifierPostProcessSettings) == 0x000050, "Member 'UGBPostProcessCameraModifier::CameraModifierPostProcessSettings' has a wrong offset!");

// Class GroundBranch.GBAnimFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGBAnimFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float FindPositionFromDistanceCurve(const float& Distance, class UAnimSequenceBase* InAnimSequence);
	static struct FTransform GetBoneTransformAtTime(class UAnimSequence* AnimSequence, float AnimTime, class FName BoneName, bool bUseRawDataOnly);
	static float GetRateForPlayTime(class UAnimSequenceBase* TargetSeq, float PlayTime);
	static float GetSequenceLength(class UAnimSequenceBase* TargetSeq);
	static void TransformFromBoneSpace(class UAnimInstance* Target, class FName BoneName, const struct FVector& position, const struct FRotator& Rotation, struct FVector* OutPosition, struct FRotator* OutRotation);
	static void TransformToBoneSpace(class UAnimInstance* Target, class FName BoneName, const struct FVector& position, const struct FRotator& Rotation, struct FVector* OutPosition, struct FRotator* OutRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAnimFunctionLibrary">();
	}
	static class UGBAnimFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAnimFunctionLibrary>();
	}
};
static_assert(alignof(UGBAnimFunctionLibrary) == 0x000008, "Wrong alignment on UGBAnimFunctionLibrary");
static_assert(sizeof(UGBAnimFunctionLibrary) == 0x000028, "Wrong size on UGBAnimFunctionLibrary");

// Class GroundBranch.GBAnimNotify_PlayCameraAnim
// 0x0010 (0x0048 - 0x0038)
class UGBAnimNotify_PlayCameraAnim final : public UAnimNotify
{
public:
	TSubclassOf<class UCameraShakeBase>           CameraShake;                                       // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CameraShakeIntensityScale;                         // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAnimNotify_PlayCameraAnim">();
	}
	static class UGBAnimNotify_PlayCameraAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAnimNotify_PlayCameraAnim>();
	}
};
static_assert(alignof(UGBAnimNotify_PlayCameraAnim) == 0x000008, "Wrong alignment on UGBAnimNotify_PlayCameraAnim");
static_assert(sizeof(UGBAnimNotify_PlayCameraAnim) == 0x000048, "Wrong size on UGBAnimNotify_PlayCameraAnim");
static_assert(offsetof(UGBAnimNotify_PlayCameraAnim, CameraShake) == 0x000038, "Member 'UGBAnimNotify_PlayCameraAnim::CameraShake' has a wrong offset!");
static_assert(offsetof(UGBAnimNotify_PlayCameraAnim, CameraShakeIntensityScale) == 0x000040, "Member 'UGBAnimNotify_PlayCameraAnim::CameraShakeIntensityScale' has a wrong offset!");

// Class GroundBranch.GBAnimNotify_TriggerRagdoll
// 0x0000 (0x0038 - 0x0038)
class UGBAnimNotify_TriggerRagdoll final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAnimNotify_TriggerRagdoll">();
	}
	static class UGBAnimNotify_TriggerRagdoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAnimNotify_TriggerRagdoll>();
	}
};
static_assert(alignof(UGBAnimNotify_TriggerRagdoll) == 0x000008, "Wrong alignment on UGBAnimNotify_TriggerRagdoll");
static_assert(sizeof(UGBAnimNotify_TriggerRagdoll) == 0x000038, "Wrong size on UGBAnimNotify_TriggerRagdoll");

// Class GroundBranch.GBAnimNotifyInterface
// 0x0000 (0x0000 - 0x0000)
class IGBAnimNotifyInterface final
{
public:
	void NotifyEnum(uint8 InEnumAsByte);
	void NotifyName(class FName InName);
	void NotifyStateBeginEnum(uint8 InEnumAsByte, float TotalDuration);
	void NotifyStateBeginName(class FName InName, float TotalDuration);
	void NotifyStateEndEnum(uint8 InEnumAsByte);
	void NotifyStateEndName(class FName InName);
	void NotifyStateTickEnum(uint8 InEnumAsByte, float FrameDeltaTime);
	void NotifyStateTickName(class FName InName, float FrameDeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAnimNotifyInterface">();
	}
	static class IGBAnimNotifyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGBAnimNotifyInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGBAnimNotifyInterface) == 0x000001, "Wrong alignment on IGBAnimNotifyInterface");
static_assert(sizeof(IGBAnimNotifyInterface) == 0x000001, "Wrong size on IGBAnimNotifyInterface");

// Class GroundBranch.GBAnimNotifyState_BlendRagdoll
// 0x0030 (0x0060 - 0x0030)
class UGBAnimNotifyState_BlendRagdoll final : public UAnimNotifyState
{
public:
	float                                         TotalBlendDuration;                                // 0x0030(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentBlendAmount;                                // 0x0034(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyConstraintProfile;                           // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKeepConstraintProfileAfterAnim;                   // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ConstraintProfileName;                             // 0x003C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngularVelocityStrength;                           // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OrientationStrength;                               // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PositionStrength;                                  // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VelocityStrength;                                  // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAngularForce;                                   // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxLinearForce;                                    // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAnimNotifyState_BlendRagdoll">();
	}
	static class UGBAnimNotifyState_BlendRagdoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAnimNotifyState_BlendRagdoll>();
	}
};
static_assert(alignof(UGBAnimNotifyState_BlendRagdoll) == 0x000008, "Wrong alignment on UGBAnimNotifyState_BlendRagdoll");
static_assert(sizeof(UGBAnimNotifyState_BlendRagdoll) == 0x000060, "Wrong size on UGBAnimNotifyState_BlendRagdoll");
static_assert(offsetof(UGBAnimNotifyState_BlendRagdoll, TotalBlendDuration) == 0x000030, "Member 'UGBAnimNotifyState_BlendRagdoll::TotalBlendDuration' has a wrong offset!");
static_assert(offsetof(UGBAnimNotifyState_BlendRagdoll, CurrentBlendAmount) == 0x000034, "Member 'UGBAnimNotifyState_BlendRagdoll::CurrentBlendAmount' has a wrong offset!");
static_assert(offsetof(UGBAnimNotifyState_BlendRagdoll, bApplyConstraintProfile) == 0x000038, "Member 'UGBAnimNotifyState_BlendRagdoll::bApplyConstraintProfile' has a wrong offset!");
static_assert(offsetof(UGBAnimNotifyState_BlendRagdoll, bKeepConstraintProfileAfterAnim) == 0x000039, "Member 'UGBAnimNotifyState_BlendRagdoll::bKeepConstraintProfileAfterAnim' has a wrong offset!");
static_assert(offsetof(UGBAnimNotifyState_BlendRagdoll, ConstraintProfileName) == 0x00003C, "Member 'UGBAnimNotifyState_BlendRagdoll::ConstraintProfileName' has a wrong offset!");
static_assert(offsetof(UGBAnimNotifyState_BlendRagdoll, AngularVelocityStrength) == 0x000044, "Member 'UGBAnimNotifyState_BlendRagdoll::AngularVelocityStrength' has a wrong offset!");
static_assert(offsetof(UGBAnimNotifyState_BlendRagdoll, OrientationStrength) == 0x000048, "Member 'UGBAnimNotifyState_BlendRagdoll::OrientationStrength' has a wrong offset!");
static_assert(offsetof(UGBAnimNotifyState_BlendRagdoll, PositionStrength) == 0x00004C, "Member 'UGBAnimNotifyState_BlendRagdoll::PositionStrength' has a wrong offset!");
static_assert(offsetof(UGBAnimNotifyState_BlendRagdoll, VelocityStrength) == 0x000050, "Member 'UGBAnimNotifyState_BlendRagdoll::VelocityStrength' has a wrong offset!");
static_assert(offsetof(UGBAnimNotifyState_BlendRagdoll, MaxAngularForce) == 0x000054, "Member 'UGBAnimNotifyState_BlendRagdoll::MaxAngularForce' has a wrong offset!");
static_assert(offsetof(UGBAnimNotifyState_BlendRagdoll, MaxLinearForce) == 0x000058, "Member 'UGBAnimNotifyState_BlendRagdoll::MaxLinearForce' has a wrong offset!");

// Class GroundBranch.GBAssetManager
// 0x00A0 (0x0518 - 0x0478)
class UGBAssetManager final : public UAssetManager
{
public:
	uint8                                         Pad_478[0xA0];                                     // 0x0478(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BlueprintAsyncLoadAsset(const TSoftObjectPtr<class UObject>& SoftObjectPtr, TDelegate<void(class UObject* LoadedAsset)> OnAsyncLoadAssetComplete);
	static void BlueprintAsyncLoadAssetPath(const struct FSoftObjectPath& SoftObjectPath, TDelegate<void(class UObject* LoadedAsset)> OnAsyncLoadAssetComplete);
	static void BlueprintAsyncLoadAssetPaths(const TArray<struct FSoftObjectPath>& SoftObjectPaths, TDelegate<void(const TArray<class UObject*>& LoadedAssets)> OnAsyncLoadAssetsComplete);
	static void BlueprintAsyncLoadAssets(const TArray<TSoftObjectPtr<class UObject>>& SoftObjectPtrs, TDelegate<void(const TArray<class UObject*>& LoadedAssets)> OnAsyncLoadAssetsComplete);
	static void BlueprintAsyncLoadClassAsset(const TSoftClassPtr<class UClass>& SoftClassPtr, TDelegate<void(class UClass* LoadedClass)> OnAsyncLoadClassAssetComplete);
	static void BlueprintAsyncLoadClassAssets(const TArray<TSoftClassPtr<class UClass>>& SoftClassPtrs, TDelegate<void(const TArray<class UClass*>& LoadedClasses)> OnAsyncLoadClassAssetsComplete);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAssetManager">();
	}
	static class UGBAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAssetManager>();
	}
};
static_assert(alignof(UGBAssetManager) == 0x000008, "Wrong alignment on UGBAssetManager");
static_assert(sizeof(UGBAssetManager) == 0x000518, "Wrong size on UGBAssetManager");

// Class GroundBranch.GBAssetManagerFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGBAssetManagerFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool Array_GetARSFromPrimaryAsset(const TArray<int32>& TargetArray, const struct FPrimaryAssetId& PrimaryAssetId, class FName TagKey);
	static class FName Conv_PrimaryAssetTypeToName(const struct FPrimaryAssetType& PrimaryAssetType);
	static bool GetARSBoolFromPrimaryAsset(const struct FPrimaryAssetId& PrimaryAssetId, class FName TagKey, bool* bOutBool);
	static bool GetARSEnumAsByteFromPrimaryAsset(const struct FPrimaryAssetId& PrimaryAssetId, const class FString& EnumName, class FName TagKey, uint8* OutByte);
	static bool GetARSFloatFromPrimaryAsset(const struct FPrimaryAssetId& PrimaryAssetId, class FName TagKey, float* OutFloat);
	static bool GetARSIntFromPrimaryAsset(const struct FPrimaryAssetId& PrimaryAssetId, class FName TagKey, int32* OutInt);
	static bool GetARSNameFromPrimaryAsset(const struct FPrimaryAssetId& PrimaryAssetId, class FName TagKey, class FName* OutName);
	static bool GetARSSoftObjectPtrFromPrimaryAsset(const struct FPrimaryAssetId& PrimaryAssetId, class FName TagKey, TSoftObjectPtr<class UObject>* OutSoftObjectPtr);
	static bool GetARSStringFromPrimaryAsset(const struct FPrimaryAssetId& PrimaryAssetId, class FName TagKey, class FString* OutString);
	static bool GetARSStructFromPrimaryAsset(const struct FGBDummyStruct& Value, const struct FPrimaryAssetId& PrimaryAssetId, class FName TagKey);
	static bool GetARSTextFromPrimaryAsset(const struct FPrimaryAssetId& PrimaryAssetId, class FName TagKey, class FText* OutText);
	static TArray<class FName> GetBundlesToLoad(const class UObject* WorldContextObject);
	static bool GetFallbackInvItemAndSkin(const class FName& ProfileName, const struct FGameplayTagContainer& InvItemTags, struct FPrimaryAssetId* OutItemAssetId, struct FPrimaryAssetId* OutItemSkinId);
	static struct FPrimaryAssetId GetFirstValidInvItemSkinId(const class FName& ProfileName, const struct FGameplayTag& InvItemSkinTypeTag);
	static struct FGameplayTagContainer GetGameplayTagContainer(const struct FPrimaryAssetId& PrimaryAssetId, class FName AssetDataTag);
	static void GetInvItemAssetIds(const struct FGameplayTagContainer& InvItemTags, EGBInvItemTagsCheckType InvItemTagsCheckType, const struct FGameplayTagContainer& ExcludeInvItemTags, TArray<struct FPrimaryAssetId>* OutItemAssetIds);
	static struct FPrimaryAssetId GetInvItemSkinIdByTypeAndName(const struct FGameplayTag& InvItemSkinTypeTag, const struct FGameplayTag& InvItemSkinNameTag);
	static bool GetInvItemSkinInfoByNameTag(const struct FGameplayTag& InvItemSkinNameTag, struct FPrimaryAssetId* OutSkinAssetId);
	static struct FGameplayTag GetInvItemSkinNameTag(const struct FPrimaryAssetId& InvItemSkinAssetId);
	static struct FGameplayTag GetInvItemSkinTypeTag(const struct FPrimaryAssetId& InvItemAssetId);
	static struct FGameplayTagContainer GetInvItemTags(const struct FPrimaryAssetId& ItemAssetId);
	static struct FGameplayTag GetInvItemTypeTag(const struct FPrimaryAssetId& ItemAssetId);
	static struct FPrimaryAssetId GetPrimaryAssetIdForPath(const struct FSoftObjectPath& ObjectPath);
	static struct FPrimaryAssetId GetSimilarInvItemSkinId(const class FName& ProfileName, const struct FGameplayTag& InvItemSkinTypeTag, const struct FGameplayTag& InvItemSkinNameTag, const struct FGameplayTagContainer& SubstituteInvItemSkinNameTags);
	static struct FPrimaryAssetId GetSimilarInvItemSkinIdToExisting(const class FName& ProfileName, const struct FGameplayTag& InvItemSkinTypeTag, const struct FPrimaryAssetId& ExistingInvItemSkinId);
	static struct FGameplayTagContainer GetSubstituteInvItemSkinNameTags(const struct FGameplayTag& InvItemSkinNameTag);
	static TArray<struct FPrimaryAssetId> GetValidInvItemSkinIds(const class FName& ProfileName, const struct FGameplayTag& InvItemSkinTypeTag);
	static bool HasInvItemSkins(const struct FGameplayTag& InvItemSkinTypeTag);
	static bool Map_GetARSFromPrimaryAsset(const TMap<int32, int32>& TargetMap, const struct FPrimaryAssetId& PrimaryAssetId, class FName TagKey);
	static bool RestrictedPrimaryAsset(const class FName& ProfileName, const struct FPrimaryAssetId& PrimaryAssetId);
	static void SortPrimaryAssetIdList(const TArray<struct FPrimaryAssetId>& InPrimaryAssetIdList, const class FName SortTag, TArray<struct FPrimaryAssetId>* OutPrimaryAssetIdList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAssetManagerFunctionLibrary">();
	}
	static class UGBAssetManagerFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAssetManagerFunctionLibrary>();
	}
};
static_assert(alignof(UGBAssetManagerFunctionLibrary) == 0x000008, "Wrong alignment on UGBAssetManagerFunctionLibrary");
static_assert(sizeof(UGBAssetManagerFunctionLibrary) == 0x000028, "Wrong size on UGBAssetManagerFunctionLibrary");

// Class GroundBranch.GBAssetManagerSettings
// 0x0010 (0x0048 - 0x0038)
class UGBAssetManagerSettings final : public UDeveloperSettings
{
public:
	TArray<struct FGBKitFieldPrimaryAssetType>    KitFieldPrimaryAssetTypes;                         // 0x0038(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAssetManagerSettings">();
	}
	static class UGBAssetManagerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBAssetManagerSettings>();
	}
};
static_assert(alignof(UGBAssetManagerSettings) == 0x000008, "Wrong alignment on UGBAssetManagerSettings");
static_assert(sizeof(UGBAssetManagerSettings) == 0x000048, "Wrong size on UGBAssetManagerSettings");
static_assert(offsetof(UGBAssetManagerSettings, KitFieldPrimaryAssetTypes) == 0x000038, "Member 'UGBAssetManagerSettings::KitFieldPrimaryAssetTypes' has a wrong offset!");

// Class GroundBranch.GBAudioGeo
// 0x0008 (0x0260 - 0x0258)
class AGBAudioGeo final : public AVolume
{
public:
	class UAkGeometryComponent*                   GeoComp;                                           // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBAudioGeo">();
	}
	static class AGBAudioGeo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBAudioGeo>();
	}
};
static_assert(alignof(AGBAudioGeo) == 0x000008, "Wrong alignment on AGBAudioGeo");
static_assert(sizeof(AGBAudioGeo) == 0x000260, "Wrong size on AGBAudioGeo");
static_assert(offsetof(AGBAudioGeo, GeoComp) == 0x000258, "Member 'AGBAudioGeo::GeoComp' has a wrong offset!");

// Class GroundBranch.GBBarrelComponent
// 0x0030 (0x0230 - 0x0200)
class UGBBarrelComponent final : public USceneComponent
{
public:
	float                                         VelocityModifier;                                  // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBMuzzleDevice*                        MuzzleDevice;                                      // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AudioSignalRadius;                                 // 0x0208(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SuppressorSwitchValue;                             // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LightLevelKey;                                     // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightLevelAlpha;                                   // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightLevelTime;                                    // 0x0224(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMuzzleDevice(class AGBMuzzleDevice* NewMuzzleDevice);
	void SetVelocityModifier(float NewVelocityModifier);
	class AGBBulletProjectile* SpawnBulletProjectile(TSubclassOf<class AGBBulletProjectile> BulletProjectileClass);

	float GetAudioSignalRadius() const;
	class AGBMuzzleDevice* GetMuzzleDevice() const;
	class FName GetSuppressorSwitchValue() const;
	float GetVelocityModifier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBBarrelComponent">();
	}
	static class UGBBarrelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBBarrelComponent>();
	}
};
static_assert(alignof(UGBBarrelComponent) == 0x000010, "Wrong alignment on UGBBarrelComponent");
static_assert(sizeof(UGBBarrelComponent) == 0x000230, "Wrong size on UGBBarrelComponent");
static_assert(offsetof(UGBBarrelComponent, VelocityModifier) == 0x0001F8, "Member 'UGBBarrelComponent::VelocityModifier' has a wrong offset!");
static_assert(offsetof(UGBBarrelComponent, MuzzleDevice) == 0x000200, "Member 'UGBBarrelComponent::MuzzleDevice' has a wrong offset!");
static_assert(offsetof(UGBBarrelComponent, AudioSignalRadius) == 0x000208, "Member 'UGBBarrelComponent::AudioSignalRadius' has a wrong offset!");
static_assert(offsetof(UGBBarrelComponent, SuppressorSwitchValue) == 0x000210, "Member 'UGBBarrelComponent::SuppressorSwitchValue' has a wrong offset!");
static_assert(offsetof(UGBBarrelComponent, LightLevelKey) == 0x000218, "Member 'UGBBarrelComponent::LightLevelKey' has a wrong offset!");
static_assert(offsetof(UGBBarrelComponent, LightLevelAlpha) == 0x000220, "Member 'UGBBarrelComponent::LightLevelAlpha' has a wrong offset!");
static_assert(offsetof(UGBBarrelComponent, LightLevelTime) == 0x000224, "Member 'UGBBarrelComponent::LightLevelTime' has a wrong offset!");

// Class GroundBranch.GBBenchmarker
// 0x0530 (0x0750 - 0x0220)
class AGBBenchmarker : public AActor
{
public:
	class ULevelSequence*                         BenchmarkSequence;                                 // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ACameraActor*>                   HotspotCameras;                                    // 0x0228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class ULevelSequencePlayer*                   BenchmarkSequencePlayer;                           // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALevelSequenceActor*                    BenchmarkSequenceActor;                            // 0x0240(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBenchmarkResults                      BenchmarkResults;                                  // 0x0248(0x02B8)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FString                                 LastCreatedHTMLFilePath;                           // 0x0500(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutputDirectory;                                   // 0x0510(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DiscordWebHook;                                    // 0x0520(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_530[0x210];                                    // 0x0530(0x0210)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBPlayerController*                    GBPlayerController;                                // 0x0740(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBPlayerState*                         GBPlayerState;                                     // 0x0748(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CreateBenchmarkReportWidget();
	void CreateBenchmarkSequenceWidget();
	void FadeIn(float FadeTime);
	void FadeInAndOut(float FadeTime);
	void FadeOut(float FadeTime);
	void FinishBenchmarkSource();
	class FString GetDirectory();
	class FString GetTemplatesFolder();
	void HotspotPostWarmup();
	void OpenBenchmarksDirectory();
	void OpenHTMLFile();
	void OpenLevelSequence();
	void PostFinishBenchmarkSource();
	void RemoveBenchmarkWidgets();
	void ReturnToMenu();
	void StartBenchmarkPostWarmup();

	bool IsBenchmarking() const;
	bool IsBenchmarkPreparing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBBenchmarker">();
	}
	static class AGBBenchmarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBBenchmarker>();
	}
};
static_assert(alignof(AGBBenchmarker) == 0x000008, "Wrong alignment on AGBBenchmarker");
static_assert(sizeof(AGBBenchmarker) == 0x000750, "Wrong size on AGBBenchmarker");
static_assert(offsetof(AGBBenchmarker, BenchmarkSequence) == 0x000220, "Member 'AGBBenchmarker::BenchmarkSequence' has a wrong offset!");
static_assert(offsetof(AGBBenchmarker, HotspotCameras) == 0x000228, "Member 'AGBBenchmarker::HotspotCameras' has a wrong offset!");
static_assert(offsetof(AGBBenchmarker, BenchmarkSequencePlayer) == 0x000238, "Member 'AGBBenchmarker::BenchmarkSequencePlayer' has a wrong offset!");
static_assert(offsetof(AGBBenchmarker, BenchmarkSequenceActor) == 0x000240, "Member 'AGBBenchmarker::BenchmarkSequenceActor' has a wrong offset!");
static_assert(offsetof(AGBBenchmarker, BenchmarkResults) == 0x000248, "Member 'AGBBenchmarker::BenchmarkResults' has a wrong offset!");
static_assert(offsetof(AGBBenchmarker, LastCreatedHTMLFilePath) == 0x000500, "Member 'AGBBenchmarker::LastCreatedHTMLFilePath' has a wrong offset!");
static_assert(offsetof(AGBBenchmarker, OutputDirectory) == 0x000510, "Member 'AGBBenchmarker::OutputDirectory' has a wrong offset!");
static_assert(offsetof(AGBBenchmarker, DiscordWebHook) == 0x000520, "Member 'AGBBenchmarker::DiscordWebHook' has a wrong offset!");
static_assert(offsetof(AGBBenchmarker, GBPlayerController) == 0x000740, "Member 'AGBBenchmarker::GBPlayerController' has a wrong offset!");
static_assert(offsetof(AGBBenchmarker, GBPlayerState) == 0x000748, "Member 'AGBBenchmarker::GBPlayerState' has a wrong offset!");

// Class GroundBranch.GBBTTask_MoveToCover
// 0x0000 (0x00B0 - 0x00B0)
class UGBBTTask_MoveToCover final : public UBTTask_MoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBBTTask_MoveToCover">();
	}
	static class UGBBTTask_MoveToCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBBTTask_MoveToCover>();
	}
};
static_assert(alignof(UGBBTTask_MoveToCover) == 0x000008, "Wrong alignment on UGBBTTask_MoveToCover");
static_assert(sizeof(UGBBTTask_MoveToCover) == 0x0000B0, "Wrong size on UGBBTTask_MoveToCover");

// Class GroundBranch.GBBTTask_WaitBlackboardTime
// 0x0028 (0x00C8 - 0x00A0)
class UGBBTTask_WaitBlackboardTime final : public UBTTask_WaitBlackboardTime
{
public:
	struct FBlackboardKeySelector                 RandomDeviationKey;                                // 0x00A0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBBTTask_WaitBlackboardTime">();
	}
	static class UGBBTTask_WaitBlackboardTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBBTTask_WaitBlackboardTime>();
	}
};
static_assert(alignof(UGBBTTask_WaitBlackboardTime) == 0x000008, "Wrong alignment on UGBBTTask_WaitBlackboardTime");
static_assert(sizeof(UGBBTTask_WaitBlackboardTime) == 0x0000C8, "Wrong size on UGBBTTask_WaitBlackboardTime");
static_assert(offsetof(UGBBTTask_WaitBlackboardTime, RandomDeviationKey) == 0x0000A0, "Member 'UGBBTTask_WaitBlackboardTime::RandomDeviationKey' has a wrong offset!");

// Class GroundBranch.GBCharAnimInstanceLayer
// 0x0800 (0x0AC0 - 0x02C0)
class UGBCharAnimInstanceLayer : public UAnimInstance
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGBCharAnimInstanceLayerProxy          Proxy;                                             // 0x02C0(0x07F0)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPrivate)
	float                                         SprintBlendInTime;                                 // 0x0AB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintBlendOutTime;                                // 0x0AB4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB8[0x8];                                      // 0x0AB8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEquippedItemsUpdatedEvent();

	class UAnimMontage* GetMontageFromLinkedLayer(class FName MontageName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBCharAnimInstanceLayer">();
	}
	static class UGBCharAnimInstanceLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBCharAnimInstanceLayer>();
	}
};
static_assert(alignof(UGBCharAnimInstanceLayer) == 0x000010, "Wrong alignment on UGBCharAnimInstanceLayer");
static_assert(sizeof(UGBCharAnimInstanceLayer) == 0x000AC0, "Wrong size on UGBCharAnimInstanceLayer");
static_assert(offsetof(UGBCharAnimInstanceLayer, Proxy) == 0x0002C0, "Member 'UGBCharAnimInstanceLayer::Proxy' has a wrong offset!");
static_assert(offsetof(UGBCharAnimInstanceLayer, SprintBlendInTime) == 0x000AB0, "Member 'UGBCharAnimInstanceLayer::SprintBlendInTime' has a wrong offset!");
static_assert(offsetof(UGBCharAnimInstanceLayer, SprintBlendOutTime) == 0x000AB4, "Member 'UGBCharAnimInstanceLayer::SprintBlendOutTime' has a wrong offset!");

// Class GroundBranch.GBCharEmoteData
// 0x0028 (0x0058 - 0x0030)
class UGBCharEmoteData final : public UPrimaryDataAsset
{
public:
	TSoftObjectPtr<class UAnimMontage>            Montage;                                           // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBCharEmoteData">();
	}
	static class UGBCharEmoteData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBCharEmoteData>();
	}
};
static_assert(alignof(UGBCharEmoteData) == 0x000008, "Wrong alignment on UGBCharEmoteData");
static_assert(sizeof(UGBCharEmoteData) == 0x000058, "Wrong size on UGBCharEmoteData");
static_assert(offsetof(UGBCharEmoteData, Montage) == 0x000030, "Member 'UGBCharEmoteData::Montage' has a wrong offset!");

// Class GroundBranch.GBCharVoiceData
// 0x0050 (0x0080 - 0x0030)
class UGBCharVoiceData final : public UPrimaryDataAsset
{
public:
	TArray<struct FCharVoiceMessage>              Messages;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkSwitchValue>          FactionSwitchValue;                                // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UAkSwitchValue>>  VoiceActorSwitchValues;                            // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         NumVoiceActors;                                    // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBCharVoiceData">();
	}
	static class UGBCharVoiceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBCharVoiceData>();
	}
};
static_assert(alignof(UGBCharVoiceData) == 0x000008, "Wrong alignment on UGBCharVoiceData");
static_assert(sizeof(UGBCharVoiceData) == 0x000080, "Wrong size on UGBCharVoiceData");
static_assert(offsetof(UGBCharVoiceData, Messages) == 0x000030, "Member 'UGBCharVoiceData::Messages' has a wrong offset!");
static_assert(offsetof(UGBCharVoiceData, FactionSwitchValue) == 0x000040, "Member 'UGBCharVoiceData::FactionSwitchValue' has a wrong offset!");
static_assert(offsetof(UGBCharVoiceData, VoiceActorSwitchValues) == 0x000068, "Member 'UGBCharVoiceData::VoiceActorSwitchValues' has a wrong offset!");
static_assert(offsetof(UGBCharVoiceData, NumVoiceActors) == 0x000078, "Member 'UGBCharVoiceData::NumVoiceActors' has a wrong offset!");

// Class GroundBranch.GBPlayerControllerBase
// 0x0038 (0x05A8 - 0x0570)
class AGBPlayerControllerBase : public APlayerController
{
public:
	TMulticastInlineDelegate<void()>              OnColourBlindnessFilterUpdate;                     // 0x0570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UGBColourBlindnessCameraModifier> ColourBlindnessCameraModifierClass;          // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGBPlayerLoadingScreenComponent*        PlayerLoadingScreenComponent;                      // 0x0588(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_590[0x8];                                      // 0x0590(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGBFullScreenWidget>            FullScreenWidgets;                                 // 0x0598(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void AddFullScreenWidget(class UUserWidget* FullScreenWidget, int32 Priority);
	void ApplyPlayerSettings(class UGBPlayerSettings* PlayerSettings);
	void GBClientSeamlessTravel(const class FString& URL);
	void ListFullScreenWidgets();
	void RemoveFullScreenWidget(class UUserWidget* FullScreenWidget);

	class UGBPlayerSettings* GetPlayerSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPlayerControllerBase">();
	}
	static class AGBPlayerControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBPlayerControllerBase>();
	}
};
static_assert(alignof(AGBPlayerControllerBase) == 0x000008, "Wrong alignment on AGBPlayerControllerBase");
static_assert(sizeof(AGBPlayerControllerBase) == 0x0005A8, "Wrong size on AGBPlayerControllerBase");
static_assert(offsetof(AGBPlayerControllerBase, OnColourBlindnessFilterUpdate) == 0x000570, "Member 'AGBPlayerControllerBase::OnColourBlindnessFilterUpdate' has a wrong offset!");
static_assert(offsetof(AGBPlayerControllerBase, ColourBlindnessCameraModifierClass) == 0x000580, "Member 'AGBPlayerControllerBase::ColourBlindnessCameraModifierClass' has a wrong offset!");
static_assert(offsetof(AGBPlayerControllerBase, PlayerLoadingScreenComponent) == 0x000588, "Member 'AGBPlayerControllerBase::PlayerLoadingScreenComponent' has a wrong offset!");
static_assert(offsetof(AGBPlayerControllerBase, FullScreenWidgets) == 0x000598, "Member 'AGBPlayerControllerBase::FullScreenWidgets' has a wrong offset!");

// Class GroundBranch.GBPlayerController
// 0x0578 (0x0B20 - 0x05A8)
class AGBPlayerController : public AGBPlayerControllerBase
{
public:
	uint8                                         Pad_5A8[0x8];                                      // 0x05A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ServerViewTarget;                                  // 0x05B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               TargetControlRotation;                             // 0x05B8(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C4[0xC];                                      // 0x05C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBCharacter*                           GBCharacter;                                       // 0x05D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGBPlayerInput*                         GBPlayerInput;                                     // 0x05D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGBPlayerState*                         GBPlayerState;                                     // 0x05E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x48];                                     // 0x05E8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGBDialogWidget>            DialogWidgetClass;                                 // 0x0630(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DialogDefaultSelfDestructTime;                     // 0x0638(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseTurnRate;                                      // 0x063C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseLookUpRate;                                    // 0x0640(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTurnRate;                                       // 0x0644(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxProneTurnRate;                                  // 0x0648(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxProneCrawlTurnRate;                             // 0x064C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSprintTurnRate;                                 // 0x0650(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ResetFreeLookInterpSpeed;                          // 0x0654(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_658[0x4];                                      // 0x0658(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReadyRoomNameTraceDistance;                        // 0x065C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FriendlyNameTraceDistanceAiming;                   // 0x0660(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FriendlyNameTraceDistanceNormal;                   // 0x0664(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_668[0x14];                                     // 0x0668(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionDistance;                               // 0x067C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    CurrentInteractivePrimitive;                       // 0x0680(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetInteractionComponent*            WidgetInteractionComponent;                        // 0x0688(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FreeLookMaxPitchDifference;                        // 0x0690(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeLookMaxYawDifference;                          // 0x0694(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_698[0x24];                                     // 0x0698(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastTeamKilled;                                    // 0x06BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class APlayerState*>                   TeamKillVictims;                                   // 0x06C0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D0[0x8];                                      // 0x06D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FVector& ViewLocation, const struct FRotator& ViewRotation, const struct FVector& BulletLocation, bool bCanCrack)> OnPlayerControllerBulletWarn; // 0x06D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E8[0x50];                                     // 0x06E8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class FString>              LoadoutHashMap;                                    // 0x0738(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class AGBKitInfo*>          LoadoutKitInfoMap;                                 // 0x0788(0x0050)(Protected, NativeAccessSpecifierProtected)
	class AGBCharacter*                           GBInteractedCharacter;                             // 0x07D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FVector& ViewLocation, const struct FRotator& ViewRotation, const struct FTakeHitInfo& LastTakeHitInfo)> OnPlayerControllerNotifyTakeHit; // 0x07E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName OldState, class FName NewState)> OnPlayerControllerStateChanged; // 0x07F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBPlayerController* PlayerController)> OnViewTargetChanged; // 0x0800(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_810[0x18];                                     // 0x0810(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUserWidget*>                    OverrideInputWidgets;                              // 0x0828(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_838[0x50];                                     // 0x0838(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UGBVOIPManager*                         VOIPManager;                                       // 0x0888(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGBVOIPManager>             VOIPManagerClass;                                  // 0x0890(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_898[0x8];                                      // 0x0898(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBPlayerController* PlayerController)> OnSpectatorNightVisionModeChanged; // 0x08A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B0[0x18];                                     // 0x08B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   NoUseRestrainedWidget;                             // 0x08C8(0x0028)(Edit, BlueprintVisible, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8F0[0x60];                                     // 0x08F0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBPlayerController* PlayerController)> OnLocalPlayerTagsUpdated; // 0x0950(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBPlayerController* PlayerController)> OnSpectatorShowOptionsMenu; // 0x0960(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBPlayerController* PlayerController)> OnShowTransitionScreen; // 0x0970(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_980[0x40];                                     // 0x0980(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBPlayerController* PlayerController)> OnUpdateControlBreath; // 0x09C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBPlayerController* PlayerController)> OnControlBreathExhale; // 0x09D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBPlayerController* PlayerController)> OnControlBreathInhale; // 0x09E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsEditingMission;                                 // 0x09F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9F1[0x67];                                     // 0x09F1(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGBInvItem*>                     ItemsMissingFromInventory;                         // 0x0A58(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           MovementMPC;                                       // 0x0A68(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A70[0x28];                                     // 0x0A70(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBPlayerController* PlayerController)> OnSwitchToSIE;       // 0x0A98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBPlayerController* PlayerController)> OnSwitchToPIE;       // 0x0AA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB8[0x28];                                     // 0x0AB8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class ALevelSequenceActor*                    CurrentSequencePlaying;                            // 0x0AE0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCurrentSequenceIsCutscene;                        // 0x0AE8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanAbortCurrentSequence;                          // 0x0AE9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHidePlayersDuringSequence;                        // 0x0AEA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlackOutAfterSequence;                            // 0x0AEB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AEC[0x4];                                      // 0x0AEC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   SequenceFullScreenWidget;                          // 0x0AF0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            SequenceFullScreenWidgetRef;                       // 0x0B18(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddLocalPlayerTag(class FName LocalPlayerTag);
	void AddOverrideInputWidget(class UUserWidget* UserWidget);
	void Admin(const class FString& Parameters);
	void AdminRequest(const class FName& RequestType, TDelegate<void(const struct FZKReplicatedContent& Content)> OnAdminRequestFilled);
	void AdminSet(const struct FZKReplicatedContent& Content);
	bool BP_IsFrozen();
	void BP_ReadyRoom();
	void BP_Spectate();
	void BulletWarn(class AActor* Bullet, bool bSubSonic);
	void ClearCurrentInteractivePrimitive();
	void ClientAdminReply(const struct FZKReplicatedContent& Content);
	void ClientAFKPrompt(float ReponseTime);
	void ClientBecameSpectator(const struct FVector& NewSpectatorLocation, const struct FRotator& NewSpectatorRotation);
	void ClientEnterPlayArea();
	void ClientEnterReadyRoom();
	void ClientForceCrouch();
	void ClientForceProne();
	void ClientGameMessage(class FName GameMessageId, class FName Type, float Duration, const struct FUInt64& ModID);
	void ClientInitialSync();
	void ClientMissionObjectiveStatusUpdate(const EGBMissionObjectiveStatusUpdateType StatusUpdateType, class AGBMissionObjective* MissionObjective, float FloatParam);
	void ClientOnLoadoutApplied();
	void ClientPlaySequence(const TSoftObjectPtr<class ALevelSequenceActor>& SequenceRef, const uint8 GBSequencePlayFlags);
	void ClientSendPlayerCharVoice(class AGBPlayerState* SenderPlayerState, const struct FPrimaryAssetId& SenderCharVoiceDataId, const class FName Key, bool bIsRadio);
	void ClientShowAdminMenu();
	void ClientShowMenu(const struct FSoftClassPath& MenuClassName);
	void ClientShowWorldPrompt(const struct FVector& PromptLocation, class FName Tag, float Duration, const struct FUInt64& ModID);
	void ClientStopSequencePlayback(const bool bSuppressBlackOutAfter);
	void ClientTeamKilledNotify(const class FString& TeamKillerUniqueId, const class FString& TeamKillerPlayerName, int32 PrevKills);
	void ClientTeamKillWarn(const TArray<class APlayerState*>& NewTeamKillVictims);
	void ClientTeleport();
	void CustomiseOperator();
	void DumpGameplayAbilityList();
	void EditMission();
	void FinishCanUseAttempt();
	void FlushActions();
	void ForceHideTransitionScreens();
	void Forgive();
	bool GetFailedKitValidationInfo(const class FName& LoadoutName, struct FGBKitValidationInfo* OutKitValidationInfo);
	bool GetLastTeamKillerInfo(class FString* OutLastTeamKillerUniqueId, class FString* OutLastTeamKillerPlayerName, int32* OutLastTeamKillerPrevKills);
	class UUserWidget* GetOverrideInputWidget();
	void GlobalChat();
	bool HandleCommunicationKey(const struct FKey& Key, bool bPressed);
	void HideTransitionScreenEvent(class UUserWidget* LoadingScreenUserWidget);
	void HideTransitionScreens();
	bool IsSequencePlaying();
	void LocalMissionObjectiveStatusUpdate(const EGBMissionObjectiveStatusUpdateType StatusUpdateType, class AGBMissionObjective* MissionObjective, float FloatParam);
	void Mute(class APlayerState* TargetPlayerState);
	void MuteAll();
	void MuteTalking();
	void NotAFK();
	void NotifyMovementImpulse(float ImpulseX, float ImpulseY, float ImpulseDecayRate);
	void OnAFKPromptEvent(float ReponseTime);
	void OnClientOnLoadoutAppliedEvent();
	void OnCustomiseOperatorCheatEvent();
	void OnFailedKitValidationsUpdateEvent();
	void OnHoveredWidgetChanged(class UWidgetComponent* WidgetComponent, class UWidgetComponent* PreviousWidgetComponent);
	void OnLoadoutApplied(class AGBCharacter* InGBCharacter);
	void OnMissionObjectiveStatusUpdateEvent(const EGBMissionObjectiveStatusUpdateType StatusUpdateType, class AGBMissionObjective* MissionObjective, float FloatParam);
	void OnPlayerLoadoutsUpdated(class AGBGameState* GBGameState);
	void OnPreSeamlessTravelEvent();
	void OnRestartPlayerEvent();
	void OnSequenceStopped();
	void OnShowWorldPromptEvent(const struct FVector& PromptLocation, class FName Tag, float Duration, const struct FUInt64& ModID);
	void OpenMissionEditorEvent();
	void OptOut();
	void PlayEmote(const class FString& CharEmoteString);
	void PlayerGameModeRequest(const class FString& Request);
	void PlayVoice(const class FName Key, bool bIsRadioMessage);
	void ReadyRoom();
	void ReapplyCharLoadout();
	void ReInitLoadouts();
	void RemoveLocalPlayerTag(class FName LocalPlayerTag);
	void RemoveOverrideInputWidget(class UUserWidget* UserWidget);
	void Report();
	void ResetFOV();
	void RestartPlayer();
	void Say(const class FString& Msg);
	void SayTeam(const class FString& Msg);
	void ServerAdmin(const class FString& Parameters);
	void ServerAdminRequest(const class FName& RequestType);
	void ServerAdminSet(const struct FZKReplicatedContent& Content);
	void ServerCheat(const class FString& Msg);
	void ServerConfirmBulletCharacterImpact(class AGBCharacter* HitCharacter, const struct FGBOrganDamageEvent& OrganDamageEvent);
	void ServerCreateLoadoutInfo(const struct FGBReplicatedString& ReplicatedLoadout);
	void ServerEnterPlayArea();
	void ServerEnterReadyRoom();
	void ServerFinishTeleport();
	void ServerForgive();
	void ServerInitialSync();
	void ServerOptOut();
	void ServerPlayEmote(const struct FPrimaryAssetId& CharEmoteId);
	void ServerPlayerGameModeRequest(const class FString& Request);
	void ServerPlaySequence(const TSoftObjectPtr<class ALevelSequenceActor>& SequenceRef, const bool bIsCutscene, const bool bCanAbort, const bool bResetActors, const bool bHidePlayers, const bool bBlackoutAfter);
	void ServerPlayVoice(const class FName& Key, bool bIsRadioMessage);
	void ServerReapplyCharLoadout();
	void ServerReport();
	void ServerSay(const class FString& Msg);
	void ServerSayTeam(const class FString& Msg);
	void ServerSendAFKReponse();
	void ServerSetCallSign(const class FString& NewCallSign, bool bNewUseElementCallSign);
	void ServerSetCharVoiceDataId(const struct FPrimaryAssetId& CharVoiceDataId);
	void ServerSetCustomiseOperatorCheat(bool bEnabled);
	void ServerSetInsertionPoint(class AGBInsertionPoint* NewInsertionPoint);
	void ServerSetReadyStatus(const EReadyStatus& NewReadyStatus);
	void ServerSetTeamElement(const ETeamElement& NewTeamElement);
	void ServerSpectate();
	void ServerUseActor(class AActor* UseTarget, const class FName& UseType, bool bMustSucceed);
	void ServerUseActorWithParams(class AActor* UseTarget, const class FName& UseType, const class FString& Params_0, bool bMustSucceed);
	void ServerVote(const class FString& Parameters);
	void SetCustomiseOperatorCheat(bool bEnabled);
	void SetInsertionPoint(class AGBInsertionPoint* NewInsertionPoint);
	void SetIsEditingMission(bool bNewIsEditingMission);
	void SetLastDesiredOffTargetAlphaValue(float NewLastDesiredOffTargetAlphaValue);
	void SetLoadout(const class FName& LoadoutName, class UVaRestJsonObject* KitJsonObj);
	void SetMPCGlobalDecayRate(float GlobalDecayRate);
	void SetReadyStatus(EReadyStatus NewReadyStatus);
	void SetSpectatorNightVisionMode(class FName NewNightVisionMode);
	void SetTargetInputSensitivityScale(float NewScale);
	void SetTeamElement(ETeamElement NewTeamElement);
	void SetViewRotation(const struct FRotator& NewRotation);
	void ShowAdminMenuEvent();
	void ShowTransitionScreen(class FName TransitionType);
	void ShowTransitionScreenEvent(class FName TransitionType);
	void Spectate();
	void TeamChat();
	void ToggleInGameMenu();
	void TriggerSequencePlayback(const TSoftObjectPtr<class ALevelSequenceActor>& LevelSequenceActor, const bool bIsCutscene, const bool bCanAbort, const bool bHidePlayers, const bool bBlackoutAfter);
	void UnMute(class APlayerState* TargetPlayerState);
	void UnMuteAll();
	void UpdateMovementMaterialCollection(const struct FRotator& DeltaRot, float DeltaTime);
	void UseActor(class AActor* UseTarget, class FName UseType, bool bMustSucceed);
	void UseActorWithParams(class AActor* UseTarget, class FName UseType, const class FString& Params_0, bool bMustSucceed);
	void Vote(const class FString& Parameters);

	bool CanUseActor(const class AActor* UseTarget, bool bMustSucceed) const;
	void CreateBlackOutEvent(const bool bFadeIn) const;
	float FrozenTimeLeft() const;
	class FName GetCameraStyle() const;
	float GetEyeBias() const;
	TArray<struct FGBKitValidationInfo> GetFailedKitValidations() const;
	bool GetFluidStance() const;
	int32 GetFPS() const;
	class AGBCharacter* GetGBCharacter() const;
	class AGBHUD* GetGBHUD() const;
	float GetHeadMovementAmount() const;
	float GetLastDesiredOffTargetAlphaValue() const;
	class AGBKitInfo* GetLoadoutInfo(const class FName& LoadoutName) const;
	void GetNetInfo(int32* Ping, float* InKiloBytesPerSecond, int32* InPacketsPerSecond, int32* InLossPercentage, float* OutKiloBytesPerSecond, int32* OutPacketsPerSecond, int32* OutLossPercentage) const;
	float GetPlayerFOV() const;
	class ALevelSequenceActor* GetPlayingSequenceInfo(float* OutTime, float* OutTimeLeft, float* OutDuration, bool* bOutIsCutscene, bool* bOutCanAbort) const;
	float GetPredictionTime() const;
	bool GetSharedTraceBlockingHit() const;
	TArray<struct FHitResult> GetSharedTraceResults() const;
	class FName GetSpectatorNightVisionMode() const;
	float GetTargetInputSensitivityScale() const;
	TArray<class APlayerState*> GetTeamKillVictims() const;
	struct FRotator GetViewRotation() const;
	class UWidgetInteractionComponent* GetWidgetInteractionComponent() const;
	bool HasFailedKitValidations() const;
	bool HasLocalPlayerTag(class FName LocalPlayerTag) const;
	bool IsAlive() const;
	bool IsEditingMission() const;
	bool IsFirstPerson() const;
	bool IsMuted(const class APlayerState* TargetPlayerState) const;
	bool IsTalking() const;
	bool IsUsingGamepad() const;
	bool IsUsingRadio() const;
	void RemoveBlackOutEvent(const bool bFadeOut) const;
	bool ShowUsagePrompts() const;
	bool SpectatorIsFollowing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPlayerController">();
	}
	static class AGBPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBPlayerController>();
	}
};
static_assert(alignof(AGBPlayerController) == 0x000008, "Wrong alignment on AGBPlayerController");
static_assert(sizeof(AGBPlayerController) == 0x000B20, "Wrong size on AGBPlayerController");
static_assert(offsetof(AGBPlayerController, ServerViewTarget) == 0x0005B0, "Member 'AGBPlayerController::ServerViewTarget' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, TargetControlRotation) == 0x0005B8, "Member 'AGBPlayerController::TargetControlRotation' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, GBCharacter) == 0x0005D0, "Member 'AGBPlayerController::GBCharacter' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, GBPlayerInput) == 0x0005D8, "Member 'AGBPlayerController::GBPlayerInput' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, GBPlayerState) == 0x0005E0, "Member 'AGBPlayerController::GBPlayerState' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, DialogWidgetClass) == 0x000630, "Member 'AGBPlayerController::DialogWidgetClass' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, DialogDefaultSelfDestructTime) == 0x000638, "Member 'AGBPlayerController::DialogDefaultSelfDestructTime' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, BaseTurnRate) == 0x00063C, "Member 'AGBPlayerController::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, BaseLookUpRate) == 0x000640, "Member 'AGBPlayerController::BaseLookUpRate' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, MaxTurnRate) == 0x000644, "Member 'AGBPlayerController::MaxTurnRate' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, MaxProneTurnRate) == 0x000648, "Member 'AGBPlayerController::MaxProneTurnRate' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, MaxProneCrawlTurnRate) == 0x00064C, "Member 'AGBPlayerController::MaxProneCrawlTurnRate' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, MaxSprintTurnRate) == 0x000650, "Member 'AGBPlayerController::MaxSprintTurnRate' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, ResetFreeLookInterpSpeed) == 0x000654, "Member 'AGBPlayerController::ResetFreeLookInterpSpeed' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, ReadyRoomNameTraceDistance) == 0x00065C, "Member 'AGBPlayerController::ReadyRoomNameTraceDistance' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, FriendlyNameTraceDistanceAiming) == 0x000660, "Member 'AGBPlayerController::FriendlyNameTraceDistanceAiming' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, FriendlyNameTraceDistanceNormal) == 0x000664, "Member 'AGBPlayerController::FriendlyNameTraceDistanceNormal' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, InteractionDistance) == 0x00067C, "Member 'AGBPlayerController::InteractionDistance' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, CurrentInteractivePrimitive) == 0x000680, "Member 'AGBPlayerController::CurrentInteractivePrimitive' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, WidgetInteractionComponent) == 0x000688, "Member 'AGBPlayerController::WidgetInteractionComponent' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, FreeLookMaxPitchDifference) == 0x000690, "Member 'AGBPlayerController::FreeLookMaxPitchDifference' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, FreeLookMaxYawDifference) == 0x000694, "Member 'AGBPlayerController::FreeLookMaxYawDifference' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, LastTeamKilled) == 0x0006BC, "Member 'AGBPlayerController::LastTeamKilled' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, TeamKillVictims) == 0x0006C0, "Member 'AGBPlayerController::TeamKillVictims' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, OnPlayerControllerBulletWarn) == 0x0006D8, "Member 'AGBPlayerController::OnPlayerControllerBulletWarn' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, LoadoutHashMap) == 0x000738, "Member 'AGBPlayerController::LoadoutHashMap' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, LoadoutKitInfoMap) == 0x000788, "Member 'AGBPlayerController::LoadoutKitInfoMap' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, GBInteractedCharacter) == 0x0007D8, "Member 'AGBPlayerController::GBInteractedCharacter' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, OnPlayerControllerNotifyTakeHit) == 0x0007E0, "Member 'AGBPlayerController::OnPlayerControllerNotifyTakeHit' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, OnPlayerControllerStateChanged) == 0x0007F0, "Member 'AGBPlayerController::OnPlayerControllerStateChanged' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, OnViewTargetChanged) == 0x000800, "Member 'AGBPlayerController::OnViewTargetChanged' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, OverrideInputWidgets) == 0x000828, "Member 'AGBPlayerController::OverrideInputWidgets' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, VOIPManager) == 0x000888, "Member 'AGBPlayerController::VOIPManager' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, VOIPManagerClass) == 0x000890, "Member 'AGBPlayerController::VOIPManagerClass' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, OnSpectatorNightVisionModeChanged) == 0x0008A0, "Member 'AGBPlayerController::OnSpectatorNightVisionModeChanged' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, NoUseRestrainedWidget) == 0x0008C8, "Member 'AGBPlayerController::NoUseRestrainedWidget' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, OnLocalPlayerTagsUpdated) == 0x000950, "Member 'AGBPlayerController::OnLocalPlayerTagsUpdated' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, OnSpectatorShowOptionsMenu) == 0x000960, "Member 'AGBPlayerController::OnSpectatorShowOptionsMenu' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, OnShowTransitionScreen) == 0x000970, "Member 'AGBPlayerController::OnShowTransitionScreen' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, OnUpdateControlBreath) == 0x0009C0, "Member 'AGBPlayerController::OnUpdateControlBreath' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, OnControlBreathExhale) == 0x0009D0, "Member 'AGBPlayerController::OnControlBreathExhale' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, OnControlBreathInhale) == 0x0009E0, "Member 'AGBPlayerController::OnControlBreathInhale' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, bIsEditingMission) == 0x0009F0, "Member 'AGBPlayerController::bIsEditingMission' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, ItemsMissingFromInventory) == 0x000A58, "Member 'AGBPlayerController::ItemsMissingFromInventory' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, MovementMPC) == 0x000A68, "Member 'AGBPlayerController::MovementMPC' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, OnSwitchToSIE) == 0x000A98, "Member 'AGBPlayerController::OnSwitchToSIE' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, OnSwitchToPIE) == 0x000AA8, "Member 'AGBPlayerController::OnSwitchToPIE' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, CurrentSequencePlaying) == 0x000AE0, "Member 'AGBPlayerController::CurrentSequencePlaying' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, bCurrentSequenceIsCutscene) == 0x000AE8, "Member 'AGBPlayerController::bCurrentSequenceIsCutscene' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, bCanAbortCurrentSequence) == 0x000AE9, "Member 'AGBPlayerController::bCanAbortCurrentSequence' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, bHidePlayersDuringSequence) == 0x000AEA, "Member 'AGBPlayerController::bHidePlayersDuringSequence' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, bBlackOutAfterSequence) == 0x000AEB, "Member 'AGBPlayerController::bBlackOutAfterSequence' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, SequenceFullScreenWidget) == 0x000AF0, "Member 'AGBPlayerController::SequenceFullScreenWidget' has a wrong offset!");
static_assert(offsetof(AGBPlayerController, SequenceFullScreenWidgetRef) == 0x000B18, "Member 'AGBPlayerController::SequenceFullScreenWidgetRef' has a wrong offset!");

// Class GroundBranch.GBCheatManager
// 0x0000 (0x0088 - 0x0088)
class UGBCheatManager final : public UCheatManager
{
public:
	void BugItGoMantis(const class FString& CameraString);
	void DebugGameCommand(const class FString& Parameters);
	void InfAmmo();
	void KillAll();
	void KillAllEnemies();
	void KillEveryoneElse();
	void LoadPlayArea();
	void LoadReadyRoom();
	void NoRecoil();
	void NoSway();
	void NoTarget();
	void RunMissionScript(const class FString& ScriptName);
	void SaveKitForBot(const class FString& TeamName, const class FString& BotName);
	void SetCharVoiceId(const class FString& CharVoiceIdAsString);
	void SetKit(const class FString& KitName);
	void SetTeamElement(uint8 TeamElement);
	void SetTeamId(uint8 TeamId);
	void SetWaterLevel(int32 InWaterLevel);
	void ZeroSightTo(int32 NewZeroDistance);

	void TeleportAIToMe() const;
	void TeleportBotsToMe() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBCheatManager">();
	}
	static class UGBCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBCheatManager>();
	}
};
static_assert(alignof(UGBCheatManager) == 0x000008, "Wrong alignment on UGBCheatManager");
static_assert(sizeof(UGBCheatManager) == 0x000088, "Wrong size on UGBCheatManager");

// Class GroundBranch.GBClimatePreset
// 0x0060 (0x0090 - 0x0030)
class UGBClimatePreset final : public UDataAsset
{
public:
	class FName                                   Name_0;                                            // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FGBSeasonalWeather>             SpringWeather;                                     // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGBSeasonalWeather>             SummerWeather;                                     // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGBSeasonalWeather>             AutumnWeather;                                     // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGBSeasonalWeather>             WinterWeather;                                     // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static void GetWeatherPresetProperties(const class USkyCreatorWeatherPreset* SelectedWeatherPreset, class FName* OutWeatherCategory, class FName* OutWeatherType, class FText* OutWeatherDescription);

	TArray<class USkyCreatorWeatherPreset*> GetAllWeatherPresets(bool bAllSeasons, ESeason SelectedSeason) const;
	struct FGBClimateSettings GetClimateSettings() const;
	TArray<class USkyCreatorWeatherPreset*> GetWeatherPresetsForSeason(ESeason SelectedSeason) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBClimatePreset">();
	}
	static class UGBClimatePreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBClimatePreset>();
	}
};
static_assert(alignof(UGBClimatePreset) == 0x000008, "Wrong alignment on UGBClimatePreset");
static_assert(sizeof(UGBClimatePreset) == 0x000090, "Wrong size on UGBClimatePreset");
static_assert(offsetof(UGBClimatePreset, Name_0) == 0x000030, "Member 'UGBClimatePreset::Name_0' has a wrong offset!");
static_assert(offsetof(UGBClimatePreset, Description) == 0x000038, "Member 'UGBClimatePreset::Description' has a wrong offset!");
static_assert(offsetof(UGBClimatePreset, SpringWeather) == 0x000050, "Member 'UGBClimatePreset::SpringWeather' has a wrong offset!");
static_assert(offsetof(UGBClimatePreset, SummerWeather) == 0x000060, "Member 'UGBClimatePreset::SummerWeather' has a wrong offset!");
static_assert(offsetof(UGBClimatePreset, AutumnWeather) == 0x000070, "Member 'UGBClimatePreset::AutumnWeather' has a wrong offset!");
static_assert(offsetof(UGBClimatePreset, WinterWeather) == 0x000080, "Member 'UGBClimatePreset::WinterWeather' has a wrong offset!");

// Class GroundBranch.GBClothing
// 0x0038 (0x0480 - 0x0448)
class AGBClothing : public AGBInvItem
{
public:
	class USkeletalMeshComponent*                 ClothingMeshComponent;                             // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseAttachParentBound;                             // 0x0450(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_451[0x7];                                      // 0x0451(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WoundParameterName;                                // 0x0458(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           WoundBoneList;                                     // 0x0470(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void OnLoadMeshComplete();
	void OnTakeHit(const class FName& RefBoneName, const struct FVector& RefPosPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBClothing">();
	}
	static class AGBClothing* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBClothing>();
	}
};
static_assert(alignof(AGBClothing) == 0x000008, "Wrong alignment on AGBClothing");
static_assert(sizeof(AGBClothing) == 0x000480, "Wrong size on AGBClothing");
static_assert(offsetof(AGBClothing, ClothingMeshComponent) == 0x000448, "Member 'AGBClothing::ClothingMeshComponent' has a wrong offset!");
static_assert(offsetof(AGBClothing, bUseAttachParentBound) == 0x000450, "Member 'AGBClothing::bUseAttachParentBound' has a wrong offset!");
static_assert(offsetof(AGBClothing, WoundParameterName) == 0x000458, "Member 'AGBClothing::WoundParameterName' has a wrong offset!");
static_assert(offsetof(AGBClothing, WoundBoneList) == 0x000470, "Member 'AGBClothing::WoundBoneList' has a wrong offset!");

// Class GroundBranch.GBSmartTriggerVolumeBase
// 0x0000 (0x0258 - 0x0258)
class AGBSmartTriggerVolumeBase : public AVolume
{
public:
	void LocalPawnEnteredVolume(class APawn* OtherPawn);
	void LocalPawnLeavingVolume(class APawn* OtherPawn);
	void ServerPawnEnteredVolume(class APawn* OtherPawn);
	void ServerPawnLeavingVolume(class APawn* OtherPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBSmartTriggerVolumeBase">();
	}
	static class AGBSmartTriggerVolumeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBSmartTriggerVolumeBase>();
	}
};
static_assert(alignof(AGBSmartTriggerVolumeBase) == 0x000008, "Wrong alignment on AGBSmartTriggerVolumeBase");
static_assert(sizeof(AGBSmartTriggerVolumeBase) == 0x000258, "Wrong size on AGBSmartTriggerVolumeBase");

// Class GroundBranch.GBColourBlindnessCameraModifier
// 0x00C0 (0x0108 - 0x0048)
class UGBColourBlindnessCameraModifier : public UGBCameraModifier
{
public:
	class UTexture*                               ColourBlindLUT;                                    // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, TSoftObjectPtr<class UTexture>> ColourBlindLUTs;                               // 0x0058(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class FName, struct FLinearColor>        RedElementAlternateColours;                        // 0x00A8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           AccessibilityMPC;                                  // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RedElementAlternateColourParamName;                // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyPlayerSettings(class UGBPlayerSettings* PlayerSettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBColourBlindnessCameraModifier">();
	}
	static class UGBColourBlindnessCameraModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBColourBlindnessCameraModifier>();
	}
};
static_assert(alignof(UGBColourBlindnessCameraModifier) == 0x000008, "Wrong alignment on UGBColourBlindnessCameraModifier");
static_assert(sizeof(UGBColourBlindnessCameraModifier) == 0x000108, "Wrong size on UGBColourBlindnessCameraModifier");
static_assert(offsetof(UGBColourBlindnessCameraModifier, ColourBlindLUT) == 0x000048, "Member 'UGBColourBlindnessCameraModifier::ColourBlindLUT' has a wrong offset!");
static_assert(offsetof(UGBColourBlindnessCameraModifier, ColourBlindLUTs) == 0x000058, "Member 'UGBColourBlindnessCameraModifier::ColourBlindLUTs' has a wrong offset!");
static_assert(offsetof(UGBColourBlindnessCameraModifier, RedElementAlternateColours) == 0x0000A8, "Member 'UGBColourBlindnessCameraModifier::RedElementAlternateColours' has a wrong offset!");
static_assert(offsetof(UGBColourBlindnessCameraModifier, AccessibilityMPC) == 0x0000F8, "Member 'UGBColourBlindnessCameraModifier::AccessibilityMPC' has a wrong offset!");
static_assert(offsetof(UGBColourBlindnessCameraModifier, RedElementAlternateColourParamName) == 0x000100, "Member 'UGBColourBlindnessCameraModifier::RedElementAlternateColourParamName' has a wrong offset!");

// Class GroundBranch.GBCrowdFollowingComponent
// 0x0000 (0x0298 - 0x0298)
class UGBCrowdFollowingComponent final : public UCrowdFollowingComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBCrowdFollowingComponent">();
	}
	static class UGBCrowdFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBCrowdFollowingComponent>();
	}
};
static_assert(alignof(UGBCrowdFollowingComponent) == 0x000008, "Wrong alignment on UGBCrowdFollowingComponent");
static_assert(sizeof(UGBCrowdFollowingComponent) == 0x000298, "Wrong size on UGBCrowdFollowingComponent");

// Class GroundBranch.GBPhysicalMaterial
// 0x0020 (0x00A0 - 0x0080)
class UGBPhysicalMaterial final : public UPhysicalMaterial
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0080(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPhysicalMaterial">();
	}
	static class UGBPhysicalMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBPhysicalMaterial>();
	}
};
static_assert(alignof(UGBPhysicalMaterial) == 0x000008, "Wrong alignment on UGBPhysicalMaterial");
static_assert(sizeof(UGBPhysicalMaterial) == 0x0000A0, "Wrong size on UGBPhysicalMaterial");
static_assert(offsetof(UGBPhysicalMaterial, Tags) == 0x000080, "Member 'UGBPhysicalMaterial::Tags' has a wrong offset!");

// Class GroundBranch.GBCustomListView
// 0x04D0 (0x0838 - 0x0368)
class UGBCustomListView final : public UListView
{
public:
	struct FScrollBarStyle                        WidgetBarStyle;                                    // 0x0368(0x04D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBCustomListView">();
	}
	static class UGBCustomListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBCustomListView>();
	}
};
static_assert(alignof(UGBCustomListView) == 0x000008, "Wrong alignment on UGBCustomListView");
static_assert(sizeof(UGBCustomListView) == 0x000838, "Wrong size on UGBCustomListView");
static_assert(offsetof(UGBCustomListView, WidgetBarStyle) == 0x000368, "Member 'UGBCustomListView::WidgetBarStyle' has a wrong offset!");

// Class GroundBranch.GBLuaStaticsLibrary
// 0x0000 (0x0028 - 0x0028)
class UGBLuaStaticsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FLuaValue ActorsToLuaTable(class UObject* WorldContextObject, TSubclassOf<class ULuaState> LuaStateClass, const TArray<class AActor*>& Actors);
	static struct FLuaValue BuildRotator(const class ULuaBlueprintPackage* LuaBlueprintPackage, const struct FRotator& Rotator);
	static struct FLuaValue BuildVector(const class ULuaBlueprintPackage* LuaBlueprintPackage, const struct FVector& Vector);
	static TArray<struct FLuaValue> GetArgsFromSingle(const struct FLuaValue& InArg);
	static TArray<struct FLuaValue> GetEmptyArgs();
	static struct FRotator LuaTableToRotator(const struct FLuaValue& InValue);
	static class AGBCharacter* LuaValueToCharacter(class UObject* WorldContextObject, const struct FLuaValue& InValue);
	static class AGBPlayerController* LuaValueToPlayerController(class UObject* WorldContextObject, const struct FLuaValue& InValue);
	static class AGBPlayerState* LuaValueToPlayerState(class UObject* WorldContextObject, const struct FLuaValue& InValue);
	static struct FLuaValue LuaValueToScript(const struct FLuaValue& InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLuaStaticsLibrary">();
	}
	static class UGBLuaStaticsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBLuaStaticsLibrary>();
	}
};
static_assert(alignof(UGBLuaStaticsLibrary) == 0x000008, "Wrong alignment on UGBLuaStaticsLibrary");
static_assert(sizeof(UGBLuaStaticsLibrary) == 0x000028, "Wrong size on UGBLuaStaticsLibrary");

// Class GroundBranch.GBCustomTileView
// 0x04D0 (0x0858 - 0x0388)
class UGBCustomTileView final : public UTileView
{
public:
	struct FScrollBarStyle                        WidgetBarStyle;                                    // 0x0388(0x04D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBCustomTileView">();
	}
	static class UGBCustomTileView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBCustomTileView>();
	}
};
static_assert(alignof(UGBCustomTileView) == 0x000008, "Wrong alignment on UGBCustomTileView");
static_assert(sizeof(UGBCustomTileView) == 0x000858, "Wrong size on UGBCustomTileView");
static_assert(offsetof(UGBCustomTileView, WidgetBarStyle) == 0x000388, "Member 'UGBCustomTileView::WidgetBarStyle' has a wrong offset!");

// Class GroundBranch.GBDebugCameraController
// 0x0010 (0x0680 - 0x0670)
class AGBDebugCameraController final : public ADebugCameraController
{
public:
	uint8                                         Pad_670[0x8];                                      // 0x0670(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPostProcessComponent*                  DebugCameraPostProcessComponent;                   // 0x0678(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBDebugCameraController">();
	}
	static class AGBDebugCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBDebugCameraController>();
	}
};
static_assert(alignof(AGBDebugCameraController) == 0x000008, "Wrong alignment on AGBDebugCameraController");
static_assert(sizeof(AGBDebugCameraController) == 0x000680, "Wrong size on AGBDebugCameraController");
static_assert(offsetof(AGBDebugCameraController, DebugCameraPostProcessComponent) == 0x000678, "Member 'AGBDebugCameraController::DebugCameraPostProcessComponent' has a wrong offset!");

// Class GroundBranch.GBObjectiveMarker
// 0x0078 (0x0298 - 0x0220)
class AGBObjectiveMarker final : public AActor
{
public:
	uint8                                         Pad_220[0x18];                                     // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBObjectiveMarker* Objective)> OnObjectiveUpdate;           // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USphereComponent*                       SphereComp;                                        // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBillboardComponent*                    SpriteComp;                                        // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             SpriteExtraction;                                  // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             SpriteMissionLocation;                             // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ObjectiveName;                                     // 0x0268(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         TeamId;                                            // 0x0270(0x0001)(Edit, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsActive : 1;                                     // 0x0271(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_272[0x2];                                      // 0x0272(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ObjectiveMarkerType;                               // 0x0274(0x0008)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ObjectiveMarkerSize;                               // 0x027C(0x0008)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           CustomDetailWidgets;                               // 0x0288(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void ObjectiveUpdated();
	void SetObjectiveMarkerSize(const struct FVector2D& NewObjectiveMarkerSize);
	void SetObjectiveMarkerType(const class FName NewObjectiveMarkerType);
	void SetObjectiveName(class FName Value);
	void UpdateObjectiveSprite();

	struct FVector2D GetObjectiveMarkerSize() const;
	class FName GetObjectiveMarkerType() const;
	class FName GetObjectiveName() const;
	class UTexture2D* GetObjectiveSprite() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBObjectiveMarker">();
	}
	static class AGBObjectiveMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBObjectiveMarker>();
	}
};
static_assert(alignof(AGBObjectiveMarker) == 0x000008, "Wrong alignment on AGBObjectiveMarker");
static_assert(sizeof(AGBObjectiveMarker) == 0x000298, "Wrong size on AGBObjectiveMarker");
static_assert(offsetof(AGBObjectiveMarker, OnObjectiveUpdate) == 0x000238, "Member 'AGBObjectiveMarker::OnObjectiveUpdate' has a wrong offset!");
static_assert(offsetof(AGBObjectiveMarker, SphereComp) == 0x000248, "Member 'AGBObjectiveMarker::SphereComp' has a wrong offset!");
static_assert(offsetof(AGBObjectiveMarker, SpriteComp) == 0x000250, "Member 'AGBObjectiveMarker::SpriteComp' has a wrong offset!");
static_assert(offsetof(AGBObjectiveMarker, SpriteExtraction) == 0x000258, "Member 'AGBObjectiveMarker::SpriteExtraction' has a wrong offset!");
static_assert(offsetof(AGBObjectiveMarker, SpriteMissionLocation) == 0x000260, "Member 'AGBObjectiveMarker::SpriteMissionLocation' has a wrong offset!");
static_assert(offsetof(AGBObjectiveMarker, ObjectiveName) == 0x000268, "Member 'AGBObjectiveMarker::ObjectiveName' has a wrong offset!");
static_assert(offsetof(AGBObjectiveMarker, TeamId) == 0x000270, "Member 'AGBObjectiveMarker::TeamId' has a wrong offset!");
static_assert(offsetof(AGBObjectiveMarker, ObjectiveMarkerType) == 0x000274, "Member 'AGBObjectiveMarker::ObjectiveMarkerType' has a wrong offset!");
static_assert(offsetof(AGBObjectiveMarker, ObjectiveMarkerSize) == 0x00027C, "Member 'AGBObjectiveMarker::ObjectiveMarkerSize' has a wrong offset!");
static_assert(offsetof(AGBObjectiveMarker, CustomDetailWidgets) == 0x000288, "Member 'AGBObjectiveMarker::CustomDetailWidgets' has a wrong offset!");

// Class GroundBranch.GBDialogWidget
// 0x0060 (0x02C0 - 0x0260)
class UGBDialogWidget : public UUserWidget
{
public:
	class FName                                   DialogName;                                        // 0x0260(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   Title;                                             // 0x0268(0x0018)(BlueprintVisible, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	class FText                                   Message;                                           // 0x0280(0x0018)(BlueprintVisible, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	EGBMessageDialogType                          MessageDialogType;                                 // 0x0298(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x27];                                     // 0x0299(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyCancelClicked();
	void NotifyOkClicked();
	void SetDialogName(const class FName& InDialogName);
	void SetMessage(const class FText& InMessage);
	void SetMessageDialogType(const EGBMessageDialogType InMessageDialogType);
	void SetTerminationTime(const float SecondsBeforeKill);
	void SetTitle(const class FText& InTitle);
	void UpdateDisplayFieldsEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBDialogWidget">();
	}
	static class UGBDialogWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBDialogWidget>();
	}
};
static_assert(alignof(UGBDialogWidget) == 0x000008, "Wrong alignment on UGBDialogWidget");
static_assert(sizeof(UGBDialogWidget) == 0x0002C0, "Wrong size on UGBDialogWidget");
static_assert(offsetof(UGBDialogWidget, DialogName) == 0x000260, "Member 'UGBDialogWidget::DialogName' has a wrong offset!");
static_assert(offsetof(UGBDialogWidget, Title) == 0x000268, "Member 'UGBDialogWidget::Title' has a wrong offset!");
static_assert(offsetof(UGBDialogWidget, Message) == 0x000280, "Member 'UGBDialogWidget::Message' has a wrong offset!");
static_assert(offsetof(UGBDialogWidget, MessageDialogType) == 0x000298, "Member 'UGBDialogWidget::MessageDialogType' has a wrong offset!");

// Class GroundBranch.GBDirectionalSunlight
// 0x0010 (0x0240 - 0x0230)
class AGBDirectionalSunlight final : public ADirectionalLight
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetLightSourceAngle(float NewSourceAngle);
	void UpdateCloudScatteredLuminance(const struct FLinearColor& NewScale);

	struct FLinearColor GetSavedCloudScatteredLuminance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBDirectionalSunlight">();
	}
	static class AGBDirectionalSunlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBDirectionalSunlight>();
	}
};
static_assert(alignof(AGBDirectionalSunlight) == 0x000008, "Wrong alignment on AGBDirectionalSunlight");
static_assert(sizeof(AGBDirectionalSunlight) == 0x000240, "Wrong size on AGBDirectionalSunlight");

// Class GroundBranch.GBMuzzleDevice
// 0x0020 (0x0468 - 0x0448)
class AGBMuzzleDevice : public AGBInvItem
{
public:
	class FName                                   SuppressorSwitchValue;                             // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LightLevelKey;                                     // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightLevelAlpha;                                   // 0x0458(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightLevelTime;                                    // 0x045C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AudioSignalRadius;                                 // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_464[0x4];                                      // 0x0464(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetAudioSignalRadius() const;
	class FName GetMuzzleDeviceThread() const;
	class FName GetSuppressorSwitchValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBMuzzleDevice">();
	}
	static class AGBMuzzleDevice* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBMuzzleDevice>();
	}
};
static_assert(alignof(AGBMuzzleDevice) == 0x000008, "Wrong alignment on AGBMuzzleDevice");
static_assert(sizeof(AGBMuzzleDevice) == 0x000468, "Wrong size on AGBMuzzleDevice");
static_assert(offsetof(AGBMuzzleDevice, SuppressorSwitchValue) == 0x000448, "Member 'AGBMuzzleDevice::SuppressorSwitchValue' has a wrong offset!");
static_assert(offsetof(AGBMuzzleDevice, LightLevelKey) == 0x000450, "Member 'AGBMuzzleDevice::LightLevelKey' has a wrong offset!");
static_assert(offsetof(AGBMuzzleDevice, LightLevelAlpha) == 0x000458, "Member 'AGBMuzzleDevice::LightLevelAlpha' has a wrong offset!");
static_assert(offsetof(AGBMuzzleDevice, LightLevelTime) == 0x00045C, "Member 'AGBMuzzleDevice::LightLevelTime' has a wrong offset!");
static_assert(offsetof(AGBMuzzleDevice, AudioSignalRadius) == 0x000460, "Member 'AGBMuzzleDevice::AudioSignalRadius' has a wrong offset!");

// Class GroundBranch.GBDoorSwinging
// 0x0168 (0x0388 - 0x0220)
class AGBDoorSwinging : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   DoorMeshComp;                                      // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicsConstraintComponent*            PhysicsConstraintComp;                             // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          DoorWayAcousticsObstacle;                          // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   InteractionWidget;                                 // 0x0240(0x0028)(Edit, BlueprintVisible, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           GameplayAbilityClasses;                            // 0x0268(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	EGBDoorSwingDirection                         SwingDirection;                                    // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDestructionDamage;                              // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            AcousticPortalScalingCurve;                        // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                AcousticPortalOriginalScaleVector;                 // 0x0288(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0x1C];                                     // 0x0294(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxYaw;                                            // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialYaw;                                        // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConsideredOpenYaw;                                 // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBDoorSwinging*                        AdjoiningDoor;                                     // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGBAdjoiningDoorBehaviour                     AdjoiningDoorBehaviour;                            // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAIAlwaysMirrorAdjoiningDoorUsage;                 // 0x02C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CA[0x6];                                      // 0x02CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBDoorSwinging* SwingingDoor)> OnOpening;                   // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBDoorSwinging* SwingingDoor)> OnClosing;                   // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBDoorSwinging* SwingingDoor)> OnStartedMoving;             // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBDoorSwinging* SwingingDoor)> OnStoppedMoving;             // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGBReplicatedSwing                     ReplicatedSwing;                                   // 0x0310(0x000C)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_31C[0x24];                                     // 0x031C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AAkAcousticPortal>       AcousticPortalSoftRef;                             // 0x0340(0x0028)(Edit, BlueprintVisible, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDoorDestroyed : 1;                                // 0x0370(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_371[0x17];                                     // 0x0371(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableDoorCompPhysics();
	void NetMulticastDestroyDoor(const struct FVector_NetQuantize10& DamageOrigin, const struct FVector_NetQuantizeNormal& DamageDir);
	void NetMulticastUpdateYaw(const struct FGBReplicatedSwing& Swing);
	void OnAdjoiningDoorClosing(class AGBDoorSwinging* OtherDoor);
	void OnAdjoiningDoorOpening(class AGBDoorSwinging* OtherDoor);
	void OnDoorDestroyedEvent(const struct FVector& DamageOrigin, const struct FVector& DamageDir);
	void OnPhysicsCollision(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnRep_DoorDestroyed(bool bLastDoorDestroyed);
	void OnRep_ReplicatedSwing();
	void ResetAngularDamping();
	void SetAdjoiningDoor(class AGBDoorSwinging* NewAdjoiningDoor);
	void SetAdjoiningDoorBehaviour(EGBAdjoiningDoorBehaviour NewAdjoiningDoorBehaviour);
	void SetDoorYawAngle(float NewYawAngle);
	void SetDoorYawSpeed(float NewYawSpeed);
	void SetupDoor();
	void UpdateAcousticPortal();
	void UpdateAcousticPortalInternal();

	EGBPlayerRelativeSwingDir GetControllerRelativeSwingDir(const class AController* Controller) const;
	struct FVector GetDoorScale() const;
	float GetDoorYawAngle() const;
	float GetDoorYawSpeed() const;
	bool IsClosed() const;
	bool IsClosing() const;
	bool IsDestroyed() const;
	bool IsOpenedEnoughForAIToUse() const;
	bool IsOpening() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBDoorSwinging">();
	}
	static class AGBDoorSwinging* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBDoorSwinging>();
	}
};
static_assert(alignof(AGBDoorSwinging) == 0x000008, "Wrong alignment on AGBDoorSwinging");
static_assert(sizeof(AGBDoorSwinging) == 0x000388, "Wrong size on AGBDoorSwinging");
static_assert(offsetof(AGBDoorSwinging, DoorMeshComp) == 0x000228, "Member 'AGBDoorSwinging::DoorMeshComp' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, PhysicsConstraintComp) == 0x000230, "Member 'AGBDoorSwinging::PhysicsConstraintComp' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, DoorWayAcousticsObstacle) == 0x000238, "Member 'AGBDoorSwinging::DoorWayAcousticsObstacle' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, InteractionWidget) == 0x000240, "Member 'AGBDoorSwinging::InteractionWidget' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, GameplayAbilityClasses) == 0x000268, "Member 'AGBDoorSwinging::GameplayAbilityClasses' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, SwingDirection) == 0x000278, "Member 'AGBDoorSwinging::SwingDirection' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, MinDestructionDamage) == 0x00027C, "Member 'AGBDoorSwinging::MinDestructionDamage' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, AcousticPortalScalingCurve) == 0x000280, "Member 'AGBDoorSwinging::AcousticPortalScalingCurve' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, AcousticPortalOriginalScaleVector) == 0x000288, "Member 'AGBDoorSwinging::AcousticPortalOriginalScaleVector' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, MaxYaw) == 0x0002B0, "Member 'AGBDoorSwinging::MaxYaw' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, InitialYaw) == 0x0002B8, "Member 'AGBDoorSwinging::InitialYaw' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, ConsideredOpenYaw) == 0x0002BC, "Member 'AGBDoorSwinging::ConsideredOpenYaw' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, AdjoiningDoor) == 0x0002C0, "Member 'AGBDoorSwinging::AdjoiningDoor' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, AdjoiningDoorBehaviour) == 0x0002C8, "Member 'AGBDoorSwinging::AdjoiningDoorBehaviour' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, bAIAlwaysMirrorAdjoiningDoorUsage) == 0x0002C9, "Member 'AGBDoorSwinging::bAIAlwaysMirrorAdjoiningDoorUsage' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, OnOpening) == 0x0002D0, "Member 'AGBDoorSwinging::OnOpening' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, OnClosing) == 0x0002E0, "Member 'AGBDoorSwinging::OnClosing' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, OnStartedMoving) == 0x0002F0, "Member 'AGBDoorSwinging::OnStartedMoving' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, OnStoppedMoving) == 0x000300, "Member 'AGBDoorSwinging::OnStoppedMoving' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, ReplicatedSwing) == 0x000310, "Member 'AGBDoorSwinging::ReplicatedSwing' has a wrong offset!");
static_assert(offsetof(AGBDoorSwinging, AcousticPortalSoftRef) == 0x000340, "Member 'AGBDoorSwinging::AcousticPortalSoftRef' has a wrong offset!");

// Class GroundBranch.GBDroppedInvItem
// 0x0080 (0x02A0 - 0x0220)
class AGBDroppedInvItem : public AActor
{
public:
	class UGBInvItemPickupComponent*              PickupComponent;                                   // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoInitPickupComponent;                          // 0x0228(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bImportant;                                        // 0x0229(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22A[0x2];                                      // 0x022A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearDamping;                                     // 0x022C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngularDamping;                                    // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bZOnlyTranslation;                                 // 0x0234(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLockXRotation;                                    // 0x0235(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLockYRotation;                                    // 0x0236(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLockZRotation;                                    // 0x0237(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x28];                                     // 0x0238(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBInvItem*                             AssociatedInvItem;                                 // 0x0260(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AController*                            AssociatedController;                              // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ImpactType;                                        // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpactSpeedSquared;                                // 0x0278(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBetweenImpacts;                                // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x1C];                                     // 0x0284(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAssocatedInvItemSetEvent();
	void OnPhysicsCollision(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnRep_AssociatedInvItem();
	void RescueImportant();
	void SetAssociatedInvItem(class AGBInvItem* NewAssociatedInvItem);

	class AGBInvItem* GetAssociatedInvItem() const;
	bool IsImportant() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBDroppedInvItem">();
	}
	static class AGBDroppedInvItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBDroppedInvItem>();
	}
};
static_assert(alignof(AGBDroppedInvItem) == 0x000008, "Wrong alignment on AGBDroppedInvItem");
static_assert(sizeof(AGBDroppedInvItem) == 0x0002A0, "Wrong size on AGBDroppedInvItem");
static_assert(offsetof(AGBDroppedInvItem, PickupComponent) == 0x000220, "Member 'AGBDroppedInvItem::PickupComponent' has a wrong offset!");
static_assert(offsetof(AGBDroppedInvItem, bAutoInitPickupComponent) == 0x000228, "Member 'AGBDroppedInvItem::bAutoInitPickupComponent' has a wrong offset!");
static_assert(offsetof(AGBDroppedInvItem, bImportant) == 0x000229, "Member 'AGBDroppedInvItem::bImportant' has a wrong offset!");
static_assert(offsetof(AGBDroppedInvItem, LinearDamping) == 0x00022C, "Member 'AGBDroppedInvItem::LinearDamping' has a wrong offset!");
static_assert(offsetof(AGBDroppedInvItem, AngularDamping) == 0x000230, "Member 'AGBDroppedInvItem::AngularDamping' has a wrong offset!");
static_assert(offsetof(AGBDroppedInvItem, bZOnlyTranslation) == 0x000234, "Member 'AGBDroppedInvItem::bZOnlyTranslation' has a wrong offset!");
static_assert(offsetof(AGBDroppedInvItem, bLockXRotation) == 0x000235, "Member 'AGBDroppedInvItem::bLockXRotation' has a wrong offset!");
static_assert(offsetof(AGBDroppedInvItem, bLockYRotation) == 0x000236, "Member 'AGBDroppedInvItem::bLockYRotation' has a wrong offset!");
static_assert(offsetof(AGBDroppedInvItem, bLockZRotation) == 0x000237, "Member 'AGBDroppedInvItem::bLockZRotation' has a wrong offset!");
static_assert(offsetof(AGBDroppedInvItem, AssociatedInvItem) == 0x000260, "Member 'AGBDroppedInvItem::AssociatedInvItem' has a wrong offset!");
static_assert(offsetof(AGBDroppedInvItem, AssociatedController) == 0x000268, "Member 'AGBDroppedInvItem::AssociatedController' has a wrong offset!");
static_assert(offsetof(AGBDroppedInvItem, ImpactType) == 0x000270, "Member 'AGBDroppedInvItem::ImpactType' has a wrong offset!");
static_assert(offsetof(AGBDroppedInvItem, ImpactSpeedSquared) == 0x000278, "Member 'AGBDroppedInvItem::ImpactSpeedSquared' has a wrong offset!");
static_assert(offsetof(AGBDroppedInvItem, TimeBetweenImpacts) == 0x000280, "Member 'AGBDroppedInvItem::TimeBetweenImpacts' has a wrong offset!");

// Class GroundBranch.GBEjectComponent
// 0x0050 (0x0250 - 0x0200)
class UGBEjectComponent final : public USceneComponent
{
public:
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         SmokeFXNiagaraRef;                                 // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachedSmoke;                                    // 0x0208(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoopedSmoke;                                      // 0x0209(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20A[0x6];                                      // 0x020A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      SmokeNiagaraComp;                                  // 0x0210(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         ShellFXNiagaraRef;                                 // 0x0218(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachedShell;                                    // 0x0220(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoopedShell;                                      // 0x0221(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_222[0x6];                                      // 0x0222(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      ShellNiagaraComp;                                  // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bManualEjection;                                   // 0x0230(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ShellCollisionName;                                // 0x0234(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShellImpactType;                                   // 0x023C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinShellImpactSpeedSquared;                        // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateShell();
	void ActivateSmoke();
	void DeActivateShell();
	void DeActivateSmoke();

	bool IsManuallyEjected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBEjectComponent">();
	}
	static class UGBEjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBEjectComponent>();
	}
};
static_assert(alignof(UGBEjectComponent) == 0x000010, "Wrong alignment on UGBEjectComponent");
static_assert(sizeof(UGBEjectComponent) == 0x000250, "Wrong size on UGBEjectComponent");
static_assert(offsetof(UGBEjectComponent, SmokeFXNiagaraRef) == 0x000200, "Member 'UGBEjectComponent::SmokeFXNiagaraRef' has a wrong offset!");
static_assert(offsetof(UGBEjectComponent, bAttachedSmoke) == 0x000208, "Member 'UGBEjectComponent::bAttachedSmoke' has a wrong offset!");
static_assert(offsetof(UGBEjectComponent, bLoopedSmoke) == 0x000209, "Member 'UGBEjectComponent::bLoopedSmoke' has a wrong offset!");
static_assert(offsetof(UGBEjectComponent, SmokeNiagaraComp) == 0x000210, "Member 'UGBEjectComponent::SmokeNiagaraComp' has a wrong offset!");
static_assert(offsetof(UGBEjectComponent, ShellFXNiagaraRef) == 0x000218, "Member 'UGBEjectComponent::ShellFXNiagaraRef' has a wrong offset!");
static_assert(offsetof(UGBEjectComponent, bAttachedShell) == 0x000220, "Member 'UGBEjectComponent::bAttachedShell' has a wrong offset!");
static_assert(offsetof(UGBEjectComponent, bLoopedShell) == 0x000221, "Member 'UGBEjectComponent::bLoopedShell' has a wrong offset!");
static_assert(offsetof(UGBEjectComponent, ShellNiagaraComp) == 0x000228, "Member 'UGBEjectComponent::ShellNiagaraComp' has a wrong offset!");
static_assert(offsetof(UGBEjectComponent, bManualEjection) == 0x000230, "Member 'UGBEjectComponent::bManualEjection' has a wrong offset!");
static_assert(offsetof(UGBEjectComponent, ShellCollisionName) == 0x000234, "Member 'UGBEjectComponent::ShellCollisionName' has a wrong offset!");
static_assert(offsetof(UGBEjectComponent, ShellImpactType) == 0x00023C, "Member 'UGBEjectComponent::ShellImpactType' has a wrong offset!");
static_assert(offsetof(UGBEjectComponent, MinShellImpactSpeedSquared) == 0x000244, "Member 'UGBEjectComponent::MinShellImpactSpeedSquared' has a wrong offset!");

// Class GroundBranch.GBGameplayAbility
// 0x0008 (0x03B8 - 0x03B0)
class UGBGameplayAbility : public UGameplayAbility
{
public:
	bool                                          bActivateOnGive;                                   // 0x03B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_AuthoritativeCancelAbility();
	void K2_AuthoritativeEndAbility();
	void K2_LocalCancelAbility();
	void K2_LocalEndAbility();

	class AGBKytController* GetAvatarKytController() const;
	class AGBCharacter* GetCharacter() const;
	class AGBKytController* GetOwnerKytController() const;
	bool IsLocallyControlledPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameplayAbility">();
	}
	static class UGBGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameplayAbility>();
	}
};
static_assert(alignof(UGBGameplayAbility) == 0x000008, "Wrong alignment on UGBGameplayAbility");
static_assert(sizeof(UGBGameplayAbility) == 0x0003B8, "Wrong size on UGBGameplayAbility");
static_assert(offsetof(UGBGameplayAbility, bActivateOnGive) == 0x0003B0, "Member 'UGBGameplayAbility::bActivateOnGive' has a wrong offset!");

// Class GroundBranch.GBPhysicsCollisionHandler
// 0x0000 (0x0040 - 0x0040)
class UGBPhysicsCollisionHandler final : public UPhysicsCollisionHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPhysicsCollisionHandler">();
	}
	static class UGBPhysicsCollisionHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBPhysicsCollisionHandler>();
	}
};
static_assert(alignof(UGBPhysicsCollisionHandler) == 0x000008, "Wrong alignment on UGBPhysicsCollisionHandler");
static_assert(sizeof(UGBPhysicsCollisionHandler) == 0x000040, "Wrong size on UGBPhysicsCollisionHandler");

// Class GroundBranch.GBEquippedGameplayAbility
// 0x0000 (0x03B8 - 0x03B8)
class UGBEquippedGameplayAbility : public UGBGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBEquippedGameplayAbility">();
	}
	static class UGBEquippedGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBEquippedGameplayAbility>();
	}
};
static_assert(alignof(UGBEquippedGameplayAbility) == 0x000008, "Wrong alignment on UGBEquippedGameplayAbility");
static_assert(sizeof(UGBEquippedGameplayAbility) == 0x0003B8, "Wrong size on UGBEquippedGameplayAbility");

// Class GroundBranch.GBEvent
// 0x0000 (0x0220 - 0x0220)
class AGBEvent : public AActor
{
public:
	class AGBEventManager* GetEventManager();
	bool RemoveFromActiveEvents();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBEvent">();
	}
	static class AGBEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBEvent>();
	}
};
static_assert(alignof(AGBEvent) == 0x000008, "Wrong alignment on AGBEvent");
static_assert(sizeof(AGBEvent) == 0x000220, "Wrong size on AGBEvent");

// Class GroundBranch.GBEventManager
// 0x0080 (0x02A0 - 0x0220)
class AGBEventManager final : public AInfo
{
public:
	TArray<TSubclassOf<class UGBEventSpawnBehavior>> SpawnBehaviors;                                 // 0x0220(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UGBEventSpawnBehavior>, class UGBEventSpawnBehavior*> SpawnBehaviorMap;   // 0x0230(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         EventTickRate;                                     // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGBEvent*>                       ActiveEvents;                                      // 0x0288(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTimerHandle                           UpdateHandle;                                      // 0x0298(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool GetActiveEventsByClass(TSubclassOf<class AGBEvent> Class_0, TArray<class AGBEvent*>* OutEvents);
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBEventManager">();
	}
	static class AGBEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBEventManager>();
	}
};
static_assert(alignof(AGBEventManager) == 0x000008, "Wrong alignment on AGBEventManager");
static_assert(sizeof(AGBEventManager) == 0x0002A0, "Wrong size on AGBEventManager");
static_assert(offsetof(AGBEventManager, SpawnBehaviors) == 0x000220, "Member 'AGBEventManager::SpawnBehaviors' has a wrong offset!");
static_assert(offsetof(AGBEventManager, SpawnBehaviorMap) == 0x000230, "Member 'AGBEventManager::SpawnBehaviorMap' has a wrong offset!");
static_assert(offsetof(AGBEventManager, EventTickRate) == 0x000280, "Member 'AGBEventManager::EventTickRate' has a wrong offset!");
static_assert(offsetof(AGBEventManager, ActiveEvents) == 0x000288, "Member 'AGBEventManager::ActiveEvents' has a wrong offset!");
static_assert(offsetof(AGBEventManager, UpdateHandle) == 0x000298, "Member 'AGBEventManager::UpdateHandle' has a wrong offset!");

// Class GroundBranch.GBNavLinkProxy
// 0x0000 (0x0270 - 0x0270)
class AGBNavLinkProxy : public ANavLinkProxy
{
public:
	void OnNavigationGenerationFinished(class ANavigationData* NavData);
	void SmartLinkReached(class AActor* Agent, const struct FVector& Destination);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBNavLinkProxy">();
	}
	static class AGBNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBNavLinkProxy>();
	}
};
static_assert(alignof(AGBNavLinkProxy) == 0x000008, "Wrong alignment on AGBNavLinkProxy");
static_assert(sizeof(AGBNavLinkProxy) == 0x000270, "Wrong size on AGBNavLinkProxy");

// Class GroundBranch.GBNavLinkProxy_Door
// 0x0008 (0x0278 - 0x0270)
class AGBNavLinkProxy_Door final : public AGBNavLinkProxy
{
public:
	class AActor*                                 DoorRef;                                           // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetDoorRef(class AActor* NewDoorRef);

	class AActor* GetDoorRef() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBNavLinkProxy_Door">();
	}
	static class AGBNavLinkProxy_Door* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBNavLinkProxy_Door>();
	}
};
static_assert(alignof(AGBNavLinkProxy_Door) == 0x000008, "Wrong alignment on AGBNavLinkProxy_Door");
static_assert(sizeof(AGBNavLinkProxy_Door) == 0x000278, "Wrong size on AGBNavLinkProxy_Door");
static_assert(offsetof(AGBNavLinkProxy_Door, DoorRef) == 0x000270, "Member 'AGBNavLinkProxy_Door::DoorRef' has a wrong offset!");

// Class GroundBranch.GBEventSpawnBehavior
// 0x0008 (0x0030 - 0x0028)
class UGBEventSpawnBehavior final : public UObject
{
public:
	int32                                         EventsSpawned;                                     // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AGBEvent* SpawnEvent();

	bool CanSpawn() const;
	class AGBEventManager* GetEventManager() const;
	class UWorld* GetWorld() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBEventSpawnBehavior">();
	}
	static class UGBEventSpawnBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBEventSpawnBehavior>();
	}
};
static_assert(alignof(UGBEventSpawnBehavior) == 0x000008, "Wrong alignment on UGBEventSpawnBehavior");
static_assert(sizeof(UGBEventSpawnBehavior) == 0x000030, "Wrong size on UGBEventSpawnBehavior");
static_assert(offsetof(UGBEventSpawnBehavior, EventsSpawned) == 0x000028, "Member 'UGBEventSpawnBehavior::EventsSpawned' has a wrong offset!");

// Class GroundBranch.GBExistingInvItemDragDropPayload
// 0x0008 (0x0080 - 0x0078)
class UGBExistingInvItemDragDropPayload final : public UGBInvItemDragDropPayloadBase
{
public:
	class AGBInvItem*                             InvItem;                                           // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBExistingInvItemDragDropPayload">();
	}
	static class UGBExistingInvItemDragDropPayload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBExistingInvItemDragDropPayload>();
	}
};
static_assert(alignof(UGBExistingInvItemDragDropPayload) == 0x000008, "Wrong alignment on UGBExistingInvItemDragDropPayload");
static_assert(sizeof(UGBExistingInvItemDragDropPayload) == 0x000080, "Wrong size on UGBExistingInvItemDragDropPayload");
static_assert(offsetof(UGBExistingInvItemDragDropPayload, InvItem) == 0x000078, "Member 'UGBExistingInvItemDragDropPayload::InvItem' has a wrong offset!");

// Class GroundBranch.GBRailComponent
// 0x0020 (0x0220 - 0x0200)
class UGBRailComponent final : public USceneComponent
{
public:
	struct FGameplayTagContainer                  RailComponentTags;                                 // 0x01F8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         RecoilSlots;                                       // 0x0218(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FGameplayTag GetOrientationRailTypeTag() const;
	struct FGameplayTagContainer GetRailComponentTags() const;
	int32 GetRecoilSlots() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBRailComponent">();
	}
	static class UGBRailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBRailComponent>();
	}
};
static_assert(alignof(UGBRailComponent) == 0x000010, "Wrong alignment on UGBRailComponent");
static_assert(sizeof(UGBRailComponent) == 0x000220, "Wrong size on UGBRailComponent");
static_assert(offsetof(UGBRailComponent, RailComponentTags) == 0x0001F8, "Member 'UGBRailComponent::RailComponentTags' has a wrong offset!");
static_assert(offsetof(UGBRailComponent, RecoilSlots) == 0x000218, "Member 'UGBRailComponent::RecoilSlots' has a wrong offset!");

// Class GroundBranch.GBExternalMagazineComponent
// 0x0040 (0x0250 - 0x0210)
class UGBExternalMagazineComponent final : public UGBAmmunitionFeedComponent
{
public:
	class AGBMagazine*                            Magazine;                                          // 0x0208(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGBMagazine>                MagazineClass;                                     // 0x0210(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGBBulletProjectile>        ChamberedRound;                                    // 0x0218(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartPlusOne;                                     // 0x0220(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStayOpenOnLastRound;                              // 0x0221(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsFiringFromOpenBolt : 1;                         // 0x0222(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBoltHeldOpen : 1;                                 // 0x0222(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_223[0x5];                                      // 0x0223(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class UGBAmmunitionFeedComponent* AmmunitionFeedComp)> OnBoltHeldOpenUpdated; // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UGBAmmunitionFeedComponent* AmmunitionFeedComp)> OnMagazineUpdated; // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AGBMagazine* FindCompatibleMagazine(class AGBCharacter* Character);
	void OnRep_BoltHeldOpen();
	void OnRep_Magazine();
	void SetBoltHeldOpen(bool bNewBoltIsHeldOpen);
	void SetChamberedRound(TSubclassOf<class AGBBulletProjectile> NewChamberedRound);
	void SetIsFiringFromOpenBolt(bool bNewIsFiringFromOpenBolt);

	bool GetBoltHeldOpen() const;
	TSubclassOf<class AGBBulletProjectile> GetChamberedRound() const;
	bool GetIsFiringFromOpenBolt() const;
	class AGBMagazine* GetMagazine() const;
	TSubclassOf<class AGBMagazine> GetMagazineClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBExternalMagazineComponent">();
	}
	static class UGBExternalMagazineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBExternalMagazineComponent>();
	}
};
static_assert(alignof(UGBExternalMagazineComponent) == 0x000010, "Wrong alignment on UGBExternalMagazineComponent");
static_assert(sizeof(UGBExternalMagazineComponent) == 0x000250, "Wrong size on UGBExternalMagazineComponent");
static_assert(offsetof(UGBExternalMagazineComponent, Magazine) == 0x000208, "Member 'UGBExternalMagazineComponent::Magazine' has a wrong offset!");
static_assert(offsetof(UGBExternalMagazineComponent, MagazineClass) == 0x000210, "Member 'UGBExternalMagazineComponent::MagazineClass' has a wrong offset!");
static_assert(offsetof(UGBExternalMagazineComponent, ChamberedRound) == 0x000218, "Member 'UGBExternalMagazineComponent::ChamberedRound' has a wrong offset!");
static_assert(offsetof(UGBExternalMagazineComponent, bStartPlusOne) == 0x000220, "Member 'UGBExternalMagazineComponent::bStartPlusOne' has a wrong offset!");
static_assert(offsetof(UGBExternalMagazineComponent, bStayOpenOnLastRound) == 0x000221, "Member 'UGBExternalMagazineComponent::bStayOpenOnLastRound' has a wrong offset!");
static_assert(offsetof(UGBExternalMagazineComponent, OnBoltHeldOpenUpdated) == 0x000228, "Member 'UGBExternalMagazineComponent::OnBoltHeldOpenUpdated' has a wrong offset!");
static_assert(offsetof(UGBExternalMagazineComponent, OnMagazineUpdated) == 0x000238, "Member 'UGBExternalMagazineComponent::OnMagazineUpdated' has a wrong offset!");

// Class GroundBranch.GBPlayerSettings
// 0x0210 (0x0238 - 0x0028)
class UGBPlayerSettings final : public UObject
{
public:
	class FString                                 PlayerName;                                        // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerCallSign;                                    // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerUseElementCallSign;                         // 0x0048(0x0001)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FOVDefault;                                        // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeBias;                                           // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanRoll;                                          // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseSensitivity;                                  // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertMouse;                                      // 0x005C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMouseSmoothing;                             // 0x005D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableInputScaling;                              // 0x005E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F[0x1];                                       // 0x005F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoubleClickTime;                                   // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeLookSensitivityScale;                          // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SensitivityGamepadLeft;                            // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SensitivityGamepadRight;                           // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadzoneRightStick;                                // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadzoneLeftStick;                                 // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimMaxYaw;                                     // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimMinPitch;                                   // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimMaxPitch;                                   // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffTargetMaxYaw;                                   // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetFreelookToAim;                               // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitMaxFreelookFromAim;                          // 0x0089(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowKeyBinds;                                     // 0x008A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowReadyRoomPrompts;                             // 0x008B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowStanceProne;                                  // 0x008C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowStanceCrouched;                               // 0x008D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowStanceStanding;                               // 0x008E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowStanceLeaning;                                // 0x008F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlipStanceIndicatorPosition;                      // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowGaitWalking;                                  // 0x0091(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowGaitRunning;                                  // 0x0092(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93[0x1];                                       // 0x0093(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxChatMessages;                                   // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChatDisplayTime;                                   // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadialMenuInputScale;                              // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowFriendlyNameTags;                             // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomisePermanentHUDElementLocations;            // 0x00A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysRun;                                        // 0x00A2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleRun;                                        // 0x00A3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CrouchType;                                        // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleLean;                                       // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProneYawLimitHandling;                             // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultFiringMode;                                 // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultReticleBrightnessLevel;                     // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultReticleColourIndex;                         // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMomentaryAim;                                     // 0x00C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultFirearmPosition;                            // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReturnToReadyPostEngaged;                         // 0x00D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSingleTapReloadWithRetention;                     // 0x00D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SightPriority;                                     // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MagLevelSensitivityScales;                         // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManualBoltAction;                                 // 0x00F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManualPumpAction;                                 // 0x00F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x2];                                       // 0x00FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GrenadeSwitch;                                     // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           GrenadeArcColour;                                  // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           GrenadeImpactColour;                               // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleVoice;                                      // 0x0120(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoopBackVoice;                                    // 0x0121(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowVoiceIcon;                                    // 0x0122(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowVoiceMutedIcon;                               // 0x0123(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowRadioIcon;                                    // 0x0124(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PPSharpenPercentage;                               // 0x0128(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowFPS;                                          // 0x012C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MainMenuFPS;                                       // 0x0130(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHints;                                      // 0x0134(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowUsagePrompts;                                 // 0x0135(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowUsageHighlight;                               // 0x0136(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_137[0x1];                                      // 0x0137(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UsageHighlightSize;                                // 0x0138(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           UsageHighlightColour;                              // 0x013C(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpectatorMiniMapStyle;                             // 0x014C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSpectatorControls;                            // 0x0154(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowNetInfo;                                      // 0x0155(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleGadgetsOnNVGChange;                         // 0x0156(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideModdedPatches;                                // 0x0157(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideServerPatches;                                // 0x0158(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AudioChannelConfig;                                // 0x015C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AudioMixConfig;                                    // 0x0160(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DLSS_Mode;                                         // 0x0164(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DLSS_Sharpness;                                    // 0x0168(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DLSS3_Active;                                      // 0x016C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Reflex_ReflexMode;                                 // 0x0170(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColourBlindFilterName;                             // 0x0174(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColourBlindFilterAmount;                           // 0x017C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RedElementAlternateColourName;                     // 0x0180(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NVGVerticalScreenExtent;                           // 0x0188(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PIPScopeResolutionScale;                           // 0x018C(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenPercentageWith3dOptic;                       // 0x0190(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AntiAliasingMethod;                                // 0x0194(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGBLocalPlayer*                         LocalPlayer;                                       // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPlayerHint>                    HintList;                                          // 0x01A0(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B0[0x68];                                     // 0x01B0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           HiddenDialogs;                                     // 0x0218(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UGBPlayerSettings* PlayerSettings)> ApplyPlayerSettings;     // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ApplyNVIDIASettings();
	void ApplySettings();
	void BindSceneViewportResized();
	void HideDialog(const class FName& DialogName);
	void LoadSettings();
	void ResetHiddenDiaglogs();
	void ResetHints();
	void SceneViewportResized(const struct FVector2D& ViewportSize);
	void SetNVGVerticalScreenExtent(float NewNVGVerticalScreenExtent);
	void SetPIPScopeResolutionScale(float NewPIPScopeResolutionScale);
	void SetPlayerCallSign(const class FString& NewPlayerCallSign);
	void SetPlayerName(const class FString& NewPlayerName);
	void SetPlayerUseElementCallSign(bool bNewPlayerUseElementCallSign);
	void UpdateFOVDefault();

	bool CanShowDialog(const class FName& DialogName) const;
	float GetPIPScopeResolutionScale() const;
	class FString GetPlayerCallSign() const;
	class FString GetPlayerName() const;
	bool GetPlayerUseElementCallSign() const;
	bool HintValid(class FName HintName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPlayerSettings">();
	}
	static class UGBPlayerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBPlayerSettings>();
	}
};
static_assert(alignof(UGBPlayerSettings) == 0x000008, "Wrong alignment on UGBPlayerSettings");
static_assert(sizeof(UGBPlayerSettings) == 0x000238, "Wrong size on UGBPlayerSettings");
static_assert(offsetof(UGBPlayerSettings, PlayerName) == 0x000028, "Member 'UGBPlayerSettings::PlayerName' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, PlayerCallSign) == 0x000038, "Member 'UGBPlayerSettings::PlayerCallSign' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bPlayerUseElementCallSign) == 0x000048, "Member 'UGBPlayerSettings::bPlayerUseElementCallSign' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, FOVDefault) == 0x00004C, "Member 'UGBPlayerSettings::FOVDefault' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, EyeBias) == 0x000050, "Member 'UGBPlayerSettings::EyeBias' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, LeanRoll) == 0x000054, "Member 'UGBPlayerSettings::LeanRoll' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, MouseSensitivity) == 0x000058, "Member 'UGBPlayerSettings::MouseSensitivity' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bInvertMouse) == 0x00005C, "Member 'UGBPlayerSettings::bInvertMouse' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bEnableMouseSmoothing) == 0x00005D, "Member 'UGBPlayerSettings::bEnableMouseSmoothing' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bDisableInputScaling) == 0x00005E, "Member 'UGBPlayerSettings::bDisableInputScaling' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, DoubleClickTime) == 0x000060, "Member 'UGBPlayerSettings::DoubleClickTime' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, FreeLookSensitivityScale) == 0x000064, "Member 'UGBPlayerSettings::FreeLookSensitivityScale' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, SensitivityGamepadLeft) == 0x000068, "Member 'UGBPlayerSettings::SensitivityGamepadLeft' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, SensitivityGamepadRight) == 0x00006C, "Member 'UGBPlayerSettings::SensitivityGamepadRight' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, DeadzoneRightStick) == 0x000070, "Member 'UGBPlayerSettings::DeadzoneRightStick' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, DeadzoneLeftStick) == 0x000074, "Member 'UGBPlayerSettings::DeadzoneLeftStick' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, FreeAimMaxYaw) == 0x000078, "Member 'UGBPlayerSettings::FreeAimMaxYaw' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, FreeAimMinPitch) == 0x00007C, "Member 'UGBPlayerSettings::FreeAimMinPitch' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, FreeAimMaxPitch) == 0x000080, "Member 'UGBPlayerSettings::FreeAimMaxPitch' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, OffTargetMaxYaw) == 0x000084, "Member 'UGBPlayerSettings::OffTargetMaxYaw' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bResetFreelookToAim) == 0x000088, "Member 'UGBPlayerSettings::bResetFreelookToAim' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bLimitMaxFreelookFromAim) == 0x000089, "Member 'UGBPlayerSettings::bLimitMaxFreelookFromAim' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowKeyBinds) == 0x00008A, "Member 'UGBPlayerSettings::bShowKeyBinds' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowReadyRoomPrompts) == 0x00008B, "Member 'UGBPlayerSettings::bShowReadyRoomPrompts' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowStanceProne) == 0x00008C, "Member 'UGBPlayerSettings::bShowStanceProne' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowStanceCrouched) == 0x00008D, "Member 'UGBPlayerSettings::bShowStanceCrouched' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowStanceStanding) == 0x00008E, "Member 'UGBPlayerSettings::bShowStanceStanding' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowStanceLeaning) == 0x00008F, "Member 'UGBPlayerSettings::bShowStanceLeaning' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bFlipStanceIndicatorPosition) == 0x000090, "Member 'UGBPlayerSettings::bFlipStanceIndicatorPosition' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowGaitWalking) == 0x000091, "Member 'UGBPlayerSettings::bShowGaitWalking' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowGaitRunning) == 0x000092, "Member 'UGBPlayerSettings::bShowGaitRunning' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, MaxChatMessages) == 0x000094, "Member 'UGBPlayerSettings::MaxChatMessages' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, ChatDisplayTime) == 0x000098, "Member 'UGBPlayerSettings::ChatDisplayTime' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, RadialMenuInputScale) == 0x00009C, "Member 'UGBPlayerSettings::RadialMenuInputScale' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowFriendlyNameTags) == 0x0000A0, "Member 'UGBPlayerSettings::bShowFriendlyNameTags' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bRandomisePermanentHUDElementLocations) == 0x0000A1, "Member 'UGBPlayerSettings::bRandomisePermanentHUDElementLocations' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bAlwaysRun) == 0x0000A2, "Member 'UGBPlayerSettings::bAlwaysRun' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bToggleRun) == 0x0000A3, "Member 'UGBPlayerSettings::bToggleRun' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, CrouchType) == 0x0000A4, "Member 'UGBPlayerSettings::CrouchType' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bToggleLean) == 0x0000A8, "Member 'UGBPlayerSettings::bToggleLean' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, ProneYawLimitHandling) == 0x0000AC, "Member 'UGBPlayerSettings::ProneYawLimitHandling' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, DefaultFiringMode) == 0x0000B0, "Member 'UGBPlayerSettings::DefaultFiringMode' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, DefaultReticleBrightnessLevel) == 0x0000C0, "Member 'UGBPlayerSettings::DefaultReticleBrightnessLevel' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, DefaultReticleColourIndex) == 0x0000C4, "Member 'UGBPlayerSettings::DefaultReticleColourIndex' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bMomentaryAim) == 0x0000C8, "Member 'UGBPlayerSettings::bMomentaryAim' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, DefaultFirearmPosition) == 0x0000CC, "Member 'UGBPlayerSettings::DefaultFirearmPosition' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bReturnToReadyPostEngaged) == 0x0000D0, "Member 'UGBPlayerSettings::bReturnToReadyPostEngaged' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bSingleTapReloadWithRetention) == 0x0000D1, "Member 'UGBPlayerSettings::bSingleTapReloadWithRetention' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, SightPriority) == 0x0000D8, "Member 'UGBPlayerSettings::SightPriority' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, MagLevelSensitivityScales) == 0x0000E8, "Member 'UGBPlayerSettings::MagLevelSensitivityScales' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bManualBoltAction) == 0x0000F8, "Member 'UGBPlayerSettings::bManualBoltAction' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bManualPumpAction) == 0x0000F9, "Member 'UGBPlayerSettings::bManualPumpAction' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, GrenadeSwitch) == 0x0000FC, "Member 'UGBPlayerSettings::GrenadeSwitch' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, GrenadeArcColour) == 0x000100, "Member 'UGBPlayerSettings::GrenadeArcColour' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, GrenadeImpactColour) == 0x000110, "Member 'UGBPlayerSettings::GrenadeImpactColour' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bToggleVoice) == 0x000120, "Member 'UGBPlayerSettings::bToggleVoice' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bLoopBackVoice) == 0x000121, "Member 'UGBPlayerSettings::bLoopBackVoice' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowVoiceIcon) == 0x000122, "Member 'UGBPlayerSettings::bShowVoiceIcon' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowVoiceMutedIcon) == 0x000123, "Member 'UGBPlayerSettings::bShowVoiceMutedIcon' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowRadioIcon) == 0x000124, "Member 'UGBPlayerSettings::bShowRadioIcon' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, PPSharpenPercentage) == 0x000128, "Member 'UGBPlayerSettings::PPSharpenPercentage' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowFPS) == 0x00012C, "Member 'UGBPlayerSettings::bShowFPS' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, MainMenuFPS) == 0x000130, "Member 'UGBPlayerSettings::MainMenuFPS' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bEnableHints) == 0x000134, "Member 'UGBPlayerSettings::bEnableHints' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowUsagePrompts) == 0x000135, "Member 'UGBPlayerSettings::bShowUsagePrompts' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowUsageHighlight) == 0x000136, "Member 'UGBPlayerSettings::bShowUsageHighlight' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, UsageHighlightSize) == 0x000138, "Member 'UGBPlayerSettings::UsageHighlightSize' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, UsageHighlightColour) == 0x00013C, "Member 'UGBPlayerSettings::UsageHighlightColour' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, SpectatorMiniMapStyle) == 0x00014C, "Member 'UGBPlayerSettings::SpectatorMiniMapStyle' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowSpectatorControls) == 0x000154, "Member 'UGBPlayerSettings::bShowSpectatorControls' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bShowNetInfo) == 0x000155, "Member 'UGBPlayerSettings::bShowNetInfo' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bToggleGadgetsOnNVGChange) == 0x000156, "Member 'UGBPlayerSettings::bToggleGadgetsOnNVGChange' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bHideModdedPatches) == 0x000157, "Member 'UGBPlayerSettings::bHideModdedPatches' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, bHideServerPatches) == 0x000158, "Member 'UGBPlayerSettings::bHideServerPatches' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, AudioChannelConfig) == 0x00015C, "Member 'UGBPlayerSettings::AudioChannelConfig' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, AudioMixConfig) == 0x000160, "Member 'UGBPlayerSettings::AudioMixConfig' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, DLSS_Mode) == 0x000164, "Member 'UGBPlayerSettings::DLSS_Mode' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, DLSS_Sharpness) == 0x000168, "Member 'UGBPlayerSettings::DLSS_Sharpness' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, DLSS3_Active) == 0x00016C, "Member 'UGBPlayerSettings::DLSS3_Active' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, Reflex_ReflexMode) == 0x000170, "Member 'UGBPlayerSettings::Reflex_ReflexMode' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, ColourBlindFilterName) == 0x000174, "Member 'UGBPlayerSettings::ColourBlindFilterName' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, ColourBlindFilterAmount) == 0x00017C, "Member 'UGBPlayerSettings::ColourBlindFilterAmount' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, RedElementAlternateColourName) == 0x000180, "Member 'UGBPlayerSettings::RedElementAlternateColourName' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, NVGVerticalScreenExtent) == 0x000188, "Member 'UGBPlayerSettings::NVGVerticalScreenExtent' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, PIPScopeResolutionScale) == 0x00018C, "Member 'UGBPlayerSettings::PIPScopeResolutionScale' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, ScreenPercentageWith3dOptic) == 0x000190, "Member 'UGBPlayerSettings::ScreenPercentageWith3dOptic' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, AntiAliasingMethod) == 0x000194, "Member 'UGBPlayerSettings::AntiAliasingMethod' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, LocalPlayer) == 0x000198, "Member 'UGBPlayerSettings::LocalPlayer' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, HintList) == 0x0001A0, "Member 'UGBPlayerSettings::HintList' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, HiddenDialogs) == 0x000218, "Member 'UGBPlayerSettings::HiddenDialogs' has a wrong offset!");
static_assert(offsetof(UGBPlayerSettings, ApplyPlayerSettings) == 0x000228, "Member 'UGBPlayerSettings::ApplyPlayerSettings' has a wrong offset!");

// Class GroundBranch.GBGameTrigger
// 0x0038 (0x0260 - 0x0228)
class AGBGameTrigger : public ATriggerBase
{
public:
	uint8                                         Pad_228[0x18];                                     // 0x0228(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBGameMode*                            GBGameMode;                                        // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         TeamId;                                            // 0x0248(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsActive : 1;                                     // 0x0249(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_24A[0x6];                                      // 0x024A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           CustomDetailWidgets;                               // 0x0250(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	TArray<class AGBCharacter*> GetOverlaps();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameTrigger">();
	}
	static class AGBGameTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBGameTrigger>();
	}
};
static_assert(alignof(AGBGameTrigger) == 0x000008, "Wrong alignment on AGBGameTrigger");
static_assert(sizeof(AGBGameTrigger) == 0x000260, "Wrong size on AGBGameTrigger");
static_assert(offsetof(AGBGameTrigger, GBGameMode) == 0x000240, "Member 'AGBGameTrigger::GBGameMode' has a wrong offset!");
static_assert(offsetof(AGBGameTrigger, TeamId) == 0x000248, "Member 'AGBGameTrigger::TeamId' has a wrong offset!");
static_assert(offsetof(AGBGameTrigger, CustomDetailWidgets) == 0x000250, "Member 'AGBGameTrigger::CustomDetailWidgets' has a wrong offset!");

// Class GroundBranch.GBExtractionPoint
// 0x0078 (0x02D8 - 0x0260)
class AGBExtractionPoint final : public AGBGameTrigger
{
public:
	TSoftObjectPtr<class ALevelSequenceActor>     SequenceToPlayBeforeExfil;                         // 0x0260(0x0028)(Edit, SaveGame, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class ALevelSequenceActor>     SequenceToPlayAfterExfil;                          // 0x0288(0x0028)(Edit, SaveGame, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SequencePickerWidget;                              // 0x02B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetSequenceToPlayAfterExfil(const TSoftObjectPtr<class ALevelSequenceActor>& InLevelSequenceActor);
	void SetSequenceToPlayBeforeExfil(const TSoftObjectPtr<class ALevelSequenceActor>& InLevelSequenceActor);

	TSoftObjectPtr<class ALevelSequenceActor> GetSequenceToPlayAfterExfil() const;
	TSoftObjectPtr<class ALevelSequenceActor> GetSequenceToPlayBeforeExfil() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBExtractionPoint">();
	}
	static class AGBExtractionPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBExtractionPoint>();
	}
};
static_assert(alignof(AGBExtractionPoint) == 0x000008, "Wrong alignment on AGBExtractionPoint");
static_assert(sizeof(AGBExtractionPoint) == 0x0002D8, "Wrong size on AGBExtractionPoint");
static_assert(offsetof(AGBExtractionPoint, SequenceToPlayBeforeExfil) == 0x000260, "Member 'AGBExtractionPoint::SequenceToPlayBeforeExfil' has a wrong offset!");
static_assert(offsetof(AGBExtractionPoint, SequenceToPlayAfterExfil) == 0x000288, "Member 'AGBExtractionPoint::SequenceToPlayAfterExfil' has a wrong offset!");
static_assert(offsetof(AGBExtractionPoint, SequencePickerWidget) == 0x0002B0, "Member 'AGBExtractionPoint::SequencePickerWidget' has a wrong offset!");

// Class GroundBranch.GBGameTriggerBase
// 0x0048 (0x0270 - 0x0228)
class AGBGameTriggerBase : public ATriggerBase
{
public:
	uint8                                         Pad_228[0x18];                                     // 0x0228(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGBGameTriggerBase*>             AssociatedTriggers;                                // 0x0240(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseAssociatedTriggers;                            // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         TeamId;                                            // 0x0259(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsActive;                                         // 0x025A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25B[0x5];                                      // 0x025B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           CustomDetailWidgets;                               // 0x0260(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void OnNonTeamBeginOverlap(class AGBCharacter* GBCharacter);
	void OnNonTeamEndOverlap(class AGBCharacter* GBCharacter);
	void OnTeamBeginOverlap(class AGBCharacter* GBCharacter);
	void OnTeamEndOverlap(class AGBCharacter* GBCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameTriggerBase">();
	}
	static class AGBGameTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBGameTriggerBase>();
	}
};
static_assert(alignof(AGBGameTriggerBase) == 0x000008, "Wrong alignment on AGBGameTriggerBase");
static_assert(sizeof(AGBGameTriggerBase) == 0x000270, "Wrong size on AGBGameTriggerBase");
static_assert(offsetof(AGBGameTriggerBase, AssociatedTriggers) == 0x000240, "Member 'AGBGameTriggerBase::AssociatedTriggers' has a wrong offset!");
static_assert(offsetof(AGBGameTriggerBase, bUseAssociatedTriggers) == 0x000258, "Member 'AGBGameTriggerBase::bUseAssociatedTriggers' has a wrong offset!");
static_assert(offsetof(AGBGameTriggerBase, TeamId) == 0x000259, "Member 'AGBGameTriggerBase::TeamId' has a wrong offset!");
static_assert(offsetof(AGBGameTriggerBase, bIsActive) == 0x00025A, "Member 'AGBGameTriggerBase::bIsActive' has a wrong offset!");
static_assert(offsetof(AGBGameTriggerBase, CustomDetailWidgets) == 0x000260, "Member 'AGBGameTriggerBase::CustomDetailWidgets' has a wrong offset!");

// Class GroundBranch.GBRestrictedAreaVolume
// 0x0000 (0x0270 - 0x0270)
class AGBRestrictedAreaVolume final : public AGBGameTriggerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBRestrictedAreaVolume">();
	}
	static class AGBRestrictedAreaVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBRestrictedAreaVolume>();
	}
};
static_assert(alignof(AGBRestrictedAreaVolume) == 0x000008, "Wrong alignment on AGBRestrictedAreaVolume");
static_assert(sizeof(AGBRestrictedAreaVolume) == 0x000270, "Wrong size on AGBRestrictedAreaVolume");

// Class GroundBranch.GBFirearm
// 0x0148 (0x0590 - 0x0448)
class AGBFirearm : public AGBInvItem
{
public:
	class USkeletalMeshComponent*                 FirearmMeshComponent;                              // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkGunshotComponent;                                // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkInteractComponent;                               // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGBSightComponent*                      CurrentSight;                                      // 0x0460(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGBSightComponent*>              SightLineRoots;                                    // 0x0468(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0xC];                                      // 0x0478(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGBRecoilData                          EngagedRecoilData;                                 // 0x0484(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGBRecoilData                          RecoilData;                                        // 0x049C(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         StaminaRecoveryMultiplierCrouchedReady;            // 0x04B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaRecoveryMultiplierCrouchedEngaged;          // 0x04B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaRecoveryMultiplierCrouchedLowReady;         // 0x04BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaRecoveryMultiplierCrouchedHighReady;        // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaRecoveryMultiplierReady;                    // 0x04C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaRecoveryMultiplierEngaged;                  // 0x04C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaRecoveryMultiplierLowReady;                 // 0x04CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaRecoveryMultiplierHighReady;                // 0x04D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaExhaustionMultiplierCrouchedReady;          // 0x04D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaExhaustionMultiplierCrouchedEngaged;        // 0x04D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaExhaustionMultiplierCrouchedLowReady;       // 0x04DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaExhaustionMultiplierCrouchedHighReady;      // 0x04E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaExhaustionMultiplierReady;                  // 0x04E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaExhaustionMultiplierEngaged;                // 0x04E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaExhaustionMultiplierLowReady;               // 0x04EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaExhaustionMultiplierHighReady;              // 0x04F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastFired;                                         // 0x04F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F8[0x10];                                     // 0x04F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFiringModeData>                FiringModes;                                       // 0x0508(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         FiringModeIndex;                                   // 0x0518(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_519[0x7];                                      // 0x0519(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(uint8 FiringModeIndex)> OnFiringModeIndexChanged;                  // 0x0520(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USphereComponent*                       BarrelSpatialSoundSphereComp;                      // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BarrelSpatialSoundTag;                             // 0x0538(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FirearmSoundType;                                  // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BarrelAimAngleThreshold;                           // 0x0548(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSightRelativeX;                                 // 0x054C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxGripRelativeX;                                  // 0x0550(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CollisionTraceEndOffset;                           // 0x0554(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_560[0x8];                                      // 0x0560(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeightNoCoverAdvance;                              // 0x0568(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightNoCoverGoProne;                              // 0x056C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightNoCoverGoCrouch;                             // 0x0570(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_574[0x4];                                      // 0x0574(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGBFirearmCameraModifier*               FirearmCameraModifier;                             // 0x0578(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInsigatorIsLocallyViewed;                         // 0x0580(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_581[0xF];                                      // 0x0581(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AIReload(class FName ReloadType);
	bool ChangeFiringModeIndex(int32 dir);
	void ChangeSightLine(int32 dir);
	void FireShot();
	class AGBHolster* GetEmptyHolster(class AGBCharacter* Character);
	class FName GetEmptySlingPoint(class AGBCharacter* GBCharacter);
	class UGBFirearmAnimInstance* GetFirearmAnimInstance();
	struct FVector GetFirearmForwardVector();
	uint8 GetFiringModeByString(const class FString& FiringModeString);
	void OnBecomeViewTarget(class APlayerController* PlayerController, class AGBCharacter* Character);
	void OnEndViewTarget(class APlayerController* PlayerController, class AGBCharacter* Character);
	void OnRep_CurrentSight(class UGBSightComponent* LastActiveSightComponent);
	void OnRep_FiringModeIndex();
	void PlayFiringSound(class FName FirstPersonSoundName, class FName ThirdPersonSoundName, bool bTrackPlayingID);
	void PlayNonFiringSound(class FName FirstPersonSoundName, class FName ThirdPersonSoundName);
	void ServerSetCurrentSight(class UGBSightComponent* NewSight);
	void ServerSetFiringModeIndex(uint8 NewFiringMode);
	void SetCurrentSight(class UGBSightComponent* NewSight);
	void SetFiringModeByString(const class FString& FiringModeString);
	void SetFiringModeIndex(uint8 NewFiringModeIndex);
	void SetupCollisionTraceEndOffset();
	void SpatialSoundSphereBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void SpatialSoundSphereEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void StopFiringSound(class FName FirstPersonSoundName, class FName ThirdPersonSoundName);
	void UseRound();
	void ZeroCurrentSightComp(class UGBSightComponent* SightComp);

	TSubclassOf<class AGBBulletProjectile> GetBulletProjectileClass(const class UGBBarrelComponent* Barrel) const;
	uint8 GetBurstCount() const;
	struct FVector GetCollisionTraceEndOffset() const;
	float GetCurrentSightMagnification() const;
	class FString GetFirearmSoundType() const;
	struct FTransform GetFirearmTransform() const;
	class FString GetFireModeSwitchValue() const;
	uint8 GetFiringModeIndex() const;
	TArray<struct FFiringModeData> GetFiringModes() const;
	class UAkComponent* GetGunshotComp() const;
	bool GetInsigatorIsLocallyViewed() const;
	class UAkComponent* GetInteractComp() const;
	float GetLastTriggerPullTime() const;
	float GetMaxGripRelativeX() const;
	float GetMinSightRelativeX() const;
	struct FVector GetMuzzleOffset() const;
	int32 GetNumSightLines() const;
	float GetRateOfFire() const;
	struct FGBRecoilData GetRecoilData(bool bIsEngaged) const;
	class FString GetSuppressorSwitchValue() const;
	int32 GetTotalAvailableCount() const;
	uint8 GetTracerColourIndexForShot(const class UGBBarrelComponent* Barrel) const;
	bool IsEmpty() const;
	bool IsFingerOnTrigger() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBFirearm">();
	}
	static class AGBFirearm* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBFirearm>();
	}
};
static_assert(alignof(AGBFirearm) == 0x000008, "Wrong alignment on AGBFirearm");
static_assert(sizeof(AGBFirearm) == 0x000590, "Wrong size on AGBFirearm");
static_assert(offsetof(AGBFirearm, FirearmMeshComponent) == 0x000448, "Member 'AGBFirearm::FirearmMeshComponent' has a wrong offset!");
static_assert(offsetof(AGBFirearm, AkGunshotComponent) == 0x000450, "Member 'AGBFirearm::AkGunshotComponent' has a wrong offset!");
static_assert(offsetof(AGBFirearm, AkInteractComponent) == 0x000458, "Member 'AGBFirearm::AkInteractComponent' has a wrong offset!");
static_assert(offsetof(AGBFirearm, CurrentSight) == 0x000460, "Member 'AGBFirearm::CurrentSight' has a wrong offset!");
static_assert(offsetof(AGBFirearm, SightLineRoots) == 0x000468, "Member 'AGBFirearm::SightLineRoots' has a wrong offset!");
static_assert(offsetof(AGBFirearm, EngagedRecoilData) == 0x000484, "Member 'AGBFirearm::EngagedRecoilData' has a wrong offset!");
static_assert(offsetof(AGBFirearm, RecoilData) == 0x00049C, "Member 'AGBFirearm::RecoilData' has a wrong offset!");
static_assert(offsetof(AGBFirearm, StaminaRecoveryMultiplierCrouchedReady) == 0x0004B4, "Member 'AGBFirearm::StaminaRecoveryMultiplierCrouchedReady' has a wrong offset!");
static_assert(offsetof(AGBFirearm, StaminaRecoveryMultiplierCrouchedEngaged) == 0x0004B8, "Member 'AGBFirearm::StaminaRecoveryMultiplierCrouchedEngaged' has a wrong offset!");
static_assert(offsetof(AGBFirearm, StaminaRecoveryMultiplierCrouchedLowReady) == 0x0004BC, "Member 'AGBFirearm::StaminaRecoveryMultiplierCrouchedLowReady' has a wrong offset!");
static_assert(offsetof(AGBFirearm, StaminaRecoveryMultiplierCrouchedHighReady) == 0x0004C0, "Member 'AGBFirearm::StaminaRecoveryMultiplierCrouchedHighReady' has a wrong offset!");
static_assert(offsetof(AGBFirearm, StaminaRecoveryMultiplierReady) == 0x0004C4, "Member 'AGBFirearm::StaminaRecoveryMultiplierReady' has a wrong offset!");
static_assert(offsetof(AGBFirearm, StaminaRecoveryMultiplierEngaged) == 0x0004C8, "Member 'AGBFirearm::StaminaRecoveryMultiplierEngaged' has a wrong offset!");
static_assert(offsetof(AGBFirearm, StaminaRecoveryMultiplierLowReady) == 0x0004CC, "Member 'AGBFirearm::StaminaRecoveryMultiplierLowReady' has a wrong offset!");
static_assert(offsetof(AGBFirearm, StaminaRecoveryMultiplierHighReady) == 0x0004D0, "Member 'AGBFirearm::StaminaRecoveryMultiplierHighReady' has a wrong offset!");
static_assert(offsetof(AGBFirearm, StaminaExhaustionMultiplierCrouchedReady) == 0x0004D4, "Member 'AGBFirearm::StaminaExhaustionMultiplierCrouchedReady' has a wrong offset!");
static_assert(offsetof(AGBFirearm, StaminaExhaustionMultiplierCrouchedEngaged) == 0x0004D8, "Member 'AGBFirearm::StaminaExhaustionMultiplierCrouchedEngaged' has a wrong offset!");
static_assert(offsetof(AGBFirearm, StaminaExhaustionMultiplierCrouchedLowReady) == 0x0004DC, "Member 'AGBFirearm::StaminaExhaustionMultiplierCrouchedLowReady' has a wrong offset!");
static_assert(offsetof(AGBFirearm, StaminaExhaustionMultiplierCrouchedHighReady) == 0x0004E0, "Member 'AGBFirearm::StaminaExhaustionMultiplierCrouchedHighReady' has a wrong offset!");
static_assert(offsetof(AGBFirearm, StaminaExhaustionMultiplierReady) == 0x0004E4, "Member 'AGBFirearm::StaminaExhaustionMultiplierReady' has a wrong offset!");
static_assert(offsetof(AGBFirearm, StaminaExhaustionMultiplierEngaged) == 0x0004E8, "Member 'AGBFirearm::StaminaExhaustionMultiplierEngaged' has a wrong offset!");
static_assert(offsetof(AGBFirearm, StaminaExhaustionMultiplierLowReady) == 0x0004EC, "Member 'AGBFirearm::StaminaExhaustionMultiplierLowReady' has a wrong offset!");
static_assert(offsetof(AGBFirearm, StaminaExhaustionMultiplierHighReady) == 0x0004F0, "Member 'AGBFirearm::StaminaExhaustionMultiplierHighReady' has a wrong offset!");
static_assert(offsetof(AGBFirearm, LastFired) == 0x0004F4, "Member 'AGBFirearm::LastFired' has a wrong offset!");
static_assert(offsetof(AGBFirearm, FiringModes) == 0x000508, "Member 'AGBFirearm::FiringModes' has a wrong offset!");
static_assert(offsetof(AGBFirearm, FiringModeIndex) == 0x000518, "Member 'AGBFirearm::FiringModeIndex' has a wrong offset!");
static_assert(offsetof(AGBFirearm, OnFiringModeIndexChanged) == 0x000520, "Member 'AGBFirearm::OnFiringModeIndexChanged' has a wrong offset!");
static_assert(offsetof(AGBFirearm, BarrelSpatialSoundSphereComp) == 0x000530, "Member 'AGBFirearm::BarrelSpatialSoundSphereComp' has a wrong offset!");
static_assert(offsetof(AGBFirearm, BarrelSpatialSoundTag) == 0x000538, "Member 'AGBFirearm::BarrelSpatialSoundTag' has a wrong offset!");
static_assert(offsetof(AGBFirearm, FirearmSoundType) == 0x000540, "Member 'AGBFirearm::FirearmSoundType' has a wrong offset!");
static_assert(offsetof(AGBFirearm, BarrelAimAngleThreshold) == 0x000548, "Member 'AGBFirearm::BarrelAimAngleThreshold' has a wrong offset!");
static_assert(offsetof(AGBFirearm, MinSightRelativeX) == 0x00054C, "Member 'AGBFirearm::MinSightRelativeX' has a wrong offset!");
static_assert(offsetof(AGBFirearm, MaxGripRelativeX) == 0x000550, "Member 'AGBFirearm::MaxGripRelativeX' has a wrong offset!");
static_assert(offsetof(AGBFirearm, CollisionTraceEndOffset) == 0x000554, "Member 'AGBFirearm::CollisionTraceEndOffset' has a wrong offset!");
static_assert(offsetof(AGBFirearm, WeightNoCoverAdvance) == 0x000568, "Member 'AGBFirearm::WeightNoCoverAdvance' has a wrong offset!");
static_assert(offsetof(AGBFirearm, WeightNoCoverGoProne) == 0x00056C, "Member 'AGBFirearm::WeightNoCoverGoProne' has a wrong offset!");
static_assert(offsetof(AGBFirearm, WeightNoCoverGoCrouch) == 0x000570, "Member 'AGBFirearm::WeightNoCoverGoCrouch' has a wrong offset!");
static_assert(offsetof(AGBFirearm, FirearmCameraModifier) == 0x000578, "Member 'AGBFirearm::FirearmCameraModifier' has a wrong offset!");
static_assert(offsetof(AGBFirearm, bInsigatorIsLocallyViewed) == 0x000580, "Member 'AGBFirearm::bInsigatorIsLocallyViewed' has a wrong offset!");

// Class GroundBranch.GBFirearmAnimInstance
// 0x0000 (0x02C0 - 0x02C0)
class UGBFirearmAnimInstance : public UAnimInstance
{
public:
	bool                                          bLocallyViewed;                                    // 0x02B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBoltHeldOpen;                                     // 0x02B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BA[0x6];                                      // 0x02BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBoltHeldOpenUpdated(const class UGBAmmunitionFeedComponent* AmmunitionFeedComp);
	void OnFiringModeIndexChanged(uint8 FiringModeIndex);
	void OnIronSightZeroing(const struct FVector& ZeroRelativeToSight, const struct FVector& SightLocationOffset, const struct FRotator& SightRotationOffset);
	void OnSetFrontSightPostHeightOffset(float FrontSightPostHeightOffset);

	bool IsLocal() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBFirearmAnimInstance">();
	}
	static class UGBFirearmAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBFirearmAnimInstance>();
	}
};
static_assert(alignof(UGBFirearmAnimInstance) == 0x000010, "Wrong alignment on UGBFirearmAnimInstance");
static_assert(sizeof(UGBFirearmAnimInstance) == 0x0002C0, "Wrong size on UGBFirearmAnimInstance");
static_assert(offsetof(UGBFirearmAnimInstance, bLocallyViewed) == 0x0002B8, "Member 'UGBFirearmAnimInstance::bLocallyViewed' has a wrong offset!");
static_assert(offsetof(UGBFirearmAnimInstance, bBoltHeldOpen) == 0x0002B9, "Member 'UGBFirearmAnimInstance::bBoltHeldOpen' has a wrong offset!");

// Class GroundBranch.GBItemCameraModifier
// 0x0010 (0x0058 - 0x0048)
class UGBItemCameraModifier : public UGBCameraModifier
{
public:
	bool                                          bMustBeEquipped;                                   // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableOnTransition;                              // 0x0049(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBInvItem*                             AssociatedItem;                                    // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAssociatedItemDestroyed(class AActor* DestroyedActor);
	void SetAssociatedItem(class AGBInvItem* Item);

	class AGBInvItem* GetAssociatedItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBItemCameraModifier">();
	}
	static class UGBItemCameraModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBItemCameraModifier>();
	}
};
static_assert(alignof(UGBItemCameraModifier) == 0x000008, "Wrong alignment on UGBItemCameraModifier");
static_assert(sizeof(UGBItemCameraModifier) == 0x000058, "Wrong size on UGBItemCameraModifier");
static_assert(offsetof(UGBItemCameraModifier, bMustBeEquipped) == 0x000048, "Member 'UGBItemCameraModifier::bMustBeEquipped' has a wrong offset!");
static_assert(offsetof(UGBItemCameraModifier, bDisableOnTransition) == 0x000049, "Member 'UGBItemCameraModifier::bDisableOnTransition' has a wrong offset!");
static_assert(offsetof(UGBItemCameraModifier, AssociatedItem) == 0x000050, "Member 'UGBItemCameraModifier::AssociatedItem' has a wrong offset!");

// Class GroundBranch.GBFirearmCameraModifier
// 0x0008 (0x0060 - 0x0058)
class UGBFirearmCameraModifier final : public UGBItemCameraModifier
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBFirearmCameraModifier">();
	}
	static class UGBFirearmCameraModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBFirearmCameraModifier>();
	}
};
static_assert(alignof(UGBFirearmCameraModifier) == 0x000008, "Wrong alignment on UGBFirearmCameraModifier");
static_assert(sizeof(UGBFirearmCameraModifier) == 0x000060, "Wrong size on UGBFirearmCameraModifier");

// Class GroundBranch.GBSightComponent
// 0x0180 (0x0380 - 0x0200)
class UGBSightComponent final : public USceneComponent
{
public:
	struct FGBSightLineInfo                       SightLineInfo;                                     // 0x01F8(0x0054)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint16                                        ZeroDistance;                                      // 0x024C(0x0002)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24E[0x12];                                     // 0x024E(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UGBSightComponent* SightComponent, class AGBInvItem* OwningItem, const struct FVector& RelativeZeroLocation)> PreSightZeroing; // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FVector& ZeroRelativeToSight, const struct FVector& SightLocationOffset, const struct FRotator& SightRotationOffset)> OnSightZeroing; // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UGBSightComponent* SightComponent, float Value)> OnSetMagnificationLevel; // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bHasFocus)> OnSightLineChanged;                               // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UMaterialInstanceDynamic* CurrentMID, class UMaterialInstanceDynamic* TargetMID)> OnMeshMaterialUpdate; // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ESightType                                    SightType;                                         // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultZeroDistance;                               // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpticRadius;                                       // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinOffset;                                         // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxOffset;                                         // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinMagnificationLevel;                             // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxMagnificationLevel;                             // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultMagnificationLevel;                         // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MagnificationLevel;                                // 0x02D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ReticleBrightnessLevel;                            // 0x02D4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ReticleColourIndex;                                // 0x02D5(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D6[0x2];                                      // 0x02D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StatKey;                                           // 0x02D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x4];                                      // 0x02E8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaterialIndex;                                     // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        FirstPersonMaterial;                               // 0x02F0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RTTextureName;                                     // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RTAlphaName;                                       // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ReticleBrightnessName;                             // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReticleBrightnessScale;                            // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneCaptureComponent2D*               SceneCaptureComponent;                             // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               NormalMID;                                         // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               FirstPersonMID;                                    // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x8];                                      // 0x0340(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTexture;                                     // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGBSightComponent*                      PrevSight;                                         // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGBSightComponent*                      NextSight;                                         // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x10];                                     // 0x0368(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UGBFrontSightPostComponent> MatchedFrontSightPost;                          // 0x0378(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AdjustReticleBrightnessLevel(int32 dir);
	void OnEndViewTarget(class APlayerController* PlayerController, class AGBCharacter* Character);
	void OnRep_MagnificationLevel();
	void OnRep_ReticleBrightness();
	void OnRep_ReticleColourIndex();
	void OnRep_SightLineInfo();
	void ServerSetMagnificationLevel(float NewMagnificationLevel);
	void ServerSetReticleBrightnessLevel(uint8 NewReticleBrightnessLevel);
	void ServerSetReticleColourIndex(uint8 NewReticleColourIndex);
	void ServerSetZeroDistance(const uint16 NewZeroDistance);
	void ServerSightLineInfoUpdated(const struct FGBSightLineInfo& NewSightLineInfo);
	void SetMagnificationLevel(float NewMagnificationLevel);
	void SetSceneCaptureComponent(class USceneCaptureComponent2D* NewSceneCaptureComp);
	bool SetupSight(class AGBFirearm* RelativeFirearm, const TArray<class AGBInvItem*>& OtherAttachments, class FString* OutErrorMessage);

	struct FVector GetAnimLocOffset() const;
	struct FRotator GetAnimRotOffset() const;
	float GetDefaultMagnificationLevel() const;
	bool GetFocus() const;
	float GetFOV() const;
	float GetLeafSightAngle(const class AGBFirearm* RelativeFirearm, const struct FVector& WorldBoneLocation, const struct FVector& RelativeLocationOffset) const;
	float GetMagnificationLevel() const;
	float GetMaxMagnificationLevel() const;
	float GetMinMagnificationLevel() const;
	class UGBSightComponent* GetNextSight() const;
	float GetOpticRadius() const;
	class UGBSightComponent* GetPrevSight() const;
	int32 GetReticleColourIndex() const;
	bool GetSightLineFocus() const;
	struct FGBSightLineInfo GetSightLineInfo() const;
	const class UGBSightComponent* GetSightLineRoot() const;
	class FString GetStatKey() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBSightComponent">();
	}
	static class UGBSightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBSightComponent>();
	}
};
static_assert(alignof(UGBSightComponent) == 0x000010, "Wrong alignment on UGBSightComponent");
static_assert(sizeof(UGBSightComponent) == 0x000380, "Wrong size on UGBSightComponent");
static_assert(offsetof(UGBSightComponent, SightLineInfo) == 0x0001F8, "Member 'UGBSightComponent::SightLineInfo' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, ZeroDistance) == 0x00024C, "Member 'UGBSightComponent::ZeroDistance' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, PreSightZeroing) == 0x000260, "Member 'UGBSightComponent::PreSightZeroing' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, OnSightZeroing) == 0x000270, "Member 'UGBSightComponent::OnSightZeroing' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, OnSetMagnificationLevel) == 0x000280, "Member 'UGBSightComponent::OnSetMagnificationLevel' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, OnSightLineChanged) == 0x000290, "Member 'UGBSightComponent::OnSightLineChanged' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, OnMeshMaterialUpdate) == 0x0002A0, "Member 'UGBSightComponent::OnMeshMaterialUpdate' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, SightType) == 0x0002B0, "Member 'UGBSightComponent::SightType' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, DefaultZeroDistance) == 0x0002B4, "Member 'UGBSightComponent::DefaultZeroDistance' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, OpticRadius) == 0x0002B8, "Member 'UGBSightComponent::OpticRadius' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, MinOffset) == 0x0002BC, "Member 'UGBSightComponent::MinOffset' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, MaxOffset) == 0x0002C0, "Member 'UGBSightComponent::MaxOffset' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, MinMagnificationLevel) == 0x0002C4, "Member 'UGBSightComponent::MinMagnificationLevel' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, MaxMagnificationLevel) == 0x0002C8, "Member 'UGBSightComponent::MaxMagnificationLevel' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, DefaultMagnificationLevel) == 0x0002CC, "Member 'UGBSightComponent::DefaultMagnificationLevel' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, MagnificationLevel) == 0x0002D0, "Member 'UGBSightComponent::MagnificationLevel' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, ReticleBrightnessLevel) == 0x0002D4, "Member 'UGBSightComponent::ReticleBrightnessLevel' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, ReticleColourIndex) == 0x0002D5, "Member 'UGBSightComponent::ReticleColourIndex' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, StatKey) == 0x0002D8, "Member 'UGBSightComponent::StatKey' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, MaterialIndex) == 0x0002EC, "Member 'UGBSightComponent::MaterialIndex' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, FirstPersonMaterial) == 0x0002F0, "Member 'UGBSightComponent::FirstPersonMaterial' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, RTTextureName) == 0x000308, "Member 'UGBSightComponent::RTTextureName' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, RTAlphaName) == 0x000310, "Member 'UGBSightComponent::RTAlphaName' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, ReticleBrightnessName) == 0x000318, "Member 'UGBSightComponent::ReticleBrightnessName' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, ReticleBrightnessScale) == 0x000320, "Member 'UGBSightComponent::ReticleBrightnessScale' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, SceneCaptureComponent) == 0x000328, "Member 'UGBSightComponent::SceneCaptureComponent' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, NormalMID) == 0x000330, "Member 'UGBSightComponent::NormalMID' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, FirstPersonMID) == 0x000338, "Member 'UGBSightComponent::FirstPersonMID' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, RenderTexture) == 0x000348, "Member 'UGBSightComponent::RenderTexture' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, PrevSight) == 0x000358, "Member 'UGBSightComponent::PrevSight' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, NextSight) == 0x000360, "Member 'UGBSightComponent::NextSight' has a wrong offset!");
static_assert(offsetof(UGBSightComponent, MatchedFrontSightPost) == 0x000378, "Member 'UGBSightComponent::MatchedFrontSightPost' has a wrong offset!");

// Class GroundBranch.GBFirearmGameplayAbility_Shoot
// 0x0008 (0x03C0 - 0x03B8)
class UGBFirearmGameplayAbility_Shoot final : public UGBEquippedGameplayAbility
{
public:
	float                                         TriggerPullDelay;                                  // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBFirearmGameplayAbility_Shoot">();
	}
	static class UGBFirearmGameplayAbility_Shoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBFirearmGameplayAbility_Shoot>();
	}
};
static_assert(alignof(UGBFirearmGameplayAbility_Shoot) == 0x000008, "Wrong alignment on UGBFirearmGameplayAbility_Shoot");
static_assert(sizeof(UGBFirearmGameplayAbility_Shoot) == 0x0003C0, "Wrong size on UGBFirearmGameplayAbility_Shoot");
static_assert(offsetof(UGBFirearmGameplayAbility_Shoot, TriggerPullDelay) == 0x0003B8, "Member 'UGBFirearmGameplayAbility_Shoot::TriggerPullDelay' has a wrong offset!");

// Class GroundBranch.GBFocusCameraModifier
// 0x05B8 (0x0600 - 0x0048)
class UGBFocusCameraModifier : public UGBCameraModifier
{
public:
	float                                         FOVScale;                                          // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomInSpeed;                                       // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomOutSpeed;                                      // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EaseExponent;                                      // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0xC];                                       // 0x0058(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRotation;                                       // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ResetRotation;                                     // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x14];                                      // 0x006C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   FOVPostProcessSettings;                            // 0x0080(0x0560)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         FOVAlphaErrorTolerance;                            // 0x05E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           ScopeMPC;                                          // 0x05E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeoutDuration;                                   // 0x05F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F4[0xC];                                      // 0x05F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBFocusCameraModifier">();
	}
	static class UGBFocusCameraModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBFocusCameraModifier>();
	}
};
static_assert(alignof(UGBFocusCameraModifier) == 0x000010, "Wrong alignment on UGBFocusCameraModifier");
static_assert(sizeof(UGBFocusCameraModifier) == 0x000600, "Wrong size on UGBFocusCameraModifier");
static_assert(offsetof(UGBFocusCameraModifier, FOVScale) == 0x000048, "Member 'UGBFocusCameraModifier::FOVScale' has a wrong offset!");
static_assert(offsetof(UGBFocusCameraModifier, ZoomInSpeed) == 0x00004C, "Member 'UGBFocusCameraModifier::ZoomInSpeed' has a wrong offset!");
static_assert(offsetof(UGBFocusCameraModifier, ZoomOutSpeed) == 0x000050, "Member 'UGBFocusCameraModifier::ZoomOutSpeed' has a wrong offset!");
static_assert(offsetof(UGBFocusCameraModifier, EaseExponent) == 0x000054, "Member 'UGBFocusCameraModifier::EaseExponent' has a wrong offset!");
static_assert(offsetof(UGBFocusCameraModifier, MaxRotation) == 0x000064, "Member 'UGBFocusCameraModifier::MaxRotation' has a wrong offset!");
static_assert(offsetof(UGBFocusCameraModifier, ResetRotation) == 0x000068, "Member 'UGBFocusCameraModifier::ResetRotation' has a wrong offset!");
static_assert(offsetof(UGBFocusCameraModifier, FOVPostProcessSettings) == 0x000080, "Member 'UGBFocusCameraModifier::FOVPostProcessSettings' has a wrong offset!");
static_assert(offsetof(UGBFocusCameraModifier, FOVAlphaErrorTolerance) == 0x0005E0, "Member 'UGBFocusCameraModifier::FOVAlphaErrorTolerance' has a wrong offset!");
static_assert(offsetof(UGBFocusCameraModifier, ScopeMPC) == 0x0005E8, "Member 'UGBFocusCameraModifier::ScopeMPC' has a wrong offset!");
static_assert(offsetof(UGBFocusCameraModifier, TimeoutDuration) == 0x0005F0, "Member 'UGBFocusCameraModifier::TimeoutDuration' has a wrong offset!");

// Class GroundBranch.GBRadialMenuWidget
// 0x0088 (0x02E8 - 0x0260)
class UGBRadialMenuWidget : public UUserWidget
{
public:
	TMulticastInlineDelegate<void(int32 Idx)>     OnMenuElementSelected;                             // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Idx)>     OnMenuElementHovered;                              // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Idx)>     OnMenuElementUnHovered;                            // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScreenCenter;                                      // 0x02A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CenterDistance;                                    // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGBRadialMenuElementWidget> MenuElementClass;                                  // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGBRadialMenuElementWidget*>     ActiveMenuElements;                                // 0x02C0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 MenuBackground;                                    // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DisplayText;                                       // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               MenuOverlay;                                       // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BPEvent_ClearCurrentSelection();
	void BPEvent_NewActiveSelection(int32 NewIndex);
	void BPEvent_SetDynamicMaterialParams(int32 NumberOfDivisions);
	void CloseRadialMenu();
	void SetSelectedIndex(const int32 NewIdx);
	void ShowRadialMenu(const TArray<struct FGBRadialMenuOption>& MenuOptions);

	int32 GetSelectedIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBRadialMenuWidget">();
	}
	static class UGBRadialMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBRadialMenuWidget>();
	}
};
static_assert(alignof(UGBRadialMenuWidget) == 0x000008, "Wrong alignment on UGBRadialMenuWidget");
static_assert(sizeof(UGBRadialMenuWidget) == 0x0002E8, "Wrong size on UGBRadialMenuWidget");
static_assert(offsetof(UGBRadialMenuWidget, OnMenuElementSelected) == 0x000260, "Member 'UGBRadialMenuWidget::OnMenuElementSelected' has a wrong offset!");
static_assert(offsetof(UGBRadialMenuWidget, OnMenuElementHovered) == 0x000270, "Member 'UGBRadialMenuWidget::OnMenuElementHovered' has a wrong offset!");
static_assert(offsetof(UGBRadialMenuWidget, OnMenuElementUnHovered) == 0x000280, "Member 'UGBRadialMenuWidget::OnMenuElementUnHovered' has a wrong offset!");
static_assert(offsetof(UGBRadialMenuWidget, ScreenCenter) == 0x0002A8, "Member 'UGBRadialMenuWidget::ScreenCenter' has a wrong offset!");
static_assert(offsetof(UGBRadialMenuWidget, CenterDistance) == 0x0002B0, "Member 'UGBRadialMenuWidget::CenterDistance' has a wrong offset!");
static_assert(offsetof(UGBRadialMenuWidget, MenuElementClass) == 0x0002B8, "Member 'UGBRadialMenuWidget::MenuElementClass' has a wrong offset!");
static_assert(offsetof(UGBRadialMenuWidget, ActiveMenuElements) == 0x0002C0, "Member 'UGBRadialMenuWidget::ActiveMenuElements' has a wrong offset!");
static_assert(offsetof(UGBRadialMenuWidget, MenuBackground) == 0x0002D0, "Member 'UGBRadialMenuWidget::MenuBackground' has a wrong offset!");
static_assert(offsetof(UGBRadialMenuWidget, DisplayText) == 0x0002D8, "Member 'UGBRadialMenuWidget::DisplayText' has a wrong offset!");
static_assert(offsetof(UGBRadialMenuWidget, MenuOverlay) == 0x0002E0, "Member 'UGBRadialMenuWidget::MenuOverlay' has a wrong offset!");

// Class GroundBranch.GBFoliageBlastComponent
// 0x0038 (0x00E8 - 0x00B0)
class UGBFoliageBlastComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGBFoliageQuickref>             RelevantFoliageList;                               // 0x00D0(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeBlast(class UObject* WorldContextObject, const float BlastExtent, const float MinFoliageMeshSize, const float BlastStrength, const float OscillationFrequency, const float MaxAngularPerturbation, const float MinPerturbationDecayTime, const float MaxPerturbationDecayTime);
	void ResetFoliage();
	void TriggerBlast();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBFoliageBlastComponent">();
	}
	static class UGBFoliageBlastComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBFoliageBlastComponent>();
	}
};
static_assert(alignof(UGBFoliageBlastComponent) == 0x000008, "Wrong alignment on UGBFoliageBlastComponent");
static_assert(sizeof(UGBFoliageBlastComponent) == 0x0000E8, "Wrong size on UGBFoliageBlastComponent");
static_assert(offsetof(UGBFoliageBlastComponent, RelevantFoliageList) == 0x0000D0, "Member 'UGBFoliageBlastComponent::RelevantFoliageList' has a wrong offset!");

// Class GroundBranch.GBLuaMathPackage
// 0x0000 (0x00C0 - 0x00C0)
class UGBLuaMathPackage final : public ULuaBlueprintPackage
{
public:
	struct FLuaValue GetRandom(const struct FLuaValue& Max);
	struct FLuaValue GetRandomRange(const struct FLuaValue& Min, const struct FLuaValue& Max);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLuaMathPackage">();
	}
	static class UGBLuaMathPackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBLuaMathPackage>();
	}
};
static_assert(alignof(UGBLuaMathPackage) == 0x000008, "Wrong alignment on UGBLuaMathPackage");
static_assert(sizeof(UGBLuaMathPackage) == 0x0000C0, "Wrong size on UGBLuaMathPackage");

// Class GroundBranch.GBFoliageInstancedStaticMeshComponent
// 0x0000 (0x06B0 - 0x06B0)
class UGBFoliageInstancedStaticMeshComponent final : public UFoliageInstancedStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBFoliageInstancedStaticMeshComponent">();
	}
	static class UGBFoliageInstancedStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBFoliageInstancedStaticMeshComponent>();
	}
};
static_assert(alignof(UGBFoliageInstancedStaticMeshComponent) == 0x000010, "Wrong alignment on UGBFoliageInstancedStaticMeshComponent");
static_assert(sizeof(UGBFoliageInstancedStaticMeshComponent) == 0x0006B0, "Wrong size on UGBFoliageInstancedStaticMeshComponent");

// Class GroundBranch.GBSearchableProp
// 0x0030 (0x0260 - 0x0230)
class AGBSearchableProp final : public AStaticMeshActor
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EGBIntelSearchType                            SearchablePropType;                                // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideIfDoesNotYieldIntel;                          // 0x0241(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_242[0x6];                                      // 0x0242(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           FoundIntelGameMessages;                            // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bYieldsIntel;                                      // 0x0258(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsActive : 1;                                     // 0x0259(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	bool                                          bIsSelected;                                       // 0x025A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEditing;                                          // 0x025B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bYieldsIntel();
	void OnRep_IsActive();
	void SetYieldsIntel(const bool bInYieldsIntel);
	void UpdateVisibility();

	EGBIntelSearchType GetSearchablePropType() const;
	bool GetYieldsIntel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBSearchableProp">();
	}
	static class AGBSearchableProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBSearchableProp>();
	}
};
static_assert(alignof(AGBSearchableProp) == 0x000008, "Wrong alignment on AGBSearchableProp");
static_assert(sizeof(AGBSearchableProp) == 0x000260, "Wrong size on AGBSearchableProp");
static_assert(offsetof(AGBSearchableProp, SearchablePropType) == 0x000240, "Member 'AGBSearchableProp::SearchablePropType' has a wrong offset!");
static_assert(offsetof(AGBSearchableProp, bHideIfDoesNotYieldIntel) == 0x000241, "Member 'AGBSearchableProp::bHideIfDoesNotYieldIntel' has a wrong offset!");
static_assert(offsetof(AGBSearchableProp, FoundIntelGameMessages) == 0x000248, "Member 'AGBSearchableProp::FoundIntelGameMessages' has a wrong offset!");
static_assert(offsetof(AGBSearchableProp, bYieldsIntel) == 0x000258, "Member 'AGBSearchableProp::bYieldsIntel' has a wrong offset!");
static_assert(offsetof(AGBSearchableProp, bIsSelected) == 0x00025A, "Member 'AGBSearchableProp::bIsSelected' has a wrong offset!");
static_assert(offsetof(AGBSearchableProp, bEditing) == 0x00025B, "Member 'AGBSearchableProp::bEditing' has a wrong offset!");

// Class GroundBranch.GBFoliageVisibilityAssetData
// 0x0018 (0x0040 - 0x0028)
class UGBFoliageVisibilityAssetData final : public UAssetUserData
{
public:
	struct FSoftObjectPath                        VisibilityMesh;                                    // 0x0028(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FSoftObjectPath GetVisibilityMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBFoliageVisibilityAssetData">();
	}
	static class UGBFoliageVisibilityAssetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBFoliageVisibilityAssetData>();
	}
};
static_assert(alignof(UGBFoliageVisibilityAssetData) == 0x000008, "Wrong alignment on UGBFoliageVisibilityAssetData");
static_assert(sizeof(UGBFoliageVisibilityAssetData) == 0x000040, "Wrong size on UGBFoliageVisibilityAssetData");
static_assert(offsetof(UGBFoliageVisibilityAssetData, VisibilityMesh) == 0x000028, "Member 'UGBFoliageVisibilityAssetData::VisibilityMesh' has a wrong offset!");

// Class GroundBranch.GBFrontSightPostComponent
// 0x0020 (0x0220 - 0x0200)
class UGBFrontSightPostComponent final : public USceneComponent
{
public:
	float                                         MinOffset;                                         // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxOffset;                                         // 0x01FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FrontSightPostHeightOffset;                        // 0x0200(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(float FrontSightPostHeightOffset)> OnSetFrontSightPostHeightOffset; // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_FrontSightPostHeightOffset();
	void ServerFrontSightPostHeightOffset(const float NewFrontSightPostHeightOffset);

	float GetFrontSightPostHeightOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBFrontSightPostComponent">();
	}
	static class UGBFrontSightPostComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBFrontSightPostComponent>();
	}
};
static_assert(alignof(UGBFrontSightPostComponent) == 0x000010, "Wrong alignment on UGBFrontSightPostComponent");
static_assert(sizeof(UGBFrontSightPostComponent) == 0x000220, "Wrong size on UGBFrontSightPostComponent");
static_assert(offsetof(UGBFrontSightPostComponent, MinOffset) == 0x0001F8, "Member 'UGBFrontSightPostComponent::MinOffset' has a wrong offset!");
static_assert(offsetof(UGBFrontSightPostComponent, MaxOffset) == 0x0001FC, "Member 'UGBFrontSightPostComponent::MaxOffset' has a wrong offset!");
static_assert(offsetof(UGBFrontSightPostComponent, FrontSightPostHeightOffset) == 0x000200, "Member 'UGBFrontSightPostComponent::FrontSightPostHeightOffset' has a wrong offset!");
static_assert(offsetof(UGBFrontSightPostComponent, OnSetFrontSightPostHeightOffset) == 0x000208, "Member 'UGBFrontSightPostComponent::OnSetFrontSightPostHeightOffset' has a wrong offset!");

// Class GroundBranch.GBLuaVectorPackage
// 0x0000 (0x00C0 - 0x00C0)
class UGBLuaVectorPackage final : public ULuaBlueprintPackage
{
public:
	struct FLuaValue VectorAdd(const struct FLuaValue& A, const struct FLuaValue& B);
	struct FLuaValue VectorDivide(const struct FLuaValue& A, const struct FLuaValue& B);
	struct FLuaValue VectorEquals(const struct FLuaValue& A, const struct FLuaValue& B);
	struct FLuaValue VectorMultiply(const struct FLuaValue& A, const struct FLuaValue& B);
	struct FLuaValue VectorSize(const struct FLuaValue& A);
	struct FLuaValue VectorSize2D(const struct FLuaValue& A);
	struct FLuaValue VectorSizeSquared(const struct FLuaValue& A);
	struct FLuaValue VectorSizeSquared2D(const struct FLuaValue& A);
	struct FLuaValue VectorStr(const struct FLuaValue& LuaVector);
	struct FLuaValue VectorSubtract(const struct FLuaValue& A, const struct FLuaValue& B);

	struct FLuaValue BuildVector(const struct FVector& Vector) const;
	struct FLuaValue VectorNew(const struct FLuaValue& SelfPackage, const struct FLuaValue& X, const struct FLuaValue& Y, const struct FLuaValue& Z) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLuaVectorPackage">();
	}
	static class UGBLuaVectorPackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBLuaVectorPackage>();
	}
};
static_assert(alignof(UGBLuaVectorPackage) == 0x000008, "Wrong alignment on UGBLuaVectorPackage");
static_assert(sizeof(UGBLuaVectorPackage) == 0x0000C0, "Wrong size on UGBLuaVectorPackage");

// Class GroundBranch.GBFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGBFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static uint8 AlphaToByte(const float AlphaValue);
	static bool AngleWithin(float AngleDegrees, float MinAngleDegrees, float MaxAngleDegrees, bool bInclusive);
	static void Array_Sort(const TArray<int32>& TargetArray, bool bAscendingOrder, class FName VariableName);
	static class UObject* BlueprintSyncLoadAsset(const TSoftObjectPtr<class UObject>& SoftObjectPtr);
	static TSubclassOf<class UObject> BlueprintSyncLoadClass(const TSoftClassPtr<class UClass>& SoftClassPtr);
	static class FString BP_GetJsonObjHash(class UVaRestJsonObject* JsonObj);
	static float ByteToAlpha(const uint8 ByteValue);
	static float ByteToSignedAlpha(const uint8 ByteValue);
	static void Capture2D_DeProject(const class ASceneCapture2D* Target, const struct FVector2D& ScreenPos, struct FVector* OutWorldOrigin, struct FVector* OutWorldDirection);
	static void Capture2D_Project(const class ASceneCapture2D* Target, const struct FVector& Location, struct FVector2D* OutPixelLocation);
	static bool Capture2D_SaveImage(class ASceneCapture2D* Target, const class FString& ImagePath, const struct FLinearColor& ClearColour);
	static void CaptureComponent2D_DeProject(const class USceneCaptureComponent2D* Target, const struct FVector2D& ScreenPos, struct FVector* OutWorldOrigin, struct FVector* OutWorldDirection);
	static void CaptureComponent2D_Project(const class USceneCaptureComponent2D* Target, const struct FVector& Location, struct FVector2D* OutPixelLocation);
	static bool CaptureComponent2D_SaveImage(class USceneCaptureComponent2D* Target, const class FString& ImagePath, const struct FLinearColor& ClearColour);
	static class FString CleanAuthorName(const class FString& InAuthorName, const bool bReturnUnknownIfUnknown);
	static bool ClearDirectoryReadyOnly(const class FString& Path, bool bRecursive);
	static bool ClearFileReadyOnly(const class FString& Filename);
	static void Component_SetCastHiddenShadow(class UPrimitiveComponent* PrimitiveComponent, bool bNewCastHiddenShadow);
	static bool CondenseJsonString(const class FString& JsonString, class FString* OutCondensedString);
	static void Config_AddToArray(const class FString& Filename, const class FString& Section, const class FString& Key, const class FString& Value);
	static void Config_DeleteArray(const class FString& Filename, const class FString& Section, const class FString& Key);
	static TArray<class FString> Config_GetArray(const class FString& Filename, const class FString& Section, const class FString& Key, bool* bValid);
	static bool Config_GetBool(const class FString& Filename, const class FString& Section, const class FString& Key, bool* bValid);
	static float Config_GetFloat(const class FString& Filename, const class FString& Section, const class FString& Key, bool* bValid);
	static int32 Config_GetInt(const class FString& Filename, const class FString& Section, const class FString& Key, bool* bValid);
	static class FString Config_GetString(const class FString& Filename, const class FString& Section, const class FString& Key, bool* bValid);
	static void Config_RemoveFromArray(const class FString& Filename, const class FString& Section, const class FString& Key, const class FString& Value);
	static void Config_Save(const class FString& Filename);
	static void Config_SetArray(const class FString& Filename, const class FString& Section, const class FString& Key, const TArray<class FString>& Values);
	static void Config_SetBool(const class FString& Filename, const class FString& Section, const class FString& Key, const bool& Value);
	static void Config_SetFloat(const class FString& Filename, const class FString& Section, const class FString& Key, const float& Value);
	static void Config_SetInt(const class FString& Filename, const class FString& Section, const class FString& Key, const int32& Value);
	static void Config_SetString(const class FString& Filename, const class FString& Section, const class FString& Key, const class FString& Value);
	static int32 Convert24HoursToMinutes(const class FString& TimeString);
	static class FString ConvertMinutesTo24Hours(const int32& MinutesOfDay);
	static class UMeshComponent* CopyMeshComponents(class AActor* NewOwner, class UMeshComponent* ParentComponent);
	static bool createDirectory(const class FString& Path);
	static bool CreateFoldersForFilename(const class FString& Filename);
	static class UMeshComponent* CreateMeshComponentCopy(class AActor* NewOwner, class UMeshComponent* Source);
	static class AVolume* CreateVolume(class UObject* WorldContextObject, const struct FTransform& SpawnTM, const struct FVector& Size, TSubclassOf<class AVolume> VolumeClass);
	static class FString DecodeServerTag(const class FString& ServerTag);
	static void DecodeTimeOfDayDateString(const class FString& InDateString, int32* OutYear, int32* OutMonth, int32* OutDay);
	static void DecodeTimeOfDayString(const class FString& inString, EMissionTimeLabel* OutMissionTimeLabel, float* OutTimeInHours, int32* OutYear, int32* OutMonth, int32* OutDay, bool bSetDefaultDate);
	static void DecodeTimeOfDayTimeString(const class FString& InTimeString, EMissionTimeLabel* OutMissionTimeLabel, float* OutTimeInHours);
	static void DecodeWeatherPresetFileName(const class FString& WeatherFilename, class FName* OutWeatherCategory, class FName* OutWeatherType);
	static void DecodeWeatherString(const class FString& inString, class FName* OutWeatherCategory, class FName* OutWeatherType);
	static float DecompressAxisFromByte(uint8 CompressedAngle);
	static bool deleteFile(const class FString& Filename, bool bLogWarnings);
	static void Deproject(const struct FTransform& ViewTM, const float FOV, const struct FVector2D& ScreenSize, const struct FVector2D& ScreenPosition, struct FVector* OutWorldLocation, struct FVector* OutWorldDirection);
	static void DrawDebugWideArrow(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, float Width, const struct FLinearColor& LineColor, float Duration, float Thickness);
	static void DumpGameInfoToLog(const class UObject* WorldContextObject, const class FString& DumpContext);
	static class FString EncodeServerTag(const class FString& ServerTag);
	static class FString EncodeTimeOfDayDateString(const int32 Year, const int32 Month, const int32 Day);
	static class FString EncodeTimeOfDayStringHours(const EMissionTimeLabel MissionTimeLabel, const float TimeInHours, const int32 Year, const int32 Month, const int32 Day);
	static class FString EncodeTimeOfDayStringMins(const EMissionTimeLabel MissionTimeLabel, const int32 TimeInMins, const int32 Year, const int32 Month, const int32 Day);
	static class FString EncodeTimeOfDayTimeStringHours(const EMissionTimeLabel MissionTimeLabel, const float TimeInHours);
	static class FString EncodeTimeOfDayTimeStringMins(const EMissionTimeLabel MissionTimeLabel, const int32 TimeInMins);
	static class FString EncodeWeatherPresetFileName(const class FName WeatherCategory, const class FName WeatherType, bool bAddPath);
	static class FString EncodeWeatherPresetObjectName(const class FName WeatherCategory, const class FName WeatherType, bool bAddPath);
	static class FString EncodeWeatherString(const class FName WeatherCategory, const class FName WeatherType);
	static bool EvalBool(const class FString& Option, bool bDefaultValue);
	static class FString ExtractAlphanumericText(const class FString& SourceStr, bool bAllowHyphens);
	static bool fileExists(const class FString& Filename);
	static class USkyCreatorWeatherPreset* FindWeatherPreset(const class FName DecodedWeatherCategory, const class FName DecodedWeatherType);
	static class USkyCreatorWeatherPreset* FindWeatherPresetFromWhitelist(const class FName DecodedWeatherCategory, const class FName DecodedWeatherType, const TArray<class USkyCreatorWeatherPreset*>& WeatherPresetWhitelist);
	static void FlushPressedAction(class APlayerController* PlayerController, class FName ActionName);
	static void FlushPressedActions(class APlayerController* PlayerController, const TArray<class FName>& ActionNames);
	static void FlushPressedKeys(class APlayerController* PlayerController);
	static bool FolderExists(const class FString& Filename);
	static class FString GenerateMissionDisplayName(const class FString& InMapName, const class FString& InVariantName);
	static class UPhysicalMaterial* Get_PhysicalMaterial(const class UMaterial* Material);
	static bool GetActor2DBoundingBox(class AActor* Target, bool bNonColliding, struct FVector2D* OutMins, struct FVector2D* OutMaxs);
	static class UCameraComponent* GetActorCameraComponent(const class AActor* Target);
	static struct FBoxSphereBounds GetActorMeshBounds(const class AActor* Target);
	static struct FBoxSphereBounds GetActorMeshBoundsWithAttachedActors(const class AActor* Target, const TArray<class AActor*>& ExcludeActors);
	static struct FBoxSphereBounds GetActorMeshLocalBounds(const class AActor* Target);
	static struct FBoxSphereBounds GetActorMeshLocalBoundsWithAttachedActors(const class AActor* Target, const TArray<class AActor*>& ExcludeActors);
	static class FString GetActorNameWithoutSuffix(const class FString& SoftReferenceString);
	static TArray<class FString> GetAllWeatherPresetFileNames(bool bTrimPath);
	static class FString GetAlphaNumeric(const class FString& Source, const class FString& Delimiter);
	static bool GetAssetSoftObjPtrs(const class FString& Path, TArray<TSoftObjectPtr<class UObject>>* OutAssetSoftObjPtrs);
	static class ULevel* GetAudioSublevel(const class UObject* WorldContextObject);
	static class FString GetBaseFilename(const class FString& Filename);
	static class FString GetBuildNumber();
	static class FString GetBuildType(bool bIncludeEditor);
	static class UObject* GetClassDefaultObject(const class UClass* Class_0);
	static class UActorComponent* GetComponentByName(const class AActor* Target, class FName Name_0);
	static class FString GetConfigFilename(const class FString& ConfigFile);
	static void GetConsoleBool(const class FString& ConsoleVar, int32* OutBool);
	static void GetConsoleFloat(const class FString& ConsoleVar, float* OutFloat);
	static void GetConsoleHelp(const class FString& ConsoleVar, class FString* OutHelp);
	static void GetConsoleInt(const class FString& ConsoleVar, int32* OutInt);
	static void GetConsoleString(const class FString& ConsoleVar, class FString* OutString);
	static float GetCreationTime(const class AActor* Target);
	static bool GetDelayedSoundPosition(const struct FVector& ViewerPosition, const struct FVector& ObjectOrigin, const struct FVector& ObjectVelocity, const float& ElapsedTime, struct FVector* OutDelayedPosition);
	static float GetDistanceAlongSplineAtSplineInputKey(class USplineComponent* SplineComp, const float& InKey);
	static bool GetFileList(const class FString& FilePath, const class FString& Extension, bool bTrimPathAndExt, TArray<class FString>* FileList);
	static bool GetFolderList(const class FString& FilePath, TArray<class FString>* FolderList, bool RecurseIntoFolders);
	static const class FString GetFriendlyAICountString();
	static class FString GetGameContentDir();
	static class FString GetGameDir();
	static class FString GetGameLogDir();
	static class FString GetGameModeAuthor(class UObject* WorldContextObject, const class FString& ScriptName);
	static struct FLuaValue GetGameModeTable(class UObject* WorldContextObject, const class FString& ScriptName);
	static EGBGameModeType GetGameModeTypeFromFile(class UObject* WorldContextObject, const class FString& ScriptFilename);
	static EGBGameModeType GetGameModeTypeFromName(const class FName GameModeTypeName);
	static class UGBLocalPlayer* GetGBLocalPlayer(const class UObject* WorldContextObject);
	static uint8 GetGenericTeamId(class AActor* Target);
	static const class FString GetJoinInProgressString();
	static TArray<struct FKey> GetKeysBoundToAction(const class FName ActionName);
	static int32 GetLastDigitsFromString(const class FString& inString);
	static class FString GetLevelName(const class UObject* CurrentObject);
	static class ULocalPlayer* GetLocalPlayer(const class APlayerController* PlayerController);
	static class FString GetMapAssetPackageName(class UObject* WorldContextObject, bool bTrimGame);
	static class FString GetMapFromCommandLine(const class FString& CommandLine, bool bRemovePath);
	static class FString GetMapPath(class UObject* WorldContextObject, bool bTrimGame);
	static bool GetMatchingNames(const TArray<class FName>& SourceNames, const TArray<class FName>& SearchNames, TArray<class FName>* OutMatchedNames, ESearchFix SearchFix);
	static bool GetMatchingSocketNames(const TArray<class FName>& SearchNames, class USceneComponent* SceneComp, TArray<class FName>* OutSocketNames, ESearchFix SearchFix);
	static EGBMatchType GetMatchTypeFromString(const class FString& MatchTypeString);
	static bool GetMaterialInstanceStaticSwitchParameterValue(const class UMaterialInstance* Instance, class FName ParameterName, bool bCheckParent);
	static class AGBMinimap* GetMinimapForMissionVariant(const class UObject* WorldContextObject, const class FName& CurrentVariantName);
	static EMissionTimeLabel GetMissionLabelFromString(const class FString& TimePart);
	static float GetMissionTimeStandardHour(const EMissionTimeLabel TimeLabel);
	static int32 GetNetworkVersion();
	static class FName GetObjectFName(const class UObject* Object);
	static const class FString GetOpForCountString();
	static class FString GetOptionsFromCommandLine(const class FString& CommandLine);
	static class FString GetPathLeaf(const class FString& Filename);
	static class AGBPlayerNightVisionStatus* GetPlayerNightVisionStatusActor(const class UObject* WorldContextObject);
	static class FString GetProhibitedNameCharacters();
	static class FString GetProjectVersion();
	static class FString GetRadiotelephonySpelling(const class FString& Source);
	static void GetRandomAllowableDay(int32* OutMonth, int32* OutDay, const TArray<int32>& AllowedMonths);
	static class FName GetRandomWeatherPresetTypeInCategoryLimitByFilename(const class FName InCategory, const TArray<class FString>& FilenamesWhitelist);
	static class FName GetRandomWeatherPresetTypeInCategoryLimitByPreset(const class FName InCategory, const TArray<class USkyCreatorWeatherPreset*>& PresetWhitelist);
	static struct FTransform GetRefPoseBoneTransform(class USkeletalMeshComponent* SkelMesh, class FName BoneName);
	static class FString GetSavedConfigDir();
	static class FString GetSavedDir();
	static class FString GetScreenShotDir();
	static ESeason GetSeasonForDate(const int32 InMonth, const int32 InDay);
	static class AGBSky* GetSkyActor(const class UObject* WorldContextObject);
	static class FName GetStateName(const class AController* Target);
	static float GetTimeAlive(const class AActor* Target);
	static class FText GetTimeLabelText(EMissionTimeLabel TimeLabel);
	static class FString GetTimeOfDayDisplayString(const class FString& TimeOfDayString, const bool bFormatAsDisplayString);
	static class FText GetTimeOfDayDisplayStringAsText(const class FString& TimeOfDayString);
	static int32 GetUnixTimestamp();
	static class FString GetUObjectStatsString();
	static class FString GetUserDir();
	static bool GetViewportPosition(class UObject* WorldContextObject, const struct FVector2D& ScreenPosition, struct FVector2D* OutViewportPosition);
	static bool GetViewportPositionHitResultByChannel(class UObject* WorldContextObject, const struct FVector2D& ViewportPosition, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<class AActor*>& IgnoreActors, struct FHitResult* OutHitResult);
	static float HorizontalFOV(float VerticalFOV_0, float AspectRatio);
	static bool IsAuthorProprietary(const class FString& InAuthorName);
	static bool IsCommunityTestBuild();
	static bool IsDebugDisplayOn(const class UObject* WorldContextObject, class FName DebugType);
	static bool IsDedicatedServerSession(const class UObject* WorldContextObject);
	static bool IsEditor();
	static bool IsEditorWorld(const class UObject* WorldContextObject);
	static bool IsFacing(class AActor* Target, const struct FVector& Location, float MinForwardDot, bool bIgnoreVerticalFacing);
	static bool IsFriendly(const class AActor* ActorA, const class AActor* ActorB);
	static bool IsGameWorld(const class UObject* WorldContextObject);
	static bool IsInState(const class AController* Target, class FName InStateName);
	static bool IsKeyBoundToActionDown(class APlayerController* PlayerController, const class FName ActionName);
	static bool IsListenServerSession(const class UObject* WorldContextObject);
	static bool IsProbablyAYearOrYearRange(const class FString& SuspectedYearString);
	static bool isReadOnly(const class FString& PathOrFilename);
	static bool IsSimulatingInEditor();
	static bool IsValidSoftObjectPath(const struct FSoftObjectPath& SoftObjectPath);
	static class FName Key_GetName(const struct FKey& Key);
	static class FString Key_GetString(const struct FKey& Key);
	static bool LoadExternalImage(const class FString& ImagePath, class UTexture2D** OutImage, int32* OutWidth, int32* OutHeight);
	static bool LoadKillhouseVariant(const class UObject* WorldContextObject, const class FString& KillhouseLayoutClassName, const struct FVector& SpawnLocation);
	static bool LoadStringArrayFromFile(const class FString& Filename, TArray<class FString>* OutStringArray, bool bLogWarnings);
	static bool LoadStringFromFile(const class FString& Filename, class FString* OutString, bool bLogWarnings);
	static void LogUObjectStats();
	static struct FColor MakeRedToGreenColorFromScalar(float Scalar);
	static class FString MakeValidCallSign(const class FString& Source);
	static class FString MakeValidString(const class FString& Source, const class FString& InvalidChars);
	static bool NameArraysMatch(const TArray<class FName>& SourceNames, const TArray<class FName>& TargetNames);
	static bool NamesMatch(const class FName SourceName, const class FName SearchName, ESearchFix SearchFix);
	static bool OnSameTeam(const class AActor* ActorA, const class AActor* ActorB);
	static bool ParseValue_Bool(const class FString& Options, const class FString& Match, bool* Value);
	static bool ParseValue_Float(const class FString& Options, const class FString& Match, float* Value);
	static bool ParseValue_Integer(const class FString& Options, const class FString& Match, int32* Value);
	static bool ParseValue_Name(const class FString& Options, const class FString& Match, class FName* Value);
	static bool ParseValue_String(const class FString& Options, const class FString& Match, class FString* Value);
	static bool PrettifyJsonString(const class FString& JsonString, class FString* OutPrettyKitString);
	static void PrintStringToLog(const class FString& StringToPrint, const bool bLogVerbose, const bool bIncludeNetworkRoleInLog, const bool bIncludeNameInLog, const class UObject* ThisRef);
	static void Project(const struct FTransform& ViewTM, const float FOV, const struct FVector2D& ScreenSize, const struct FVector& WorldLocation, struct FVector2D* OutScreenPosition);
	static class FString RemoveSpaces(const class FString& SourceString);
	static void RemoveSpacesInline(class FString* SourceString);
	static void RenameActor(class AActor* TargetActor, const class FString& NewActorName);
	static void ResetGlobalGravity(const class UObject* WorldContextObject);
	static bool SaveStringToFile(const class FString& Filename, const class FString& String, bool bOverWrite);
	static void SetConsoleBool(const class FString& ConsoleVar, bool BoolValue);
	static void SetConsoleFloat(const class FString& ConsoleVar, float FloatValue);
	static void SetConsoleInt(const class FString& ConsoleVar, int32 IntValue);
	static void SetConsoleString(const class FString& ConsoleVar, const class FString& StringValue);
	static void SetDrownEffectIntensity(class UPostProcessComponent* PostProcessSettings, const float EffectAmount);
	static bool SetGenericTeamId(class AActor* Target, uint8 NewTeamId);
	static void SetGlobalGravity(const class UObject* WorldContextObject, float GlobalGravity);
	static void SetRenderInDepthPass(class UPrimitiveComponent* PrimitiveComp, bool bValue);
	static uint8 SignedAlphaToByte(const float AlphaValue);
	static void SortActorArray(TArray<class AActor*>& ActorArray, TArray<class AActor*>* ActorArrayRef);
	static void SortFloatArray(TArray<float>& FloatArray, TArray<float>* FloatArrayRef);
	static void SortIntArray(TArray<int32>& IntArray, TArray<int32>* IntArrayRef);
	static void SortStringArray(TArray<class FString>& StringArray, TArray<class FString>* StringArrayRef, const bool bSortByLeafName);
	static void SortStringArrayWithPriorityCharacter(TArray<class FString>& StringArray, TArray<class FString>* StringArrayRef, const class FString& PriorityCharacter);
	static class FString StringHash(const class FString& StringToHash);
	static class FString StringToDisplayString(const class FString& inString, bool bIsBool);
	static class FString StripBBCode(const class FString& SourceString);
	static class FString Time_GetOSTime(int32* MilliSeconds, int32* Seconds, int32* Minutes, int32* Hours12, int32* Hours24, int32* Day, int32* Month, int32* Year);
	static class FString TrimDigitsFromString(const class FString& inString);
	static class FString TrimExtension(const class FString& SourceStr);
	static bool UpdateMissionModBase(class UObject* WorldContextObject, const class FString& Filename, const struct FUInt64& NewModID, const TArray<class FString>& MatchingGameModes, const bool bOnlyStagedMod);
	static class FString UpdateMissionParametersFromMaplist(const class FString& Parameters, const TArray<class FString>& PermittedMissions);
	static float VerticalFOV(float HorizontalFOV, float AspectRatio);
	static bool ViewportPositionDeproject(class UObject* WorldContextObject, const struct FVector2D& ViewportPosition, struct FVector* OutWorldOrigin, struct FVector* OutWorldDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBFunctionLibrary">();
	}
	static class UGBFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBFunctionLibrary>();
	}
};
static_assert(alignof(UGBFunctionLibrary) == 0x000008, "Wrong alignment on UGBFunctionLibrary");
static_assert(sizeof(UGBFunctionLibrary) == 0x000028, "Wrong size on UGBFunctionLibrary");

// Class GroundBranch.GBPlayerState
// 0x0230 (0x0550 - 0x0320)
class AGBPlayerState : public APlayerState
{
public:
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGBAbilitySystemComponent*              AbilitySystemComponent;                            // 0x0330(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBPlayerState* PlayerState)> OnPlayerCallSignUpdated;       // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBPlayerState* PlayerState)> OnPlayerVolunteeredUpdated;    // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBPlayerState* PlayerState)> OnTeamElementChanged;          // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBPlayerState* PlayerState)> OnTeamElementNumberChanged;    // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0380(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeamElement                                  TeamElement;                                       // 0x0381(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_382[0x2];                                      // 0x0382(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeamElementNumber;                                 // 0x0384(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EReadyRoomStatus                              ReadyRoomStatus;                                   // 0x0388(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EReadyStatus                                  ReadyStatus;                                       // 0x0389(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bWasInPlay : 1;                                    // 0x038A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Lives;                                             // 0x038B(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAllowedToChangeKit : 1;                           // 0x038C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowedToRestart : 1;                             // 0x038C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_38D[0x3];                                      // 0x038D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CallSign;                                          // 0x0390(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseElementCallSign;                               // 0x03A0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayerVolunteered;                                // 0x03A1(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A2[0x6];                                      // 0x03A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBInsertionPoint*                      InsertionPoint;                                    // 0x03A8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x4];                                      // 0x03B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOnDuty : 1;                                       // 0x03B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3B5[0x3];                                      // 0x03B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         QuickAdminCommands;                                // 0x03B8(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FVector_NetQuantize                    PlayerLocation;                                    // 0x03C8(0x000C)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         PlayerRotation;                                    // 0x03D4(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D5[0x7];                                      // 0x03D5(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsMutedByServer : 1;                              // 0x03DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3DD[0x3];                                      // 0x03DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerConnectString;                               // 0x03E0(0x0010)(BlueprintVisible, Net, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F0[0x58];                                     // 0x03F0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReplicatedPlayerStats;                             // 0x0448(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AGBPlayerState* PlayerState)> OnReplicatedPlayerStatsUpdated; // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBPlayerState* PlayerState)> OnPlayerReadyRoomStatusChanged; // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBPlayerState* PlayerState)> OnPlayerReadyStatusChanged;    // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBPlayerState* PlayerState)> OnPlayerTeamChanged;           // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBPlayerState* PlayerState)> OnPlayerNameUpdated;           // 0x0498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A8[0x2C];                                     // 0x04A8(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	EAlertLevel                                   AlertLevel;                                        // 0x04D4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D5[0x3];                                      // 0x04D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBPlayerState* PlayerState)> OnAlertLevelChanged;           // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBPlayerState* PlayerState)> OnPlayerScoresUpdated;         // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGBScoreCollection                     PlayerScores;                                      // 0x04F8(0x0010)(Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         ReplicatedPlayerScores;                            // 0x0508(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bClientAssetIsMissing;                             // 0x0518(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_519[0x3];                                      // 0x0519(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NextMapVoteIndex;                                  // 0x051C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bNoReceiveTeamVOIP : 1;                            // 0x0520(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_521[0x7];                                      // 0x0521(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBPlayerState* PlayerState)> OnPlayerInteractionChanged;    // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGBPlayerInteraction                   PlayerInteraction;                                 // 0x0538(0x0010)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         BadWordCount;                                      // 0x0548(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LastBadWordSeconds;                                // 0x054C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddReplicatedPlayerStat(const class FString& StatString);
	void ApplyPlayerScoreTemplateFromGameState();
	void AwardPlayerScore(class FName ScoreName, int32 ScoreMultiple);
	void ClearPlayerScores();
	void ClearReplicatedPlayerStats();
	void ClearStat(class FName StatName, const class FString& StatKey);
	TArray<class FString> GetReplicatedPlayerStats();
	TArray<class FString> GetStatKeys(class FName StatName);
	int32 GetStatValue(class FName StatName, const class FString& StatKey);
	int32 GetTimeSinceLastBadWord();
	int32 GetTotalStatValue(class FName StatName);
	void IncrementBadWordCount();
	void IncrementStat(class FName StatName, const class FString& StatKey);
	void OnRep_AlertLevel();
	void OnRep_ClientAssetIsMissing();
	void OnRep_PlayerCallSign();
	void OnRep_PlayerInteraction();
	void OnRep_PlayerScores();
	void OnRep_PlayerVolunteered();
	void OnRep_ReadyRoomStatus();
	void OnRep_ReadyStatus();
	void OnRep_ReplicatedPlayerStats();
	void OnRep_TeamElement();
	void OnRep_TeamElementNumber();
	void OnRep_TeamId();
	void OnRepPlayerNameEvent(bool bBeenWelcomed);
	void PlayerInteractionChangedEvent(const struct FGBPlayerInteraction& NewPlayerInteraction);
	void ReportClientMissingAsset(const class FString& AssetName);
	void ResetBadWordCount();
	void ResetPlayerScores();
	void ResetStats();
	void ServerApplyPlayerSettingsGameplayTags(const struct FGameplayTagContainer& PlayerSettingTags);
	void ServerRegisterPlayerWithSession(const TArray<uint8>& AuthSessionTicket);
	void ServerReportClientMissingAsset(const class FString& AssetName);
	void ServerSetPlayerVolunteered(const bool bNewPlayerVolunteered);
	void ServerSyncPlayerScores();
	void SetAlertLevel(EAlertLevel NewAlertLevel);
	void SetAllowedToRestart(bool bNewAllowedToRestart);
	void SetCallSign(const class FString& NewCallSign);
	void SetInsertionPoint(class AGBInsertionPoint* NewInsertionPoint);
	void SetLives(uint8 NewLives);
	void SetOnDuty(bool bNewOnDuty);
	void SetPlayerInteraction(const EGBPlayerInteractionStatus NewPlayerInteractionStatus, class AGBPlayerState* OtherPlayerState);
	void SetPlayerVolunteered(const bool bNewPlayerVolunteered);
	void SetReadyRoomStatus(EReadyRoomStatus NewStatus);
	void SetReadyStatus(EReadyStatus NewStatus);
	void SetServerConnectString(const class FString& NewServerConnectString);
	void SetTeamElement(const ETeamElement& NewTeamElement);
	void SetTeamElementNumber(const int32& NewTeamElementNumber);
	void SetUseElementCallSign(const bool bNewUseElementCallSign);
	void SetWasInPlay(bool bNewWasInPlay);
	void SyncPlayerScores();
	void UpdateTeamElementNumber();

	bool AllowedToChangeKit() const;
	bool AllowedToRestart() const;
	bool ArePlayerScoresInitialised() const;
	EAlertLevel GetAlertLevel() const;
	int32 GetBadWordCount() const;
	class FString GetCallSign() const;
	class AGBCharacter* GetCharacter() const;
	class AGBInsertionPoint* GetInsertionPoint() const;
	class AGBPlayerState* GetInteractingPlayer() const;
	int32 GetLastBadWordSeconds() const;
	uint8 GetLives() const;
	int32 GetNextMapVoteIndex() const;
	bool GetNoReceiveTeamVOIP() const;
	class FString GetOldName() const;
	bool GetOnDuty() const;
	float GetPingInMillisecondsGetPing() const;
	struct FGBPlayerInteraction GetPlayerInteraction() const;
	struct FVector GetPlayerLocation() const;
	float GetPlayerRotation() const;
	TArray<struct FGBScoreLine> GetPlayerScores() const;
	bool GetPlayerVolunteered() const;
	TArray<class FString> GetQuickAdminCommands() const;
	EReadyRoomStatus GetReadyRoomStatus() const;
	EReadyStatus GetReadyStatus() const;
	class FString GetServerConnectString() const;
	ETeamElement GetTeamElement() const;
	class FString GetTeamElementLetter() const;
	int32 GetTeamElementNumber() const;
	bool GetUseElementCallSign() const;
	bool IsBenchmarking() const;
	bool IsLocal() const;
	bool IsOnlyASpectatorBP() const;
	bool IsPlayerControlledByOther() const;
	bool IsPlayerControllingOther() const;
	bool IsPlayerRestrained() const;
	void UpdateRichPresence() const;
	bool WasInPlay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPlayerState">();
	}
	static class AGBPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBPlayerState>();
	}
};
static_assert(alignof(AGBPlayerState) == 0x000008, "Wrong alignment on AGBPlayerState");
static_assert(sizeof(AGBPlayerState) == 0x000550, "Wrong size on AGBPlayerState");
static_assert(offsetof(AGBPlayerState, AbilitySystemComponent) == 0x000330, "Member 'AGBPlayerState::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, OnPlayerCallSignUpdated) == 0x000340, "Member 'AGBPlayerState::OnPlayerCallSignUpdated' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, OnPlayerVolunteeredUpdated) == 0x000350, "Member 'AGBPlayerState::OnPlayerVolunteeredUpdated' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, OnTeamElementChanged) == 0x000360, "Member 'AGBPlayerState::OnTeamElementChanged' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, OnTeamElementNumberChanged) == 0x000370, "Member 'AGBPlayerState::OnTeamElementNumberChanged' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, TeamId) == 0x000380, "Member 'AGBPlayerState::TeamId' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, TeamElement) == 0x000381, "Member 'AGBPlayerState::TeamElement' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, TeamElementNumber) == 0x000384, "Member 'AGBPlayerState::TeamElementNumber' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, ReadyRoomStatus) == 0x000388, "Member 'AGBPlayerState::ReadyRoomStatus' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, ReadyStatus) == 0x000389, "Member 'AGBPlayerState::ReadyStatus' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, Lives) == 0x00038B, "Member 'AGBPlayerState::Lives' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, CallSign) == 0x000390, "Member 'AGBPlayerState::CallSign' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, bUseElementCallSign) == 0x0003A0, "Member 'AGBPlayerState::bUseElementCallSign' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, bPlayerVolunteered) == 0x0003A1, "Member 'AGBPlayerState::bPlayerVolunteered' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, InsertionPoint) == 0x0003A8, "Member 'AGBPlayerState::InsertionPoint' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, QuickAdminCommands) == 0x0003B8, "Member 'AGBPlayerState::QuickAdminCommands' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, PlayerLocation) == 0x0003C8, "Member 'AGBPlayerState::PlayerLocation' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, PlayerRotation) == 0x0003D4, "Member 'AGBPlayerState::PlayerRotation' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, ServerConnectString) == 0x0003E0, "Member 'AGBPlayerState::ServerConnectString' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, ReplicatedPlayerStats) == 0x000448, "Member 'AGBPlayerState::ReplicatedPlayerStats' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, OnReplicatedPlayerStatsUpdated) == 0x000458, "Member 'AGBPlayerState::OnReplicatedPlayerStatsUpdated' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, OnPlayerReadyRoomStatusChanged) == 0x000468, "Member 'AGBPlayerState::OnPlayerReadyRoomStatusChanged' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, OnPlayerReadyStatusChanged) == 0x000478, "Member 'AGBPlayerState::OnPlayerReadyStatusChanged' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, OnPlayerTeamChanged) == 0x000488, "Member 'AGBPlayerState::OnPlayerTeamChanged' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, OnPlayerNameUpdated) == 0x000498, "Member 'AGBPlayerState::OnPlayerNameUpdated' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, AlertLevel) == 0x0004D4, "Member 'AGBPlayerState::AlertLevel' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, OnAlertLevelChanged) == 0x0004D8, "Member 'AGBPlayerState::OnAlertLevelChanged' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, OnPlayerScoresUpdated) == 0x0004E8, "Member 'AGBPlayerState::OnPlayerScoresUpdated' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, PlayerScores) == 0x0004F8, "Member 'AGBPlayerState::PlayerScores' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, ReplicatedPlayerScores) == 0x000508, "Member 'AGBPlayerState::ReplicatedPlayerScores' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, bClientAssetIsMissing) == 0x000518, "Member 'AGBPlayerState::bClientAssetIsMissing' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, NextMapVoteIndex) == 0x00051C, "Member 'AGBPlayerState::NextMapVoteIndex' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, OnPlayerInteractionChanged) == 0x000528, "Member 'AGBPlayerState::OnPlayerInteractionChanged' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, PlayerInteraction) == 0x000538, "Member 'AGBPlayerState::PlayerInteraction' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, BadWordCount) == 0x000548, "Member 'AGBPlayerState::BadWordCount' has a wrong offset!");
static_assert(offsetof(AGBPlayerState, LastBadWordSeconds) == 0x00054C, "Member 'AGBPlayerState::LastBadWordSeconds' has a wrong offset!");

// Class GroundBranch.GBGameEngine
// 0x0000 (0x0D70 - 0x0D70)
class UGBGameEngine final : public UGameEngine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameEngine">();
	}
	static class UGBGameEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameEngine>();
	}
};
static_assert(alignof(UGBGameEngine) == 0x000008, "Wrong alignment on UGBGameEngine");
static_assert(sizeof(UGBGameEngine) == 0x000D70, "Wrong size on UGBGameEngine");

// Class GroundBranch.GBGameInstance
// 0x00C0 (0x0268 - 0x01A8)
class UGBGameInstance : public UGameInstance
{
public:
	struct FDateTime                              LastMapPreLoadTime;                                // 0x01A8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              LastMapPostLoadTime;                               // 0x01B0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B8[0x8];                                      // 0x01B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUInt64                                JoiningFriend;                                     // 0x01C0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUInt64                                FriendLobbyID;                                     // 0x01C8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D0[0x10];                                     // 0x01D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFMModdingModSync>          FMModdingModSyncClass;                             // 0x01E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFMModdingModSync*                      FMModdingModSync;                                  // 0x01E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMModdingModListRetriever*             ModListRetriever;                                  // 0x01F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGBModBasicInfo>                MasterServerModList;                               // 0x01F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_208[0x10];                                     // 0x0208(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUInt64                                LobbyID;                                           // 0x0218(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_220[0x38];                                     // 0x0220(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGBDialogWidget>            DialogWidgetClass;                                 // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bColdStartAsListenServerClient;                    // 0x0260(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStillDownloadingModsForListenServerClient;        // 0x0261(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_262[0x6];                                      // 0x0262(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FLuaScriptOption> GetOptionValuesForMutator(struct FLuaScriptInfo& ScriptInfo);
	void LoadAllMutators();
	void LoadMutatorsForMod(const struct FUInt64& ModID);
	void OnModSyncComplete(bool bWasSuccessful);
	void PostInviteAccepted();
	void SetNewMasterServerModList(const TArray<struct FGBModBasicInfo>& NewMasterServerModList);
	void UnloadAllMutators();
	void UnloadMutatorsForMod(const struct FUInt64& ModID);

	float GetLastMapLoadTime() const;
	TArray<struct FGBModBasicInfo> GetMasterServerModList() const;
	bool GetServerDownloadModsComplete() const;
	bool GetStillDownloadingModsForListenServerClient() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameInstance">();
	}
	static class UGBGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameInstance>();
	}
};
static_assert(alignof(UGBGameInstance) == 0x000008, "Wrong alignment on UGBGameInstance");
static_assert(sizeof(UGBGameInstance) == 0x000268, "Wrong size on UGBGameInstance");
static_assert(offsetof(UGBGameInstance, LastMapPreLoadTime) == 0x0001A8, "Member 'UGBGameInstance::LastMapPreLoadTime' has a wrong offset!");
static_assert(offsetof(UGBGameInstance, LastMapPostLoadTime) == 0x0001B0, "Member 'UGBGameInstance::LastMapPostLoadTime' has a wrong offset!");
static_assert(offsetof(UGBGameInstance, JoiningFriend) == 0x0001C0, "Member 'UGBGameInstance::JoiningFriend' has a wrong offset!");
static_assert(offsetof(UGBGameInstance, FriendLobbyID) == 0x0001C8, "Member 'UGBGameInstance::FriendLobbyID' has a wrong offset!");
static_assert(offsetof(UGBGameInstance, FMModdingModSyncClass) == 0x0001E0, "Member 'UGBGameInstance::FMModdingModSyncClass' has a wrong offset!");
static_assert(offsetof(UGBGameInstance, FMModdingModSync) == 0x0001E8, "Member 'UGBGameInstance::FMModdingModSync' has a wrong offset!");
static_assert(offsetof(UGBGameInstance, ModListRetriever) == 0x0001F0, "Member 'UGBGameInstance::ModListRetriever' has a wrong offset!");
static_assert(offsetof(UGBGameInstance, MasterServerModList) == 0x0001F8, "Member 'UGBGameInstance::MasterServerModList' has a wrong offset!");
static_assert(offsetof(UGBGameInstance, LobbyID) == 0x000218, "Member 'UGBGameInstance::LobbyID' has a wrong offset!");
static_assert(offsetof(UGBGameInstance, DialogWidgetClass) == 0x000258, "Member 'UGBGameInstance::DialogWidgetClass' has a wrong offset!");
static_assert(offsetof(UGBGameInstance, bColdStartAsListenServerClient) == 0x000260, "Member 'UGBGameInstance::bColdStartAsListenServerClient' has a wrong offset!");
static_assert(offsetof(UGBGameInstance, bStillDownloadingModsForListenServerClient) == 0x000261, "Member 'UGBGameInstance::bStillDownloadingModsForListenServerClient' has a wrong offset!");

// Class GroundBranch.GBGameMode
// 0x04D8 (0x0798 - 0x02C0)
class AGBGameMode : public AGameModeBase
{
public:
	class AGBGameState*                           GBGameState;                                       // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHandleDedicatedServerReplays;                     // 0x02C8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumSpectators;                                     // 0x02CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumPlayers;                                        // 0x02D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumTravellingPlayers;                              // 0x02D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AGBGameMode* GameMode, class AGBCharacter* GBCharacter)> OnCharacterEnteredPlayArea; // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x02E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                SettingsWidget;                                    // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                BriefingRoomWidget;                                // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        MissionNameAdjectives;                             // 0x0310(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        MissionNameNouns;                                  // 0x0328(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGBAIDirector>              AIDirectorClass;                                   // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBAIDirector*                          AIDirector;                                        // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGBAISpawnManager>          AISpawnManagerClass;                               // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBAISpawnManager*                      AISpawnManager;                                    // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGBAIBarkManager>           AIBarkManagerClass;                                // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBAIBarkManager*                       AIBarkManager;                                     // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGBEventManager>            EventManagerClass;                                 // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBEventManager*                        EventManager;                                      // 0x0378(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TimeLimit;                                         // 0x0380(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PostTimeLimitDelay;                                // 0x0384(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0xC];                                      // 0x0388(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxDeadBodies;                                     // 0x0394(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDeadBodyData>                  DeadBodies;                                        // 0x0398(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxDroppedInvItems;                                // 0x03B0(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DroppedInvItemLifeSpan;                            // 0x03B4(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x18];                                     // 0x03B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanRandomiseObjectives;                           // 0x03D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0x3];                                      // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxLagCompTime;                                    // 0x03D4(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Difficulty;                                        // 0x03D8(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DC[0xB4];                                     // 0x03DC(0x00B4)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RoundStage;                                        // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PreviousRoundStage;                                // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRecordStats;                                      // 0x04A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A1[0x3];                                      // 0x04A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReadyCountdownTime;                                // 0x04A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreRoundWaitTime;                                  // 0x04A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RoundTime;                                         // 0x04AC(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PostRoundWaitTime;                                 // 0x04B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MatchEndedWaitTime;                                // 0x04B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class AGBKitInfo*>          DefaultLoadoutMap;                                 // 0x04C0(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_510[0x18];                                     // 0x0510(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GameStartTime;                                     // 0x0528(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52C[0x4];                                      // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FailSafeLoadout;                                   // 0x0530(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_540[0x10];                                     // 0x0540(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGBKytController>           BotControllerClass;                                // 0x0550(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGBCharacter>               FriendlyAIClass;                                   // 0x0558(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBotInfo>                       Bots;                                              // 0x0560(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AGBAISquad*>                     BotSquads;                                         // 0x0570(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBotInfo>                       PendingBots;                                       // 0x0580(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_590[0x10];                                     // 0x0590(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinPlayers;                                        // 0x05A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FriendlyAICount;                                   // 0x05A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A8[0x8];                                      // 0x05A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLuaScriptInfo                         GameModeTable;                                     // 0x05B0(0x0080)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FString                                 MissionFileName;                                   // 0x0630(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGBMissionData*                         MissionData;                                       // 0x0640(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGBGameModeType                               GameModeType;                                      // 0x0648(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_649[0x7];                                      // 0x0649(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBGameMode* GameMode)> OnPreStopMissionScript;              // 0x0650(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBGameMode* GameMode)> OnPostRunMissionScript;              // 0x0660(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_670[0x4];                                      // 0x0670(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MatchTimeLimit;                                    // 0x0674(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_678[0x8];                                      // 0x0678(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGBGameModeType, EGBMatchType>           GameModeType2DefaultMatchType;                     // 0x0680(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<EGBGameModeType, uint8>                  GameModeType2DefaultRoundLimit;                    // 0x06D0(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_720[0x10];                                     // 0x0720(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsEditingMission;                                 // 0x0730(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_731[0x7];                                      // 0x0731(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGBBenchmarker>             BenchmarkerClass;                                  // 0x0738(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBBenchmarker*                         Benchmarker;                                       // 0x0740(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_748[0x8];                                      // 0x0748(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGBSquad>                   SquadClass;                                        // 0x0750(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AGBSquad*>                       CurrentSquads;                                     // 0x0758(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FUInt64                                GameModeModID;                                     // 0x0768(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TimerHandle_NotifySequenceHasStopped;              // 0x0770(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALevelSequenceActor*                    CurrentSequencePlaying;                            // 0x0778(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCurrentSequenceIsCutscene;                        // 0x0780(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanAbortCurrentSequence;                          // 0x0781(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHidePlayersDuringSequence;                        // 0x0782(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlackOutAfterSequence;                            // 0x0783(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentSequenceDuration;                           // 0x0784(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PredictedSequenceEndTime;                          // 0x0788(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCampaignMissionHasGoneCoop;                       // 0x078C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78D[0x3];                                      // 0x078D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FinalMissionCompletionFraction;                    // 0x0790(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_794[0x4];                                      // 0x0794(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbortRoundStage(class FName Reason);
	void AddBots(uint8 Count, uint8 TeamId);
	void AddDefaultLoadout(const class FName& LoadoutName);
	bool AdjudicateWhetherMatchFinished();
	void AdvanceToNextMap();
	void AFKDetected(class APlayerController* PlayerController);
	void ApplyPlayerLoadout(class AController* Controller);
	void BecomeSpectator(class AGBPlayerState* GBPlayerState);
	void BeginServerShutdown();
	void Broadcast(class AGBPlayerState* SenderPlayerState, const class FString& Message, class FName MessageType, const struct FUInt64& ModID);
	void BroadcastGameMessage(class FName GameMessageId, class FName Type, float Duration, const struct FUInt64& ModID);
	void BroadcastLocalized(class AActor* Sender, TSubclassOf<class ULocalMessage> Message, int32 SWITCH, class APlayerState* RelatedPlayerState_1, class APlayerState* RelatedPlayerState_2, class UObject* OptionalObject);
	void ChangeCallSign(class AController* Controller, const class FString& NewCallSign);
	void CharacterDied(class ACharacter* Character, class AController* CharacterController, class AController* KillerController);
	bool CheckChatForBadWords(class FString* ChatText, class AGBPlayerState* GBPlayerState);
	void CheckServerShutdown();
	void ClearRoundStageTime();
	void CompleteAllObjectives();
	void EnterPlayArea(class AGBPlayerState* GBPlayerState);
	void EnterReadyRoom(class AGBPlayerState* GBPlayerState);
	void FinishServerShutdown();
	void FreezeBots(uint8 TeamId);
	class AGBInsertionPoint* GetBestLateComerInsertionPoint(class AGBPlayerState* GBPlayerState);
	TArray<class AGBKytController*> GetBotControllers(uint8 TeamId);
	struct FLuaValue GetGameModeTable();
	struct FLuaScriptInfo GetGameModeTableInfo();
	class FString GetMissionFileName();
	class AGBKitInfo* GetPlayerLoadoutInfo(class AController* Controller, const class FName& LoadoutName);
	class AGBInsertionPoint* GetRandomInsertionPoint();
	TArray<int32> GetReadyPlayerTeamCounts(bool bExcludeBots);
	void HandleEndRoundCommand();
	void HandleRestartRoundCommand();
	void HandleStartRoundCommand();
	bool IsSequencePlaying();
	void KillBots(uint8 TeamId);
	bool LoadLuaScript(const class FString& Filename, struct FLuaScriptInfo* OutLuaScriptInfo);
	void MakeEveryoneSpectate();
	void NotifyMissionObjectiveStatusChanged(class AGBMissionObjective* MissionObjective, const EGBMissionObjectiveStatus NewMissionObjectiveStatus);
	void NotifySequenceHasStopped();
	void OnAIInitializedHandler(class AGBKytController* NewAIController);
	void OnCharacterDiedEvent(class ACharacter* Character, class AController* CharacterController, class AController* KillerController);
	void OnDroppedInvItemDestroyed(class AActor* DestroyedActor);
	void OnLuaError(const class FString& Message);
	void OnPlayerCastNextMapVote(class APlayerState* PlayerState, const int32& MapListIndex);
	void OnProcessCommand(class APlayerController* InvokerPlayerController, const class FString& Command, const class FString& Params_0);
	void OnProcessCommandEvent(const class FString& Command, const class FString& Params_0);
	void OnRetryStandalone(class AGBPlayerController* PlayerController);
	void OnRoundStageAborted(class FName Reason);
	void OnRoundStageSet();
	void OnRoundStageTimeElapsed();
	void OnVoteCommand(class APlayerController* PlayerController, const class FString& Command, const class FString& Params_0);
	void OnVoteCommandEvent(class APlayerController* PlayerController, const class FString& Command, const class FString& Params_0);
	bool PlayerCanEnterPlayArea(class AGBPlayerState* GBPlayerState);
	void PlayerEnteredPlayArea(class AGBPlayerState* GBPlayerState);
	void PlayerEnteredReadyRoom(class AGBPlayerState* GBPlayerState);
	void PlayerGameModeRequest(class AGBPlayerState* GBPlayerState, const class FString& Request);
	void PlayerInsertionPointChanged(class AGBPlayerState* GBPlayerState, class AGBInsertionPoint* InsertionPoint);
	void PlayerReadyStatusChanged(class AGBPlayerState* GBPlayerState, EReadyStatus ReadyStatus);
	bool PrepLatecomer(class AGBPlayerState* GBPlayerState);
	void RefreshDeadBodyList();
	void RefreshDroppedInvItemsTimer();
	void RemoveBots(uint8 Count, uint8 TeamId);
	void ReportAICreatedInPlayArea(class AGBCharacter* GBCharacter);
	void ResetMissionObjectives();
	void RetryStandalone(class AGBPlayerController* PlayerController);
	void RunMissionScript(const class FString& ScriptName);
	void SendEveryoneToPlayArea();
	void SendEveryoneToReadyRoom();
	void SetCampaignMissionHasGoneCoop(const bool bInCampaignMissionHasGoneCoop);
	void SetDefaultRoundStageTime(class FName RoundStageName, int32 NewTimeLimit);
	void SetDifficulty(int32 NewDifficulty);
	void SetGameModeModID(const struct FUInt64& InGameModeModID);
	void SetMatchInfo(const struct FGBMatchInfo& NewMatchInfo);
	void SetMatchStartTime(const float NewMatchStartTime);
	void SetMatchType(const EGBMatchType NewMatchType, const bool bResetRoundScores);
	void SetMissionData(class UGBMissionData* NewMissionData, bool bSpawnActors, bool bRunScript, bool bForce);
	void SetMissionFileName(const class FString& NewMissionFileName);
	void SetRecordStats(const bool bNewRecordStats);
	void SetRoundStage(class FName NewRoundStage);
	void SetRoundStageTime(int32 NewTime);
	void SetRoundTime(int32 NewRoundTime);
	bool ShouldCheckForTeamKills();
	void StandAloneCommand(const class FString& Command, const class FString& Params_0);
	void StopCurrentSequencePlayback(const bool bSuppressBlackOutAfter);
	void TeleportPlayer(class AGBPlayerState* GBPlayerState, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation);
	void TimeLimitReached();
	void TimeLimitTimer();
	float TriggerSequencePlayback(TSoftObjectPtr<class ALevelSequenceActor> LevelSequenceActor, const bool bIsCutscene, const bool bCanAbort, const bool bResetActors, const bool bHidePlayers, const bool bBlackoutAfter);
	void UnFreezeBots(uint8 TeamId);
	void UpdateCanRandomiseObjectives();
	void UpdateGameRules();
	void UpdateMissionCompletionStats();

	bool GameModeIsLoaded() const;
	class AGBAIBarkManager* GetAIBarkManager() const;
	class AGBAISpawnManager* GetAISpawnManager() const;
	TSubclassOf<class AGBAISpawnManager> GetAISpawnManagerClass() const;
	TSubclassOf<class UUserWidget> GetBriefingRoomWidget() const;
	bool GetCampaignMissionHasGoneCoop() const;
	int32 GetDefaultRoundStageTime(class FName RoundStageName) const;
	class FText GetDisplayName() const;
	float GetFinalMissionCompletionFraction() const;
	struct FUInt64 GetGameModeModID() const;
	class AGBWorldSettings* GetGBWorldSettings() const;
	struct FGBMatchInfo GetMatchInfo() const;
	float GetMatchStartTime() const;
	float GetMissionCompletionFraction() const;
	class UGBMissionData* GetMissionData() const;
	TArray<class USkyCreatorWeatherPreset*> GetPermittedWeatherPresets() const;
	class ALevelSequenceActor* GetPlayingSequenceInfo(float* OutTime, float* OutTimeLeft, float* OutDuration, bool* bOutIsCutscene, bool* bOutCanAbort, bool* bOutBlackoutAfter) const;
	bool GetRecordStats() const;
	class FName GetRoundStage() const;
	bool GetRoundStageIsCutScene() const;
	float GetRoundStageTimeRemaining() const;
	bool HasBots() const;
	bool HasReachedTimeLimit() const;
	bool IsEditingMission() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameMode">();
	}
	static class AGBGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBGameMode>();
	}
};
static_assert(alignof(AGBGameMode) == 0x000008, "Wrong alignment on AGBGameMode");
static_assert(sizeof(AGBGameMode) == 0x000798, "Wrong size on AGBGameMode");
static_assert(offsetof(AGBGameMode, GBGameState) == 0x0002C0, "Member 'AGBGameMode::GBGameState' has a wrong offset!");
static_assert(offsetof(AGBGameMode, bHandleDedicatedServerReplays) == 0x0002C8, "Member 'AGBGameMode::bHandleDedicatedServerReplays' has a wrong offset!");
static_assert(offsetof(AGBGameMode, NumSpectators) == 0x0002CC, "Member 'AGBGameMode::NumSpectators' has a wrong offset!");
static_assert(offsetof(AGBGameMode, NumPlayers) == 0x0002D0, "Member 'AGBGameMode::NumPlayers' has a wrong offset!");
static_assert(offsetof(AGBGameMode, NumTravellingPlayers) == 0x0002D4, "Member 'AGBGameMode::NumTravellingPlayers' has a wrong offset!");
static_assert(offsetof(AGBGameMode, OnCharacterEnteredPlayArea) == 0x0002D8, "Member 'AGBGameMode::OnCharacterEnteredPlayArea' has a wrong offset!");
static_assert(offsetof(AGBGameMode, DisplayName) == 0x0002E8, "Member 'AGBGameMode::DisplayName' has a wrong offset!");
static_assert(offsetof(AGBGameMode, SettingsWidget) == 0x000300, "Member 'AGBGameMode::SettingsWidget' has a wrong offset!");
static_assert(offsetof(AGBGameMode, BriefingRoomWidget) == 0x000308, "Member 'AGBGameMode::BriefingRoomWidget' has a wrong offset!");
static_assert(offsetof(AGBGameMode, MissionNameAdjectives) == 0x000310, "Member 'AGBGameMode::MissionNameAdjectives' has a wrong offset!");
static_assert(offsetof(AGBGameMode, MissionNameNouns) == 0x000328, "Member 'AGBGameMode::MissionNameNouns' has a wrong offset!");
static_assert(offsetof(AGBGameMode, AIDirectorClass) == 0x000340, "Member 'AGBGameMode::AIDirectorClass' has a wrong offset!");
static_assert(offsetof(AGBGameMode, AIDirector) == 0x000348, "Member 'AGBGameMode::AIDirector' has a wrong offset!");
static_assert(offsetof(AGBGameMode, AISpawnManagerClass) == 0x000350, "Member 'AGBGameMode::AISpawnManagerClass' has a wrong offset!");
static_assert(offsetof(AGBGameMode, AISpawnManager) == 0x000358, "Member 'AGBGameMode::AISpawnManager' has a wrong offset!");
static_assert(offsetof(AGBGameMode, AIBarkManagerClass) == 0x000360, "Member 'AGBGameMode::AIBarkManagerClass' has a wrong offset!");
static_assert(offsetof(AGBGameMode, AIBarkManager) == 0x000368, "Member 'AGBGameMode::AIBarkManager' has a wrong offset!");
static_assert(offsetof(AGBGameMode, EventManagerClass) == 0x000370, "Member 'AGBGameMode::EventManagerClass' has a wrong offset!");
static_assert(offsetof(AGBGameMode, EventManager) == 0x000378, "Member 'AGBGameMode::EventManager' has a wrong offset!");
static_assert(offsetof(AGBGameMode, TimeLimit) == 0x000380, "Member 'AGBGameMode::TimeLimit' has a wrong offset!");
static_assert(offsetof(AGBGameMode, PostTimeLimitDelay) == 0x000384, "Member 'AGBGameMode::PostTimeLimitDelay' has a wrong offset!");
static_assert(offsetof(AGBGameMode, MaxDeadBodies) == 0x000394, "Member 'AGBGameMode::MaxDeadBodies' has a wrong offset!");
static_assert(offsetof(AGBGameMode, DeadBodies) == 0x000398, "Member 'AGBGameMode::DeadBodies' has a wrong offset!");
static_assert(offsetof(AGBGameMode, MaxDroppedInvItems) == 0x0003B0, "Member 'AGBGameMode::MaxDroppedInvItems' has a wrong offset!");
static_assert(offsetof(AGBGameMode, DroppedInvItemLifeSpan) == 0x0003B4, "Member 'AGBGameMode::DroppedInvItemLifeSpan' has a wrong offset!");
static_assert(offsetof(AGBGameMode, bCanRandomiseObjectives) == 0x0003D0, "Member 'AGBGameMode::bCanRandomiseObjectives' has a wrong offset!");
static_assert(offsetof(AGBGameMode, MaxLagCompTime) == 0x0003D4, "Member 'AGBGameMode::MaxLagCompTime' has a wrong offset!");
static_assert(offsetof(AGBGameMode, Difficulty) == 0x0003D8, "Member 'AGBGameMode::Difficulty' has a wrong offset!");
static_assert(offsetof(AGBGameMode, RoundStage) == 0x000490, "Member 'AGBGameMode::RoundStage' has a wrong offset!");
static_assert(offsetof(AGBGameMode, PreviousRoundStage) == 0x000498, "Member 'AGBGameMode::PreviousRoundStage' has a wrong offset!");
static_assert(offsetof(AGBGameMode, bRecordStats) == 0x0004A0, "Member 'AGBGameMode::bRecordStats' has a wrong offset!");
static_assert(offsetof(AGBGameMode, ReadyCountdownTime) == 0x0004A4, "Member 'AGBGameMode::ReadyCountdownTime' has a wrong offset!");
static_assert(offsetof(AGBGameMode, PreRoundWaitTime) == 0x0004A8, "Member 'AGBGameMode::PreRoundWaitTime' has a wrong offset!");
static_assert(offsetof(AGBGameMode, RoundTime) == 0x0004AC, "Member 'AGBGameMode::RoundTime' has a wrong offset!");
static_assert(offsetof(AGBGameMode, PostRoundWaitTime) == 0x0004B0, "Member 'AGBGameMode::PostRoundWaitTime' has a wrong offset!");
static_assert(offsetof(AGBGameMode, MatchEndedWaitTime) == 0x0004B4, "Member 'AGBGameMode::MatchEndedWaitTime' has a wrong offset!");
static_assert(offsetof(AGBGameMode, DefaultLoadoutMap) == 0x0004C0, "Member 'AGBGameMode::DefaultLoadoutMap' has a wrong offset!");
static_assert(offsetof(AGBGameMode, GameStartTime) == 0x000528, "Member 'AGBGameMode::GameStartTime' has a wrong offset!");
static_assert(offsetof(AGBGameMode, FailSafeLoadout) == 0x000530, "Member 'AGBGameMode::FailSafeLoadout' has a wrong offset!");
static_assert(offsetof(AGBGameMode, BotControllerClass) == 0x000550, "Member 'AGBGameMode::BotControllerClass' has a wrong offset!");
static_assert(offsetof(AGBGameMode, FriendlyAIClass) == 0x000558, "Member 'AGBGameMode::FriendlyAIClass' has a wrong offset!");
static_assert(offsetof(AGBGameMode, Bots) == 0x000560, "Member 'AGBGameMode::Bots' has a wrong offset!");
static_assert(offsetof(AGBGameMode, BotSquads) == 0x000570, "Member 'AGBGameMode::BotSquads' has a wrong offset!");
static_assert(offsetof(AGBGameMode, PendingBots) == 0x000580, "Member 'AGBGameMode::PendingBots' has a wrong offset!");
static_assert(offsetof(AGBGameMode, MinPlayers) == 0x0005A0, "Member 'AGBGameMode::MinPlayers' has a wrong offset!");
static_assert(offsetof(AGBGameMode, FriendlyAICount) == 0x0005A4, "Member 'AGBGameMode::FriendlyAICount' has a wrong offset!");
static_assert(offsetof(AGBGameMode, GameModeTable) == 0x0005B0, "Member 'AGBGameMode::GameModeTable' has a wrong offset!");
static_assert(offsetof(AGBGameMode, MissionFileName) == 0x000630, "Member 'AGBGameMode::MissionFileName' has a wrong offset!");
static_assert(offsetof(AGBGameMode, MissionData) == 0x000640, "Member 'AGBGameMode::MissionData' has a wrong offset!");
static_assert(offsetof(AGBGameMode, GameModeType) == 0x000648, "Member 'AGBGameMode::GameModeType' has a wrong offset!");
static_assert(offsetof(AGBGameMode, OnPreStopMissionScript) == 0x000650, "Member 'AGBGameMode::OnPreStopMissionScript' has a wrong offset!");
static_assert(offsetof(AGBGameMode, OnPostRunMissionScript) == 0x000660, "Member 'AGBGameMode::OnPostRunMissionScript' has a wrong offset!");
static_assert(offsetof(AGBGameMode, MatchTimeLimit) == 0x000674, "Member 'AGBGameMode::MatchTimeLimit' has a wrong offset!");
static_assert(offsetof(AGBGameMode, GameModeType2DefaultMatchType) == 0x000680, "Member 'AGBGameMode::GameModeType2DefaultMatchType' has a wrong offset!");
static_assert(offsetof(AGBGameMode, GameModeType2DefaultRoundLimit) == 0x0006D0, "Member 'AGBGameMode::GameModeType2DefaultRoundLimit' has a wrong offset!");
static_assert(offsetof(AGBGameMode, bIsEditingMission) == 0x000730, "Member 'AGBGameMode::bIsEditingMission' has a wrong offset!");
static_assert(offsetof(AGBGameMode, BenchmarkerClass) == 0x000738, "Member 'AGBGameMode::BenchmarkerClass' has a wrong offset!");
static_assert(offsetof(AGBGameMode, Benchmarker) == 0x000740, "Member 'AGBGameMode::Benchmarker' has a wrong offset!");
static_assert(offsetof(AGBGameMode, SquadClass) == 0x000750, "Member 'AGBGameMode::SquadClass' has a wrong offset!");
static_assert(offsetof(AGBGameMode, CurrentSquads) == 0x000758, "Member 'AGBGameMode::CurrentSquads' has a wrong offset!");
static_assert(offsetof(AGBGameMode, GameModeModID) == 0x000768, "Member 'AGBGameMode::GameModeModID' has a wrong offset!");
static_assert(offsetof(AGBGameMode, TimerHandle_NotifySequenceHasStopped) == 0x000770, "Member 'AGBGameMode::TimerHandle_NotifySequenceHasStopped' has a wrong offset!");
static_assert(offsetof(AGBGameMode, CurrentSequencePlaying) == 0x000778, "Member 'AGBGameMode::CurrentSequencePlaying' has a wrong offset!");
static_assert(offsetof(AGBGameMode, bCurrentSequenceIsCutscene) == 0x000780, "Member 'AGBGameMode::bCurrentSequenceIsCutscene' has a wrong offset!");
static_assert(offsetof(AGBGameMode, bCanAbortCurrentSequence) == 0x000781, "Member 'AGBGameMode::bCanAbortCurrentSequence' has a wrong offset!");
static_assert(offsetof(AGBGameMode, bHidePlayersDuringSequence) == 0x000782, "Member 'AGBGameMode::bHidePlayersDuringSequence' has a wrong offset!");
static_assert(offsetof(AGBGameMode, bBlackOutAfterSequence) == 0x000783, "Member 'AGBGameMode::bBlackOutAfterSequence' has a wrong offset!");
static_assert(offsetof(AGBGameMode, CurrentSequenceDuration) == 0x000784, "Member 'AGBGameMode::CurrentSequenceDuration' has a wrong offset!");
static_assert(offsetof(AGBGameMode, PredictedSequenceEndTime) == 0x000788, "Member 'AGBGameMode::PredictedSequenceEndTime' has a wrong offset!");
static_assert(offsetof(AGBGameMode, bCampaignMissionHasGoneCoop) == 0x00078C, "Member 'AGBGameMode::bCampaignMissionHasGoneCoop' has a wrong offset!");
static_assert(offsetof(AGBGameMode, FinalMissionCompletionFraction) == 0x000790, "Member 'AGBGameMode::FinalMissionCompletionFraction' has a wrong offset!");

// Class GroundBranch.GBGameModeActorInterface
// 0x0000 (0x0000 - 0x0000)
class IGBGameModeActorInterface final
{
public:
	bool IsActive();
	void SetActive(bool bNewActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameModeActorInterface">();
	}
	static class IGBGameModeActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGBGameModeActorInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGBGameModeActorInterface) == 0x000001, "Wrong alignment on IGBGameModeActorInterface");
static_assert(sizeof(IGBGameModeActorInterface) == 0x000001, "Wrong size on IGBGameModeActorInterface");

// Class GroundBranch.GBGameModeFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGBGameModeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetGameModeOptions(const class UObject* WorldContextObject);
	static class FString GetMissionExtension();
	static class FString GetMissionFileName(class UObject* WorldContextObject, const class FString& MissionName, const struct FUInt64& ModID);
	static class FString GetMissionScriptFileName(const class FString& ScriptName);
	static const int32 GetMissionVersion();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameModeFunctionLibrary">();
	}
	static class UGBGameModeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameModeFunctionLibrary>();
	}
};
static_assert(alignof(UGBGameModeFunctionLibrary) == 0x000008, "Wrong alignment on UGBGameModeFunctionLibrary");
static_assert(sizeof(UGBGameModeFunctionLibrary) == 0x000028, "Wrong size on UGBGameModeFunctionLibrary");

// Class GroundBranch.GBGameModeLuaState
// 0x0000 (0x02F0 - 0x02F0)
class UGBGameModeLuaState final : public ULuaState
{
public:
	void DebugPrint(const struct FLuaValue& Message);
	struct FLuaValue GetComp(const struct FLuaValue& Self);
	struct FLuaValue GetScript(const struct FLuaValue& Self);
	struct FLuaValue GetTimeSeconds();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameModeLuaState">();
	}
	static class UGBGameModeLuaState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameModeLuaState>();
	}
};
static_assert(alignof(UGBGameModeLuaState) == 0x000010, "Wrong alignment on UGBGameModeLuaState");
static_assert(sizeof(UGBGameModeLuaState) == 0x0002F0, "Wrong size on UGBGameModeLuaState");

// Class GroundBranch.GBGameplayAbility_BlockHostileActions
// 0x0000 (0x03B8 - 0x03B8)
class UGBGameplayAbility_BlockHostileActions final : public UGBGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameplayAbility_BlockHostileActions">();
	}
	static class UGBGameplayAbility_BlockHostileActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameplayAbility_BlockHostileActions>();
	}
};
static_assert(alignof(UGBGameplayAbility_BlockHostileActions) == 0x000008, "Wrong alignment on UGBGameplayAbility_BlockHostileActions");
static_assert(sizeof(UGBGameplayAbility_BlockHostileActions) == 0x0003B8, "Wrong size on UGBGameplayAbility_BlockHostileActions");

// Class GroundBranch.GBReadyRoomPlayerStart
// 0x0010 (0x0258 - 0x0248)
class AGBReadyRoomPlayerStart final : public ANavigationObjectBase
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         TeamId;                                            // 0x0250(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOpsArea;                                          // 0x0251(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_252[0x6];                                      // 0x0252(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBReadyRoomPlayerStart">();
	}
	static class AGBReadyRoomPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBReadyRoomPlayerStart>();
	}
};
static_assert(alignof(AGBReadyRoomPlayerStart) == 0x000008, "Wrong alignment on AGBReadyRoomPlayerStart");
static_assert(sizeof(AGBReadyRoomPlayerStart) == 0x000258, "Wrong size on AGBReadyRoomPlayerStart");
static_assert(offsetof(AGBReadyRoomPlayerStart, TeamId) == 0x000250, "Member 'AGBReadyRoomPlayerStart::TeamId' has a wrong offset!");
static_assert(offsetof(AGBReadyRoomPlayerStart, bOpsArea) == 0x000251, "Member 'AGBReadyRoomPlayerStart::bOpsArea' has a wrong offset!");

// Class GroundBranch.GBGameplayAbility_BlockMovement
// 0x0000 (0x03B8 - 0x03B8)
class UGBGameplayAbility_BlockMovement final : public UGBGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameplayAbility_BlockMovement">();
	}
	static class UGBGameplayAbility_BlockMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameplayAbility_BlockMovement>();
	}
};
static_assert(alignof(UGBGameplayAbility_BlockMovement) == 0x000008, "Wrong alignment on UGBGameplayAbility_BlockMovement");
static_assert(sizeof(UGBGameplayAbility_BlockMovement) == 0x0003B8, "Wrong size on UGBGameplayAbility_BlockMovement");

// Class GroundBranch.GBGameplayAbility_Death
// 0x0000 (0x03B8 - 0x03B8)
class UGBGameplayAbility_Death : public UGBGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameplayAbility_Death">();
	}
	static class UGBGameplayAbility_Death* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameplayAbility_Death>();
	}
};
static_assert(alignof(UGBGameplayAbility_Death) == 0x000008, "Wrong alignment on UGBGameplayAbility_Death");
static_assert(sizeof(UGBGameplayAbility_Death) == 0x0003B8, "Wrong size on UGBGameplayAbility_Death");

// Class GroundBranch.YourGameGauntletController
// 0x0008 (0x0038 - 0x0030)
class UYourGameGauntletController final : public UGauntletTestController
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartTesting();
	void StopProfiling();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"YourGameGauntletController">();
	}
	static class UYourGameGauntletController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UYourGameGauntletController>();
	}
};
static_assert(alignof(UYourGameGauntletController) == 0x000008, "Wrong alignment on UYourGameGauntletController");
static_assert(sizeof(UYourGameGauntletController) == 0x000038, "Wrong size on UYourGameGauntletController");

// Class GroundBranch.GBGameplayAbility_FreezeActions
// 0x0000 (0x03B8 - 0x03B8)
class UGBGameplayAbility_FreezeActions final : public UGBGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameplayAbility_FreezeActions">();
	}
	static class UGBGameplayAbility_FreezeActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameplayAbility_FreezeActions>();
	}
};
static_assert(alignof(UGBGameplayAbility_FreezeActions) == 0x000008, "Wrong alignment on UGBGameplayAbility_FreezeActions");
static_assert(sizeof(UGBGameplayAbility_FreezeActions) == 0x0003B8, "Wrong size on UGBGameplayAbility_FreezeActions");

// Class GroundBranch.GBGameplayAbility_ReadyRoom
// 0x0000 (0x03B8 - 0x03B8)
class UGBGameplayAbility_ReadyRoom final : public UGBGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameplayAbility_ReadyRoom">();
	}
	static class UGBGameplayAbility_ReadyRoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameplayAbility_ReadyRoom>();
	}
};
static_assert(alignof(UGBGameplayAbility_ReadyRoom) == 0x000008, "Wrong alignment on UGBGameplayAbility_ReadyRoom");
static_assert(sizeof(UGBGameplayAbility_ReadyRoom) == 0x0003B8, "Wrong size on UGBGameplayAbility_ReadyRoom");

// Class GroundBranch.GBUIFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGBUIFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void BindActionToKey(const class FName ActionName, const struct FInputBoundKey& TargetKey);
	static void BindAxisToKey(const class FName AxisName, const struct FInputBoundKey& TargetKey, float Scale);
	static void BindExecToKey(const class FString& ExecCommand, const struct FInputBoundKey& TargetKey);
	static void BreakGeometry(const struct FGeometry& Geometry, struct FVector2D* OutPosition, struct FVector2D* OutAbsolutePosition, struct FVector2D* OutSize, float* OutScale);
	static bool CheckForThreeLetterProfanity(const class FString& ThreeLetterCode);
	static class UGBDialogWidget* DisplayDialogWidget(class UObject* WorldContextObject, const class FName& DialogName, TSubclassOf<class UGBDialogWidget> DialogWidgetClass, const class FText& Title, const class FText& Message, const EGBMessageDialogType DialogType, const float SelfDestructTime);
	static bool DoesStringTableEntryExist(const class FName StringTableId, const class FString& InKey, const class FString& KeyPrefix, const struct FUInt64& ModID);
	static void FindScreenEdgeLocationForWorldLocation(const class UObject* WorldContextObject, const struct FVector& InLocation, const float EdgePercent, struct FVector2D* OutScreenPosition, float* OutRotationAngleDegrees, bool* bIsOnScreen);
	static void FindScreenEdgeLocationForWorldLocationAlt(const struct FTransform& ViewTM, const float FOV, const struct FVector2D& ScreenSize, const struct FVector& WorldLocation, const float EdgePercent, struct FVector2D* OutScreenPosition, float* OutRotationAngleDegrees, bool* bIsOnScreen);
	static void ForcePlayerInputUpdate(class APlayerController* Target);
	static struct FInputBoundKey GetBoundKeyFromKeyEvent(const struct FKeyEvent& KeyEvent);
	static void GetChildrenOfClass(class UWidget* ParentWidget, TArray<class UUserWidget*>* ChildWidgets, TSubclassOf<class UUserWidget> WidgetClass, bool bImmediateOnly);
	static void GetChildWidgetsOfClass(class UWidget* ParentWidget, TArray<class UWidget*>* ChildWidgets, TSubclassOf<class UWidget> WidgetClass, bool bImmediateOnly);
	static struct FInputBoundKey GetCommandBoundKey(const class FName Command);
	static TArray<struct FInputBoundKey> GetCommandBoundKeys(const class FName Command);
	static TArray<struct FKey> GetConsoleKeys();
	static float GetDoubleClickTime();
	static class UUserWidget* GetFirstChildOfClass(class UWidget* ParentWidget, TSubclassOf<class UUserWidget> WidgetClass, bool bImmediateOnly);
	static class UWidget* GetFirstChildWidgetOfClass(class UWidget* ParentWidget, TSubclassOf<class UWidget> WidgetClass, bool bImmediateOnly);
	static class UUserWidget* GetFirstWidgetOfClass(class UObject* WorldContextObject, TSubclassOf<class UUserWidget> WidgetClass, bool TopLevelOnly);
	static bool GetLayoutVariantBlueprints(const class FString& SearchPathName, TArray<TSoftObjectPtr<class AActor>>* OutActorPtrs);
	static class FText GetLocalisedGameplayTagText(const struct FGameplayTag& GameplayTag, const EGBLocalisedGameplayTagFormat GameplayTagFormat, const bool bStripSpaces);
	static bool GetMapInfo(const class FString& MapName, class FString* OutTitle, class FString* OutAuthor, class FText* OutDescription);
	static void GetMapList(const class FString& GameModePrefix, TArray<struct FMapListItem>* OutMapList);
	static bool GetMapScreenshots(const class FString& Prefix, const class FString& MapName, TArray<TSoftObjectPtr<class UTexture2D>>* OutScreenShotPtrs);
	static bool GetMonitorNativeResolutions(TArray<struct FVector2D>* OutMonitorResolutions);
	static class UUserWidget* GetParentOfClass(class UWidget* ChildWidget, TSubclassOf<class UUserWidget> WidgetClass);
	static class UWidget* GetParentWidgetOfClass(class UWidget* ChildWidget, TSubclassOf<class UWidget> WidgetClass);
	static class FText GetStringTableEntryOrDisplayString(const class FName StringTableId, const class FString& InKey, const class FString& KeyPrefix, const struct FUInt64& ModID);
	static class UWidget* GetWidgetFromName(class UUserWidget* ParentUserWidget, const class FName& Name_0);
	static bool InitStringTable(const class FName& StringTableId, const class FString& StringNameSpace);
	static bool InitStringTableForModID(const class FName StringTableId, const class FString& StringNameSpace, const struct FUInt64& ModID, const class UObject* WorldContextObject);
	static class UPanelSlot* InsertChildAt(class UWidget* Parent, int32 Index_0, class UWidget* Content);
	static bool IsChildOf(class UWidget* ChildWidget, class UWidget* PossibleParent);
	static void RemoveAllWidgetsOfClass(class UObject* WorldContextObject, TSubclassOf<class UUserWidget> WidgetClass, bool TopLevelOnly);
	static void SaveBinds();
	static void SetConsoleKeys(const TArray<struct FKey>& NewConsoleKeys);
	static void SetMousePosition(const struct FVector2D& MousePosition);
	static void UnBindCommand(const class FName CommandName);
	static void UnbindKey(const struct FInputBoundKey& TargetKey);
	static void UnbindKeybindCommand(const class FName CommandName, const struct FKey& Key);
	static class UTextureRenderTarget2D* WriteWidgetToTexture(class UUserWidget* WidgetToWrite, const int32 SizeX, const int32 SizeY);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBUIFunctionLibrary">();
	}
	static class UGBUIFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBUIFunctionLibrary>();
	}
};
static_assert(alignof(UGBUIFunctionLibrary) == 0x000008, "Wrong alignment on UGBUIFunctionLibrary");
static_assert(sizeof(UGBUIFunctionLibrary) == 0x000028, "Wrong size on UGBUIFunctionLibrary");

// Class GroundBranch.GBGameplayAbilitySet
// 0x0010 (0x0040 - 0x0030)
class UGBGameplayAbilitySet final : public UPrimaryDataAsset
{
public:
	TArray<struct FGBAbilitySet_GameplayAbility>  GameplayAbilities;                                 // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameplayAbilitySet">();
	}
	static class UGBGameplayAbilitySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameplayAbilitySet>();
	}
};
static_assert(alignof(UGBGameplayAbilitySet) == 0x000008, "Wrong alignment on UGBGameplayAbilitySet");
static_assert(sizeof(UGBGameplayAbilitySet) == 0x000040, "Wrong size on UGBGameplayAbilitySet");
static_assert(offsetof(UGBGameplayAbilitySet, GameplayAbilities) == 0x000030, "Member 'UGBGameplayAbilitySet::GameplayAbilities' has a wrong offset!");

// Class GroundBranch.GBGameplayEffect_BlockHostileActions
// 0x0000 (0x0800 - 0x0800)
class UGBGameplayEffect_BlockHostileActions final : public UGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameplayEffect_BlockHostileActions">();
	}
	static class UGBGameplayEffect_BlockHostileActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameplayEffect_BlockHostileActions>();
	}
};
static_assert(alignof(UGBGameplayEffect_BlockHostileActions) == 0x000008, "Wrong alignment on UGBGameplayEffect_BlockHostileActions");
static_assert(sizeof(UGBGameplayEffect_BlockHostileActions) == 0x000800, "Wrong size on UGBGameplayEffect_BlockHostileActions");

// Class GroundBranch.GBGameplayEffect_CeaseFireAndHold
// 0x0000 (0x0800 - 0x0800)
class UGBGameplayEffect_CeaseFireAndHold final : public UGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameplayEffect_CeaseFireAndHold">();
	}
	static class UGBGameplayEffect_CeaseFireAndHold* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameplayEffect_CeaseFireAndHold>();
	}
};
static_assert(alignof(UGBGameplayEffect_CeaseFireAndHold) == 0x000008, "Wrong alignment on UGBGameplayEffect_CeaseFireAndHold");
static_assert(sizeof(UGBGameplayEffect_CeaseFireAndHold) == 0x000800, "Wrong size on UGBGameplayEffect_CeaseFireAndHold");

// Class GroundBranch.GBGameplayEffect_FreezeActions
// 0x0000 (0x0800 - 0x0800)
class UGBGameplayEffect_FreezeActions final : public UGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameplayEffect_FreezeActions">();
	}
	static class UGBGameplayEffect_FreezeActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameplayEffect_FreezeActions>();
	}
};
static_assert(alignof(UGBGameplayEffect_FreezeActions) == 0x000008, "Wrong alignment on UGBGameplayEffect_FreezeActions");
static_assert(sizeof(UGBGameplayEffect_FreezeActions) == 0x000800, "Wrong size on UGBGameplayEffect_FreezeActions");

// Class GroundBranch.GBGameplayEffect_RestrictedArea
// 0x0000 (0x0800 - 0x0800)
class UGBGameplayEffect_RestrictedArea final : public UGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameplayEffect_RestrictedArea">();
	}
	static class UGBGameplayEffect_RestrictedArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameplayEffect_RestrictedArea>();
	}
};
static_assert(alignof(UGBGameplayEffect_RestrictedArea) == 0x000008, "Wrong alignment on UGBGameplayEffect_RestrictedArea");
static_assert(sizeof(UGBGameplayEffect_RestrictedArea) == 0x000800, "Wrong size on UGBGameplayEffect_RestrictedArea");

// Class GroundBranch.GBGameplayEffect_SpawnAreaWarning
// 0x0000 (0x0800 - 0x0800)
class UGBGameplayEffect_SpawnAreaWarning final : public UGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameplayEffect_SpawnAreaWarning">();
	}
	static class UGBGameplayEffect_SpawnAreaWarning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameplayEffect_SpawnAreaWarning>();
	}
};
static_assert(alignof(UGBGameplayEffect_SpawnAreaWarning) == 0x000008, "Wrong alignment on UGBGameplayEffect_SpawnAreaWarning");
static_assert(sizeof(UGBGameplayEffect_SpawnAreaWarning) == 0x000800, "Wrong size on UGBGameplayEffect_SpawnAreaWarning");

// Class GroundBranch.GBGameplayEffect_SpawnProtection
// 0x0000 (0x0800 - 0x0800)
class UGBGameplayEffect_SpawnProtection final : public UGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameplayEffect_SpawnProtection">();
	}
	static class UGBGameplayEffect_SpawnProtection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameplayEffect_SpawnProtection>();
	}
};
static_assert(alignof(UGBGameplayEffect_SpawnProtection) == 0x000008, "Wrong alignment on UGBGameplayEffect_SpawnProtection");
static_assert(sizeof(UGBGameplayEffect_SpawnProtection) == 0x000800, "Wrong size on UGBGameplayEffect_SpawnProtection");

// Class GroundBranch.GBGameplayStatics
// 0x0000 (0x0028 - 0x0028)
class UGBGameplayStatics final : public UBlueprintFunctionLibrary
{
public:
	static float ApplyRadialDamageDirect(class AActor* DamagedActor, float MaxDamage, float MinDamage, float MinDamageRadius, float MaxDamageRadius, float DamageFalloff, const struct FVector& Origin, const TArray<struct FHitResult>& HitResults, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass);
	static bool CanDamageSkeletalMesh(class USkeletalMeshComponent* SkeletalComp, const struct FVector& DamageOrigin, const TArray<class FName>& Bones, const TArray<class AActor*>& IgnoreActors, ECollisionChannel TraceChannel, const TArray<EPhysicalSurface>& SurfaceTypesToIgnore, struct FHitResult* OutHit);
	static bool CanDamageStaticMesh(class UStaticMeshComponent* StaticComp, const struct FVector& DamageOrigin, int32 MaxTraceChecks, const TArray<class AActor*>& IgnoreActors, ECollisionChannel TraceChannel, const TArray<EPhysicalSurface>& SurfaceTypesToIgnore, struct FHitResult* OutHit);
	static bool ConeOverlapActors(const class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& dir, float ConeHalfAngle, float Radius, float ClipDistance, const TArray<class AActor*>& IgnoreActors, const TArray<EObjectTypeQuery>& ObjectTypes, TArray<class AActor*>* OutActors, EDrawDebugTrace DrawDebugType, float DrawTime);
	static bool ConeOverlapDamageableComponentsSorted(const class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& dir, float ConeHalfAngle, float Radius, float ClipDistance, const TArray<class AActor*>& IgnoreActors, const TArray<EObjectTypeQuery>& ObjectTypes, TArray<class UPrimitiveComponent*>* OutComponents, EDrawDebugTrace DrawDebugType, float DrawTime);
	static bool EncompassesPoint(class AVolume* Volume, const struct FVector& Point, float SphereRadius, float* OutDistanceToPoint);
	static class AGBPlayerController* FindPlayerControllerByPlayerNameOrUniqueId(const class UObject* WorldContextObject, const class FString& PlayerNameOrUniqueId);
	static class AGBPlayerState* FindPlayerStateByPlayerNameOrUniqueId(const class UObject* WorldContextObject, const class FString& PlayerNameOrUniqueId);
	static class AGBPlayerController* GetLocallyViewingPlayerController(const class AActor* Viewed);
	static class AGBPlayerState* GetPlayerStateFromPlayerID(const class UObject* WorldContextObject, int32 PlayerId);
	static float GetPredictionTime(class AActor* Target);
	static void GetReplicatedAlphaValues(const struct FReplicatedAlpha& ReplicatedAlpha, float* CurrentAlpha, float* TargetAlpha, float* Timestamp);
	static class FName GetSpatialAudioVolumeTag(const class UObject* WorldContextObject, const struct FVector& position);
	static class FString GetUniqueIdAsString(const class APlayerState* PlayerState);
	static bool GetValidatedSpawnLocation(const class UObject* WorldContextObject, const struct FVector& SpawnLocation, const float& CapsuleHalfHeight, const float& CapsuleRadius, bool bShowDebug, struct FVector* OutValidatedSpawnLocation);
	static float GetWaterLevelAtPosition(const class UObject* WorldContextObject, const struct FVector& position, const ECollisionChannel CollisionChannel);
	static bool GrabAllOptions(const class FString& Options, TArray<class FString>* OutKeys, TArray<class FString>* OutValues);
	static bool IsDevBuild();
	static bool IsLocallyViewed(const class AActor* Viewed);
	static bool IsNetReady(const class APlayerController* PlayerController);
	static bool IsSpawnLocationValid(const class UObject* WorldContextObject, const struct FVector& SpawnLocation, const float& CapsuleHalfHeight, const float& CapsuleRadius);
	static bool LineTraceRecursiveForObjects(const class UObject* WorldContextObject, const struct FVector& TraceStart, const struct FVector& TraceEnd, const TArray<EObjectTypeQuery>& ObjectTypes, const TArray<ECollisionChannel>& BlockedCollisionChannels, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, struct FHitResult* OutHit, bool bDebug, float DebugDrawTime);
	static void NukeActor(class AActor* Target);
	static void ResetActor(class AActor* Target);
	static void ResetActors(const class UObject* WorldContextObject);
	static void ResetActorsExceptSpecifiedClasses(const class UObject* WorldContextObject, const TArray<TSoftClassPtr<class UClass>>& ClassesToExclude);
	static void ResetEncompassedActors(class AVolume* Volume);
	static void SetReplicatedAlphaValues(const class UObject* WorldContextObject, struct FReplicatedAlpha& ReplicatedAlpha, float CurrentAlpha, float TargetAlpha);
	static bool SphereOverlapDamageableComponentsSorted(const class UObject* WorldContextObject, const struct FVector& Origin, float Radius, const TArray<class AActor*>& IgnoreActors, const TArray<EObjectTypeQuery>& ObjectTypes, TArray<class UPrimitiveComponent*>* OutComponents);
	static void TeleportControlledPawn(class APawn* TargetPawn, const struct FVector& TargetLocation, const struct FRotator& TargetRotation);
	static void WaitForWorldToBeReadyForLocalPlayer(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static bool WorldIsReadyForLocalPlayer(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameplayStatics">();
	}
	static class UGBGameplayStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameplayStatics>();
	}
};
static_assert(alignof(UGBGameplayStatics) == 0x000008, "Wrong alignment on UGBGameplayStatics");
static_assert(sizeof(UGBGameplayStatics) == 0x000028, "Wrong size on UGBGameplayStatics");

// Class GroundBranch.GBGameSession
// 0x0030 (0x0268 - 0x0238)
class AGBGameSession final : public AGameSession
{
public:
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         QuickAdminCommands;                                // 0x0240(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x18];                                     // 0x0250(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MutePlayer(class APlayerState* Player);
	void UpdatePlayerAndModList();
	void UpdateServerDetails();
	void UpdateServerDetailsTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameSession">();
	}
	static class AGBGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBGameSession>();
	}
};
static_assert(alignof(AGBGameSession) == 0x000008, "Wrong alignment on AGBGameSession");
static_assert(sizeof(AGBGameSession) == 0x000268, "Wrong size on AGBGameSession");
static_assert(offsetof(AGBGameSession, QuickAdminCommands) == 0x000240, "Member 'AGBGameSession::QuickAdminCommands' has a wrong offset!");

// Class GroundBranch.GBGameState
// 0x0578 (0x07E8 - 0x0270)
class AGBGameState : public AGameStateBase
{
public:
	TArray<struct FGBTeamInfo>                    PlayerTeamInfoArray;                               // 0x0270(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         VotingCommands;                                    // 0x0280(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         PermittedGameModes;                                // 0x0290(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         PermittedMissionList;                              // 0x02A0(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGBModBasicInfo>                ServerModList;                                     // 0x02B0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         bPlayAreaOpen : 1;                                 // 0x02C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2C1[0xA7];                                     // 0x02C1(0x00A7)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReplicatedTeamAttitudes;                           // 0x0368(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnServerBasicInfoUpdatedEvent;     // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGBServerBasicInfo                     ServerBasicInfo;                                   // 0x0390(0x0030)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         Difficulty;                                        // 0x03C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TimeLimit;                                         // 0x03C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinPlayers;                                        // 0x03C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            AARWidget;                                         // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            MatchWidget;                                       // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnDifficultySet;                   // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnMinPlayersSet;                   // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   RoundStage;                                        // 0x0400(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RoundStageTime;                                    // 0x0408(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40C[0x4];                                      // 0x040C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnRoundStageSet;                   // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         RoundTime;                                         // 0x0420(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnRoundTimeSet;                    // 0x0428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FGBReplicatedString>            PlayerLoadouts;                                    // 0x0438(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         GameStats;                                         // 0x0448(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnGameStatsUpdated;                // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnMissionNameUpdated;              // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGBMissionName                         MissionName;                                       // 0x0480(0x0020)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0x18];                                     // 0x04A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LastMissionFileName;                               // 0x04B8(0x0010)(Net, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnTeamScoresUpdated;               // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<uint8, struct FGBScoreCollection>        TeamScoresMap;                                     // 0x04D8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         ReplicatedTeamScoreLists;                          // 0x0528(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGBScoreCollection                     PlayerScoresTemplate;                              // 0x0538(0x0010)(Protected, NativeAccessSpecifierProtected)
	uint8                                         bPlayerScoresTemplateInitialised : 1;              // 0x0548(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_549[0x7];                                      // 0x0549(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnMatchStatsUpdated;               // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGBMatchStats                          MatchStats;                                        // 0x0560(0x0028)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bRoundIsTemporaryGameMode;                         // 0x0588(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVolunteersAllowed;                                // 0x0589(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGBMatchInfo                           MatchInfo;                                         // 0x058A(0x0004)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_58E[0x2];                                      // 0x058E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GameModeName;                                      // 0x0590(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUInt64                                GameModeModID;                                     // 0x0598(0x0008)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MatchStartTime;                                    // 0x05A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A4[0x4];                                      // 0x05A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnGameModeNameUpdated;             // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bUsesReadyRoom : 1;                                // 0x05B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsRoundBased : 1;                                 // 0x05B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_5B9[0x57];                                     // 0x05B9(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReplicatedGameRules;                               // 0x0610(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_620[0x8];                                      // 0x0620(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGBMissionSetting>              MissionSettings;                                   // 0x0628(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	class FName                                   CurrentVariantName;                                // 0x0638(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGBGameModeType                               GameModeType;                                      // 0x0640(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanRandomiseObjectives;                           // 0x0641(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_642[0x6];                                      // 0x0642(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnPlayerLoadoutsUpdated;           // 0x0648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnGameRulesUpdated;                // 0x0658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnMissionSettingsUpdated;          // 0x0668(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FGBGameObjective>               GameObjectives;                                    // 0x0678(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGBGameObjective>               SearchLocations;                                   // 0x0688(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_698[0x10];                                     // 0x0698(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           GameStringTableIds;                                // 0x06A8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnGameObjectivesUpdated;           // 0x06B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnSearchLocationsUpdated;          // 0x06C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnWatchModeChanged;                // 0x06D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnWatchConfigChanged;              // 0x06E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnCaptureStateChanged;             // 0x06F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnCaptureZoneChanged;              // 0x0708(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnObjectiveLocationChanged;        // 0x0718(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnRoundTimeAlert;                  // 0x0728(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EWatchMode                                    WatchMode;                                         // 0x0738(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         WatchConfig;                                       // 0x0739(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCapturing;                                      // 0x073A(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_73B[0x1];                                      // 0x073B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGBCaptureZone                         CaptureZone;                                       // 0x073C(0x000C)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector_NetQuantize                    ObjectiveLocation;                                 // 0x0748(0x000C)(Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_754[0x4];                                      // 0x0754(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBGameState* GameState)> OnNextMapVoteChoicesChanged;       // 0x0758(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FString>                         NextMapVoteChoices;                                // 0x0768(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_778[0x8];                                      // 0x0778(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AIMuzzleFlashProbability;                          // 0x0780(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ServerNetMode;                                     // 0x0784(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_785[0x3];                                      // 0x0785(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBGameTrigger* GameTrigger, class AGBSearchableProp* SearchedActor)> OnIntelSearchCompleted; // 0x0788(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBMissionObjective* MissionObjective)> OnMissionObjectiveStatusChanged; // 0x0798(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   HotspotName;                                       // 0x07A8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MissionSequenceNumber;                             // 0x07B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B4[0x4];                                      // 0x07B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGBMapMarker>                   MapMarkerList;                                     // 0x07B8(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGBCampaignMissionObjectiveInfo> CampaignMissionObjectiveInfoList;                 // 0x07C8(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         BedtimeStartHour;                                  // 0x07D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BedtimeEndHour;                                    // 0x07DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseStandardHourForBedtimes;                       // 0x07E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E1[0x7];                                      // 0x07E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString GetMissionSettingConfigSectionName(const class FString& InGameModeName);

	void AddGameObjective(uint8 TeamId, class FName Name_0, EGBGameObjectiveType ObjectiveType);
	void AddGameStat(const class FString& StatString);
	void AddMissionSetting(class FString* Name_0, int32 MinValue, int32 MaxValue, int32 CurrentValue);
	void AddPlayerScoreType(class FName ScoreName, const class FString& ScoreDescription, int32 ScoreToAdd, bool OneOff);
	void AddPlayerTeamInfo(uint8 TeamId, const struct FGBTeamInfo& NewPlayerTeam);
	void AddScoreToCumulativeRoundsWon(uint8 TeamId, int32 ScoreToAdd);
	void AddScoreToCumulativeScore(uint8 TeamId, int32 ScoreToAdd);
	void AddSearchLocation(uint8 TeamId, class FName Name_0, EGBGameObjectiveType ObjectiveType);
	void AddTeamScoreType(class FName ScoreName, const class FString& ScoreDescription, int32 ScoreToAdd, bool OneOff);
	void AwardTeamScore(uint8 TeamId, class FName ScoreName, int32 ScoreMultiple);
	void ClearGameObjectives();
	void ClearGameStats();
	void ClearPlayerScores();
	void ClearPlayerScoresTemplate();
	void ClearSearchLocations();
	void ClearTeamScores();
	void CreateTeamScores(uint8 TeamId);
	void DecrementRoundNumber();
	void ForceResetActors();
	TMap<class FName, bool> GetGameRules();
	TArray<class FString> GetGameStats();
	class FText GetLocalisedGameText(const class FString& Key, const class FString& DefaultValue, const struct FUInt64& ModID, const bool bPrettifyDefault);
	class FText GetMissionName();
	class FString GetPlayerRichPresenceStatus();
	TArray<struct FGBScoreLine> GetScoreListForTeam(uint8 TeamId);
	ETeamAttitude GetTeamAttitude(const struct FGenericTeamId& A, const struct FGenericTeamId& B);
	void IncrementRoundNumber();
	void MulticastTimeRemainingAlertToWatches();
	void NotifyMissionObjectiveStatusChanged(class AGBMissionObjective* MissionObjective, const EGBMissionObjectiveStatus NewMissionObjectiveStatus);
	void OnGameMessageEvent(class FName GameMessageId, class FName Type, float Duration, const struct FUInt64& ModID);
	void OnRep_CaptureState();
	void OnRep_CaptureZone();
	void OnRep_Difficulty();
	void OnRep_GameModeName();
	void OnRep_GameObjectives();
	void OnRep_GameRules();
	void OnRep_GameStats();
	void OnRep_GameStringTables();
	void OnRep_IsRoundBased();
	void OnRep_MatchStats();
	void OnRep_MinPlayers();
	void OnRep_MissionName();
	void OnRep_MissionSettings();
	void OnRep_NextMapVoteChoices();
	void OnRep_ObjectiveLocation();
	void OnRep_PlayerLoadouts();
	void OnRep_RoundStage();
	void OnRep_RoundTime();
	void OnRep_SearchLocations();
	void OnRep_ServerBasicInfo();
	void OnRep_ServerModList();
	void OnRep_TeamAttitudes();
	void OnRep_TeamScoreLists();
	void OnRep_UsesReadyRoom();
	void OnRep_WatchConfig();
	void OnRep_WatchMode();
	void OnServerSettingsUpdated();
	void OnVoteCountUpdated(int32 YesVotes, int32 NoVotes);
	void OnVoteCountUpdatedEvent(int32 YesVotes, int32 NoVotes);
	void OnVoteEnded(bool bPassed, int32 NextVoteDelay);
	void OnVoteEndedEvent(bool bPassed, int32 NextVoteDelay);
	void OnVoteStarted(class APlayerState* VoteStarter, const class FString& Command, const class FString& Params_0, int32 VoteTime);
	void OnVoteStartedEvent(class APlayerState* VoteStarter, const class FString& Command, const class FString& Params_0, int32 VoteTime);
	void RegisterMissionObjective(class AGBMissionObjective* MissionObjective);
	void ReportClientMissingAsset(const class FString& AssetName);
	void ResetMatchStats();
	void ResetPlayerScores();
	void ResetTeamScores();
	void RoundStageSet();
	void SendTimeRemainingAlertToWatches();
	void ServerPrepMissionSummaryEvent();
	void SetAARWidget(class UUserWidget* NewAARWidget);
	void SetBedtimeHours(const float InBedtimeStartHour, const float InBedtimeEndHour, const bool bInUseStandardHourForBedtimes);
	void SetCanRandomiseObjectives(const bool bInCanRandomiseObjectives);
	void SetCaptureZone(float InCaptureRadius, float InCaptureHeight, uint8 DefenderTeamId, bool InZoneIsSpherical);
	void SetGameModeModID(const struct FUInt64& NewGameModeModID);
	void SetGameModeName(class FName InGameModeName);
	void SetGameModeType(const EGBGameModeType InGameModeType);
	void SetHotspotName(const class FName InHotspotName);
	void SetIsCapturing(bool bNewIsCapturing);
	void SetLastMissionFileName(const class FString& InLastMissionFileName);
	void SetMapMarkerList(const TArray<struct FGBMapMarker>& InMapMarkerList);
	void SetMatchInfo(const struct FGBMatchInfo& NewMatchInfo);
	void SetMatchStartTime(const float NewMatchStartTime);
	void SetMatchWidget(class UUserWidget* NewMatchWidget);
	void SetMissionSequenceNumber(const int32 InMissionSequenceNumber);
	void SetMissionSettingValue(const class FString& Name_0, const int32& NewValue);
	void SetObjectiveLocation(const struct FVector& InObjectiveLocation);
	void SetPlayAreaOpen(bool bIsOpen);
	void SetPlayerTeamRole(uint8 TeamId, class FName InRole);
	void SetRoundIsTemporaryGameMode(bool bRoundIsTemporaryGameMode_0);
	void SetServerBasicInfo(const struct FGBServerBasicInfo& NewServerBasicInfo);
	void SetServerModList(const TArray<struct FGBModBasicInfo>& InServerModList);
	void SetTeamAttitude(const struct FGenericTeamId& Team, const struct FGenericTeamId& OtherTeam, ETeamAttitude Attitude);
	void SetVolunteersAllowed(bool bNewVolunteersAllowed);
	void SetWatchConfig(uint8 InWatchConfig);
	void SetWatchMode(EWatchMode InWatchMode);
	void SyncTeamScoreLists();
	void UpdatedGameRules();
	void UpdatedGameStats();
	void UpdatedTeamAttitudes();
	void UpdateMatchStatsAfterRoundEnd();

	bool ArePlayerScoresInitialised() const;
	bool AreTeamScoresInitialised() const;
	void BroadcastGameMessage(class FName GameMessageId, class FName Type, float Duration, const struct FUInt64& ModID) const;
	bool DoesClientHostMod(const struct FUInt64& ModIDToCheck) const;
	bool DoesHostAllowPrimaryAsset(const struct FPrimaryAssetId& PrimaryAssetId) const;
	bool DoesServerHostMod(const struct FUInt64& ModIDToCheck) const;
	class UUserWidget* GetAARWidget() const;
	uint8 GetAdjustedPlayerTeamId(uint8 TeamId) const;
	void GetBedtimeHours(float* OutBedtimeStartHour, float* OutBedtimeEndHour, bool* bOutUseStandardHourForBedtimes) const;
	TSubclassOf<class UUserWidget> GetBriefingRoomWidget() const;
	struct FGBCampaignMissionObjectiveInfo GetCampaignMissionObjectiveInfoByRef(const TSoftObjectPtr<class AGBMissionObjective> MissionObjectiveRef) const;
	struct FGBCampaignMissionObjectiveInfo GetCampaignMissionObjectiveInfoByTitle(const class FString& ObjectiveTitle) const;
	TArray<struct FGBCampaignMissionObjectiveInfo> GetCampaignMissionObjectiveInfoList() const;
	bool GetCanRandomiseObjectives() const;
	struct FGBCaptureZone GetCaptureZone() const;
	int32 GetCumulativeRoundsWonForTeam(uint8 TeamId) const;
	int32 GetCumulativeScoreForTeam(uint8 TeamId) const;
	class FName GetCurrentVariantName() const;
	int32 GetDifficulty() const;
	TArray<class AGBPlayerState*> GetEnemyPlayerList(uint8 TeamId, bool bExcludeBots) const;
	struct FUInt64 GetGameModeModID() const;
	class FName GetGameModeName() const;
	EGBGameModeType GetGameModeType() const;
	TArray<struct FGBGameObjective> GetGameObjectives() const;
	class FString GetGameStatValue(const class FString& Key) const;
	class FName GetHotspotName() const;
	bool GetIsCapturing() const;
	class FString GetLastMissionFileName() const;
	TArray<struct FGBMapMarker> GetMapMarkerList() const;
	struct FGBMatchInfo GetMatchInfo() const;
	float GetMatchStartTime() const;
	struct FGBMatchStats GetMatchStats() const;
	class FString GetMatchTypeString() const;
	class UUserWidget* GetMatchWidget() const;
	int32 GetMinPlayers() const;
	int32 GetMissionSequenceNumber() const;
	struct FGBMissionSetting GetMissionSetting(const class FString& Name_0) const;
	TArray<struct FGBMissionSetting> GetMissionSettings() const;
	TArray<class FString> GetNextMapVoteChoices() const;
	int32 GetNumPlayers(uint8 TeamId, bool bExcludeBots) const;
	struct FVector GetObjectiveLocation() const;
	TArray<class FString> GetPermittedGameModes() const;
	TArray<class FString> GetPermittedMissionList() const;
	TArray<class AGBPlayerState*> GetPlayerList(uint8 TeamId, bool bExcludeBots) const;
	struct FGBScoreCollection GetPlayerScoreTemplate() const;
	int32 GetPlayerTeamCount() const;
	uint8 GetPlayerTeamIdSafe(uint8 TeamId) const;
	struct FGBTeamInfo GetPlayerTeamInfo(uint8 TeamId) const;
	TArray<struct FGBTeamInfo> GetPlayerTeamInfos() const;
	bool GetRoundIsTemporaryGameMode() const;
	int32 GetRoundNumber() const;
	class FName GetRoundStage() const;
	float GetRoundStageTime() const;
	int32 GetRoundTime() const;
	TArray<struct FGBGameObjective> GetSearchLocations() const;
	struct FGBServerBasicInfo GetServerBasicInfo() const;
	TArray<struct FGBModBasicInfo> GetServerModList() const;
	bool GetServerUsesMods() const;
	int32 GetTeamElementCount(const uint8 TeamId, bool bInPlayOnly) const;
	int32 GetTimeLimit() const;
	bool GetVolunteersAllowed() const;
	TArray<class FString> GetVotingCommands() const;
	uint8 GetWatchConfig() const;
	EWatchMode GetWatchMode() const;
	int32 GetWinningTeamForMatch() const;
	int32 GetWinningTeamForRound() const;
	bool HasMissionSetting(const class FString& Name_0) const;
	bool IsGameRuleEnabled(class FName RuleName) const;
	bool IsRoundBased() const;
	void NotifyIntelSearchCompleted(class AGBGameTrigger* GameTrigger, class AGBSearchableProp* SearchablePropActor) const;
	bool PlayAreaOpen() const;
	bool UsesReadyRoom() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameState">();
	}
	static class AGBGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBGameState>();
	}
};
static_assert(alignof(AGBGameState) == 0x000008, "Wrong alignment on AGBGameState");
static_assert(sizeof(AGBGameState) == 0x0007E8, "Wrong size on AGBGameState");
static_assert(offsetof(AGBGameState, PlayerTeamInfoArray) == 0x000270, "Member 'AGBGameState::PlayerTeamInfoArray' has a wrong offset!");
static_assert(offsetof(AGBGameState, VotingCommands) == 0x000280, "Member 'AGBGameState::VotingCommands' has a wrong offset!");
static_assert(offsetof(AGBGameState, PermittedGameModes) == 0x000290, "Member 'AGBGameState::PermittedGameModes' has a wrong offset!");
static_assert(offsetof(AGBGameState, PermittedMissionList) == 0x0002A0, "Member 'AGBGameState::PermittedMissionList' has a wrong offset!");
static_assert(offsetof(AGBGameState, ServerModList) == 0x0002B0, "Member 'AGBGameState::ServerModList' has a wrong offset!");
static_assert(offsetof(AGBGameState, ReplicatedTeamAttitudes) == 0x000368, "Member 'AGBGameState::ReplicatedTeamAttitudes' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnServerBasicInfoUpdatedEvent) == 0x000380, "Member 'AGBGameState::OnServerBasicInfoUpdatedEvent' has a wrong offset!");
static_assert(offsetof(AGBGameState, ServerBasicInfo) == 0x000390, "Member 'AGBGameState::ServerBasicInfo' has a wrong offset!");
static_assert(offsetof(AGBGameState, Difficulty) == 0x0003C0, "Member 'AGBGameState::Difficulty' has a wrong offset!");
static_assert(offsetof(AGBGameState, TimeLimit) == 0x0003C4, "Member 'AGBGameState::TimeLimit' has a wrong offset!");
static_assert(offsetof(AGBGameState, MinPlayers) == 0x0003C8, "Member 'AGBGameState::MinPlayers' has a wrong offset!");
static_assert(offsetof(AGBGameState, AARWidget) == 0x0003D0, "Member 'AGBGameState::AARWidget' has a wrong offset!");
static_assert(offsetof(AGBGameState, MatchWidget) == 0x0003D8, "Member 'AGBGameState::MatchWidget' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnDifficultySet) == 0x0003E0, "Member 'AGBGameState::OnDifficultySet' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnMinPlayersSet) == 0x0003F0, "Member 'AGBGameState::OnMinPlayersSet' has a wrong offset!");
static_assert(offsetof(AGBGameState, RoundStage) == 0x000400, "Member 'AGBGameState::RoundStage' has a wrong offset!");
static_assert(offsetof(AGBGameState, RoundStageTime) == 0x000408, "Member 'AGBGameState::RoundStageTime' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnRoundStageSet) == 0x000410, "Member 'AGBGameState::OnRoundStageSet' has a wrong offset!");
static_assert(offsetof(AGBGameState, RoundTime) == 0x000420, "Member 'AGBGameState::RoundTime' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnRoundTimeSet) == 0x000428, "Member 'AGBGameState::OnRoundTimeSet' has a wrong offset!");
static_assert(offsetof(AGBGameState, PlayerLoadouts) == 0x000438, "Member 'AGBGameState::PlayerLoadouts' has a wrong offset!");
static_assert(offsetof(AGBGameState, GameStats) == 0x000448, "Member 'AGBGameState::GameStats' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnGameStatsUpdated) == 0x000458, "Member 'AGBGameState::OnGameStatsUpdated' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnMissionNameUpdated) == 0x000468, "Member 'AGBGameState::OnMissionNameUpdated' has a wrong offset!");
static_assert(offsetof(AGBGameState, MissionName) == 0x000480, "Member 'AGBGameState::MissionName' has a wrong offset!");
static_assert(offsetof(AGBGameState, LastMissionFileName) == 0x0004B8, "Member 'AGBGameState::LastMissionFileName' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnTeamScoresUpdated) == 0x0004C8, "Member 'AGBGameState::OnTeamScoresUpdated' has a wrong offset!");
static_assert(offsetof(AGBGameState, TeamScoresMap) == 0x0004D8, "Member 'AGBGameState::TeamScoresMap' has a wrong offset!");
static_assert(offsetof(AGBGameState, ReplicatedTeamScoreLists) == 0x000528, "Member 'AGBGameState::ReplicatedTeamScoreLists' has a wrong offset!");
static_assert(offsetof(AGBGameState, PlayerScoresTemplate) == 0x000538, "Member 'AGBGameState::PlayerScoresTemplate' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnMatchStatsUpdated) == 0x000550, "Member 'AGBGameState::OnMatchStatsUpdated' has a wrong offset!");
static_assert(offsetof(AGBGameState, MatchStats) == 0x000560, "Member 'AGBGameState::MatchStats' has a wrong offset!");
static_assert(offsetof(AGBGameState, bRoundIsTemporaryGameMode) == 0x000588, "Member 'AGBGameState::bRoundIsTemporaryGameMode' has a wrong offset!");
static_assert(offsetof(AGBGameState, bVolunteersAllowed) == 0x000589, "Member 'AGBGameState::bVolunteersAllowed' has a wrong offset!");
static_assert(offsetof(AGBGameState, MatchInfo) == 0x00058A, "Member 'AGBGameState::MatchInfo' has a wrong offset!");
static_assert(offsetof(AGBGameState, GameModeName) == 0x000590, "Member 'AGBGameState::GameModeName' has a wrong offset!");
static_assert(offsetof(AGBGameState, GameModeModID) == 0x000598, "Member 'AGBGameState::GameModeModID' has a wrong offset!");
static_assert(offsetof(AGBGameState, MatchStartTime) == 0x0005A0, "Member 'AGBGameState::MatchStartTime' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnGameModeNameUpdated) == 0x0005A8, "Member 'AGBGameState::OnGameModeNameUpdated' has a wrong offset!");
static_assert(offsetof(AGBGameState, ReplicatedGameRules) == 0x000610, "Member 'AGBGameState::ReplicatedGameRules' has a wrong offset!");
static_assert(offsetof(AGBGameState, MissionSettings) == 0x000628, "Member 'AGBGameState::MissionSettings' has a wrong offset!");
static_assert(offsetof(AGBGameState, CurrentVariantName) == 0x000638, "Member 'AGBGameState::CurrentVariantName' has a wrong offset!");
static_assert(offsetof(AGBGameState, GameModeType) == 0x000640, "Member 'AGBGameState::GameModeType' has a wrong offset!");
static_assert(offsetof(AGBGameState, bCanRandomiseObjectives) == 0x000641, "Member 'AGBGameState::bCanRandomiseObjectives' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnPlayerLoadoutsUpdated) == 0x000648, "Member 'AGBGameState::OnPlayerLoadoutsUpdated' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnGameRulesUpdated) == 0x000658, "Member 'AGBGameState::OnGameRulesUpdated' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnMissionSettingsUpdated) == 0x000668, "Member 'AGBGameState::OnMissionSettingsUpdated' has a wrong offset!");
static_assert(offsetof(AGBGameState, GameObjectives) == 0x000678, "Member 'AGBGameState::GameObjectives' has a wrong offset!");
static_assert(offsetof(AGBGameState, SearchLocations) == 0x000688, "Member 'AGBGameState::SearchLocations' has a wrong offset!");
static_assert(offsetof(AGBGameState, GameStringTableIds) == 0x0006A8, "Member 'AGBGameState::GameStringTableIds' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnGameObjectivesUpdated) == 0x0006B8, "Member 'AGBGameState::OnGameObjectivesUpdated' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnSearchLocationsUpdated) == 0x0006C8, "Member 'AGBGameState::OnSearchLocationsUpdated' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnWatchModeChanged) == 0x0006D8, "Member 'AGBGameState::OnWatchModeChanged' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnWatchConfigChanged) == 0x0006E8, "Member 'AGBGameState::OnWatchConfigChanged' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnCaptureStateChanged) == 0x0006F8, "Member 'AGBGameState::OnCaptureStateChanged' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnCaptureZoneChanged) == 0x000708, "Member 'AGBGameState::OnCaptureZoneChanged' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnObjectiveLocationChanged) == 0x000718, "Member 'AGBGameState::OnObjectiveLocationChanged' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnRoundTimeAlert) == 0x000728, "Member 'AGBGameState::OnRoundTimeAlert' has a wrong offset!");
static_assert(offsetof(AGBGameState, WatchMode) == 0x000738, "Member 'AGBGameState::WatchMode' has a wrong offset!");
static_assert(offsetof(AGBGameState, WatchConfig) == 0x000739, "Member 'AGBGameState::WatchConfig' has a wrong offset!");
static_assert(offsetof(AGBGameState, bIsCapturing) == 0x00073A, "Member 'AGBGameState::bIsCapturing' has a wrong offset!");
static_assert(offsetof(AGBGameState, CaptureZone) == 0x00073C, "Member 'AGBGameState::CaptureZone' has a wrong offset!");
static_assert(offsetof(AGBGameState, ObjectiveLocation) == 0x000748, "Member 'AGBGameState::ObjectiveLocation' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnNextMapVoteChoicesChanged) == 0x000758, "Member 'AGBGameState::OnNextMapVoteChoicesChanged' has a wrong offset!");
static_assert(offsetof(AGBGameState, NextMapVoteChoices) == 0x000768, "Member 'AGBGameState::NextMapVoteChoices' has a wrong offset!");
static_assert(offsetof(AGBGameState, AIMuzzleFlashProbability) == 0x000780, "Member 'AGBGameState::AIMuzzleFlashProbability' has a wrong offset!");
static_assert(offsetof(AGBGameState, ServerNetMode) == 0x000784, "Member 'AGBGameState::ServerNetMode' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnIntelSearchCompleted) == 0x000788, "Member 'AGBGameState::OnIntelSearchCompleted' has a wrong offset!");
static_assert(offsetof(AGBGameState, OnMissionObjectiveStatusChanged) == 0x000798, "Member 'AGBGameState::OnMissionObjectiveStatusChanged' has a wrong offset!");
static_assert(offsetof(AGBGameState, HotspotName) == 0x0007A8, "Member 'AGBGameState::HotspotName' has a wrong offset!");
static_assert(offsetof(AGBGameState, MissionSequenceNumber) == 0x0007B0, "Member 'AGBGameState::MissionSequenceNumber' has a wrong offset!");
static_assert(offsetof(AGBGameState, MapMarkerList) == 0x0007B8, "Member 'AGBGameState::MapMarkerList' has a wrong offset!");
static_assert(offsetof(AGBGameState, CampaignMissionObjectiveInfoList) == 0x0007C8, "Member 'AGBGameState::CampaignMissionObjectiveInfoList' has a wrong offset!");
static_assert(offsetof(AGBGameState, BedtimeStartHour) == 0x0007D8, "Member 'AGBGameState::BedtimeStartHour' has a wrong offset!");
static_assert(offsetof(AGBGameState, BedtimeEndHour) == 0x0007DC, "Member 'AGBGameState::BedtimeEndHour' has a wrong offset!");
static_assert(offsetof(AGBGameState, bUseStandardHourForBedtimes) == 0x0007E0, "Member 'AGBGameState::bUseStandardHourForBedtimes' has a wrong offset!");

// Class GroundBranch.GBTaggedMontages
// 0x0010 (0x0040 - 0x0030)
class UGBTaggedMontages final : public UDataAsset
{
public:
	TArray<struct FGBTaggedMontageInfo>           TaggedMontageInfos;                                // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	class UAnimMontage* GetBestMatchingMontage(const struct FGameplayTagContainer& InTags, float InRandAlpha);
	class UAnimMontage* GetMatchingMontage(const struct FGameplayTagContainer& InTags, float InRandAlpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBTaggedMontages">();
	}
	static class UGBTaggedMontages* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBTaggedMontages>();
	}
};
static_assert(alignof(UGBTaggedMontages) == 0x000008, "Wrong alignment on UGBTaggedMontages");
static_assert(sizeof(UGBTaggedMontages) == 0x000040, "Wrong size on UGBTaggedMontages");
static_assert(offsetof(UGBTaggedMontages, TaggedMontageInfos) == 0x000030, "Member 'UGBTaggedMontages::TaggedMontageInfos' has a wrong offset!");

// Class GroundBranch.GBGameUserSettings
// 0x0078 (0x0198 - 0x0120)
class UGBGameUserSettings final : public UGameUserSettings
{
public:
	uint32                                        GBVersion;                                         // 0x0120(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUserAudioVolume>               AudioVolumes;                                      // 0x0128(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class USoundMix*>           AudioVolumeSoundMixes;                             // 0x0138(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_188[0x10];                                     // 0x0188(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGBGameUserSettings* GetGBGameUserSettings();
	static void GetQualityLevelCVarSettingsFromIni(const class FString& QualitySection, int32 QualityLevel, TArray<class FString>* OutCVarKeys, TArray<class FString>* OutCVarValues);

	float GetAudioVolume(const class FName InName);
	float GetUnfocusedVolumeMultiplier();
	void MuteAudio(const TArray<class FName>& ExcludedAudioVolumeNames);
	void SetAudioVolume(const class FName InName, float InVolume);
	void SetUnfocusedVolumeMultiplier(float InVolumeMultiplier);
	void UnmuteAudio();

	bool AreQualityLevelsDirty() const;
	bool IsMuted(class FName AudioVolumeName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameUserSettings">();
	}
	static class UGBGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameUserSettings>();
	}
};
static_assert(alignof(UGBGameUserSettings) == 0x000008, "Wrong alignment on UGBGameUserSettings");
static_assert(sizeof(UGBGameUserSettings) == 0x000198, "Wrong size on UGBGameUserSettings");
static_assert(offsetof(UGBGameUserSettings, GBVersion) == 0x000120, "Member 'UGBGameUserSettings::GBVersion' has a wrong offset!");
static_assert(offsetof(UGBGameUserSettings, AudioVolumes) == 0x000128, "Member 'UGBGameUserSettings::AudioVolumes' has a wrong offset!");
static_assert(offsetof(UGBGameUserSettings, AudioVolumeSoundMixes) == 0x000138, "Member 'UGBGameUserSettings::AudioVolumeSoundMixes' has a wrong offset!");

// Class GroundBranch.GBGameViewportClient
// 0x00B8 (0x0418 - 0x0360)
class UGBGameViewportClient final : public UGameViewportClient
{
public:
	uint8                                         Pad_360[0xA0];                                     // 0x0360(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisconnectReason;                                  // 0x0400(0x0018)(Protected, NativeAccessSpecifierProtected)

public:
	static class UGBGameViewportClient* GetGameViewportClient(const class UObject* WorldContextObject);

	void ClearDisconnectReason();
	void ClearNetworkFailure();
	void ClearTravelFailureInfo();
	bool GetNetworkFailureInfo(class FString* OutLastAttemptedURL, ENetworkFailure* OutLastNetworkFailureType, class FString* OutLastNetworkErrorString);
	bool GetTravelFailureInfo(class FString* OutLastAttemptedURL, ETravelFailure* OutLastTravelFailureType, class FString* OutLastTravelErrorString);
	void ScreenshotRequested();

	class FText GetDisconnectReason() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGameViewportClient">();
	}
	static class UGBGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGameViewportClient>();
	}
};
static_assert(alignof(UGBGameViewportClient) == 0x000008, "Wrong alignment on UGBGameViewportClient");
static_assert(sizeof(UGBGameViewportClient) == 0x000418, "Wrong size on UGBGameViewportClient");
static_assert(offsetof(UGBGameViewportClient, DisconnectReason) == 0x000400, "Member 'UGBGameViewportClient::DisconnectReason' has a wrong offset!");

// Class GroundBranch.GBGlobalAbilitySystem
// 0x0070 (0x00A0 - 0x0030)
class UGBGlobalAbilitySystem final : public UWorldSubsystem
{
public:
	TArray<TWeakObjectPtr<class UGBAbilitySystemComponent>> AbilitySystemComps;                      // 0x0030(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGBGameplayAbility>> GameplayAbilityClasses;                            // 0x0040(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x50];                                      // 0x0050(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAbilitySystemComp(class UGBAbilitySystemComponent* AbilitySystemComp);
	void AddGlobalGameplayAbility(TSubclassOf<class UGBGameplayAbility> GameplayAbilityClass);
	void ApplyGlobalGameplayEffect(TSubclassOf<class UGameplayEffect> GameplayEffectClass);
	void RemoveAbilitySystemComp(class UGBAbilitySystemComponent* AbilitySystemComp);
	void RemoveGlobalGameplayAbility(TSubclassOf<class UGBGameplayAbility> GameplayAbilityClass);
	void RemoveGlobalGameplayEffect(TSubclassOf<class UGameplayEffect> GameplayEffectClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGlobalAbilitySystem">();
	}
	static class UGBGlobalAbilitySystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBGlobalAbilitySystem>();
	}
};
static_assert(alignof(UGBGlobalAbilitySystem) == 0x000008, "Wrong alignment on UGBGlobalAbilitySystem");
static_assert(sizeof(UGBGlobalAbilitySystem) == 0x0000A0, "Wrong size on UGBGlobalAbilitySystem");
static_assert(offsetof(UGBGlobalAbilitySystem, AbilitySystemComps) == 0x000030, "Member 'UGBGlobalAbilitySystem::AbilitySystemComps' has a wrong offset!");
static_assert(offsetof(UGBGlobalAbilitySystem, GameplayAbilityClasses) == 0x000040, "Member 'UGBGlobalAbilitySystem::GameplayAbilityClasses' has a wrong offset!");

// Class GroundBranch.GBGrenade
// 0x0018 (0x0460 - 0x0448)
class AGBGrenade : public AGBInvItem
{
public:
	int32                                         CurrentSpeed;                                      // 0x0448(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSpeed;                                          // 0x044C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeed;                                          // 0x0450(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedStep;                                         // 0x0454(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeThrowSpeed(int32 Direction);
	void ServerSetCurrentSpeed(const int32 NewCurrentSpeed);
	void SyncCurrentSpeed();

	int32 GetCurrentSpeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBGrenade">();
	}
	static class AGBGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBGrenade>();
	}
};
static_assert(alignof(AGBGrenade) == 0x000008, "Wrong alignment on AGBGrenade");
static_assert(sizeof(AGBGrenade) == 0x000460, "Wrong size on AGBGrenade");
static_assert(offsetof(AGBGrenade, CurrentSpeed) == 0x000448, "Member 'AGBGrenade::CurrentSpeed' has a wrong offset!");
static_assert(offsetof(AGBGrenade, MinSpeed) == 0x00044C, "Member 'AGBGrenade::MinSpeed' has a wrong offset!");
static_assert(offsetof(AGBGrenade, MaxSpeed) == 0x000450, "Member 'AGBGrenade::MaxSpeed' has a wrong offset!");
static_assert(offsetof(AGBGrenade, SpeedStep) == 0x000454, "Member 'AGBGrenade::SpeedStep' has a wrong offset!");

// Class GroundBranch.GBWaterVolume
// 0x0008 (0x0270 - 0x0268)
class AGBWaterVolume final : public APhysicsVolume
{
public:
	float                                         PawnEntryVelZScaling;                              // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationSwimming;                       // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBWaterVolume">();
	}
	static class AGBWaterVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBWaterVolume>();
	}
};
static_assert(alignof(AGBWaterVolume) == 0x000008, "Wrong alignment on AGBWaterVolume");
static_assert(sizeof(AGBWaterVolume) == 0x000270, "Wrong size on AGBWaterVolume");
static_assert(offsetof(AGBWaterVolume, PawnEntryVelZScaling) == 0x000268, "Member 'AGBWaterVolume::PawnEntryVelZScaling' has a wrong offset!");
static_assert(offsetof(AGBWaterVolume, BrakingDecelerationSwimming) == 0x00026C, "Member 'AGBWaterVolume::BrakingDecelerationSwimming' has a wrong offset!");

// Class GroundBranch.GBHair
// 0x0028 (0x0470 - 0x0448)
class AGBHair : public AGBInvItem
{
public:
	struct FGameplayTagContainer                  CompatibleHeadTypeTags;                            // 0x0448(0x0020)(Edit, EditConst, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 HairMeshComponent;                                 // 0x0468(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddAdditionalMeshes();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBHair">();
	}
	static class AGBHair* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBHair>();
	}
};
static_assert(alignof(AGBHair) == 0x000008, "Wrong alignment on AGBHair");
static_assert(sizeof(AGBHair) == 0x000470, "Wrong size on AGBHair");
static_assert(offsetof(AGBHair, CompatibleHeadTypeTags) == 0x000448, "Member 'AGBHair::CompatibleHeadTypeTags' has a wrong offset!");
static_assert(offsetof(AGBHair, HairMeshComponent) == 0x000468, "Member 'AGBHair::HairMeshComponent' has a wrong offset!");

// Class GroundBranch.GBHead
// 0x0090 (0x04D8 - 0x0448)
class AGBHead : public AGBInvItem
{
public:
	TMap<class FName, class FName>                SocketOverrides;                                   // 0x0448(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        CharVoiceDataId;                                   // 0x0498(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 HeadMeshSkelMeshComp;                              // 0x04A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 WoundParameterName;                                // 0x04B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           WoundBoneList;                                     // 0x04C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void OnLoadMeshComplete();
	void OnPostLoadMeshComplete();
	void OnTakeHit(const class FName& RefBoneName, const struct FVector& RefPosPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBHead">();
	}
	static class AGBHead* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBHead>();
	}
};
static_assert(alignof(AGBHead) == 0x000008, "Wrong alignment on AGBHead");
static_assert(sizeof(AGBHead) == 0x0004D8, "Wrong size on AGBHead");
static_assert(offsetof(AGBHead, SocketOverrides) == 0x000448, "Member 'AGBHead::SocketOverrides' has a wrong offset!");
static_assert(offsetof(AGBHead, CharVoiceDataId) == 0x000498, "Member 'AGBHead::CharVoiceDataId' has a wrong offset!");
static_assert(offsetof(AGBHead, HeadMeshSkelMeshComp) == 0x0004A8, "Member 'AGBHead::HeadMeshSkelMeshComp' has a wrong offset!");
static_assert(offsetof(AGBHead, WoundParameterName) == 0x0004B0, "Member 'AGBHead::WoundParameterName' has a wrong offset!");
static_assert(offsetof(AGBHead, WoundBoneList) == 0x0004C8, "Member 'AGBHead::WoundBoneList' has a wrong offset!");

// Class GroundBranch.GBHolster
// 0x0028 (0x0470 - 0x0448)
class AGBHolster : public AGBInvItem
{
public:
	class FName                                   DefaultCharacterSocket;                            // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           LeftHandHolsterEquipTag;                           // 0x0450(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           RightHandHolsterEquipTag;                          // 0x0458(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           LeftHandHolsterUnequipTag;                         // 0x0460(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           RightHandHolsterUnequipTag;                        // 0x0468(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool HolsterItem(class AGBInvItem* Item);

	class AGBInvItem* GetHolsteredItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBHolster">();
	}
	static class AGBHolster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBHolster>();
	}
};
static_assert(alignof(AGBHolster) == 0x000008, "Wrong alignment on AGBHolster");
static_assert(sizeof(AGBHolster) == 0x000470, "Wrong size on AGBHolster");
static_assert(offsetof(AGBHolster, DefaultCharacterSocket) == 0x000448, "Member 'AGBHolster::DefaultCharacterSocket' has a wrong offset!");
static_assert(offsetof(AGBHolster, LeftHandHolsterEquipTag) == 0x000450, "Member 'AGBHolster::LeftHandHolsterEquipTag' has a wrong offset!");
static_assert(offsetof(AGBHolster, RightHandHolsterEquipTag) == 0x000458, "Member 'AGBHolster::RightHandHolsterEquipTag' has a wrong offset!");
static_assert(offsetof(AGBHolster, LeftHandHolsterUnequipTag) == 0x000460, "Member 'AGBHolster::LeftHandHolsterUnequipTag' has a wrong offset!");
static_assert(offsetof(AGBHolster, RightHandHolsterUnequipTag) == 0x000468, "Member 'AGBHolster::RightHandHolsterUnequipTag' has a wrong offset!");

// Class GroundBranch.GBHotspotDataAsset
// 0x00A0 (0x00D0 - 0x0030)
class UGBHotspotDataAsset final : public UPrimaryDataAsset
{
public:
	class FName                                   HotspotCodename;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ShortLocationName;                                 // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   LongLocationName;                                  // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   HotspotMissionType;                                // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector2D                              InGameMapPosition;                                 // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              HotspotMapImage;                                   // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHotspotNews>                   HotspotNewsItems;                                  // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDateTime                              HotspotStartDate;                                  // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidden;                                           // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBHotspotDataAsset">();
	}
	static class UGBHotspotDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBHotspotDataAsset>();
	}
};
static_assert(alignof(UGBHotspotDataAsset) == 0x000008, "Wrong alignment on UGBHotspotDataAsset");
static_assert(sizeof(UGBHotspotDataAsset) == 0x0000D0, "Wrong size on UGBHotspotDataAsset");
static_assert(offsetof(UGBHotspotDataAsset, HotspotCodename) == 0x000030, "Member 'UGBHotspotDataAsset::HotspotCodename' has a wrong offset!");
static_assert(offsetof(UGBHotspotDataAsset, ShortLocationName) == 0x000038, "Member 'UGBHotspotDataAsset::ShortLocationName' has a wrong offset!");
static_assert(offsetof(UGBHotspotDataAsset, LongLocationName) == 0x000050, "Member 'UGBHotspotDataAsset::LongLocationName' has a wrong offset!");
static_assert(offsetof(UGBHotspotDataAsset, HotspotMissionType) == 0x000068, "Member 'UGBHotspotDataAsset::HotspotMissionType' has a wrong offset!");
static_assert(offsetof(UGBHotspotDataAsset, InGameMapPosition) == 0x000080, "Member 'UGBHotspotDataAsset::InGameMapPosition' has a wrong offset!");
static_assert(offsetof(UGBHotspotDataAsset, HotspotMapImage) == 0x000088, "Member 'UGBHotspotDataAsset::HotspotMapImage' has a wrong offset!");
static_assert(offsetof(UGBHotspotDataAsset, HotspotNewsItems) == 0x0000B0, "Member 'UGBHotspotDataAsset::HotspotNewsItems' has a wrong offset!");
static_assert(offsetof(UGBHotspotDataAsset, HotspotStartDate) == 0x0000C0, "Member 'UGBHotspotDataAsset::HotspotStartDate' has a wrong offset!");
static_assert(offsetof(UGBHotspotDataAsset, bHidden) == 0x0000C8, "Member 'UGBHotspotDataAsset::bHidden' has a wrong offset!");

// Class GroundBranch.GBHUD
// 0x0058 (0x0368 - 0x0310)
class AGBHUD : public AHUD
{
public:
	class AGBPlayerController*                    GBPlayerControllerOwner;                           // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const int32 SelectedMenuIndex)> OnSelectedMenuOptionEvent;         // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBHUD* GBHUD)> OnShowHUDChanged;                            // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	float                                         FriendlyNameMinScreenSize;                         // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToIdentifyPlayer;                              // 0x034C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x18];                                     // 0x0350(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyPlayerSettings(class UGBPlayerSettings* PlayerSettings);
	void ApplyPlayerSettingsEvent(class UGBPlayerSettings* GBPlayerSettings);
	bool GetUserMenu(const class FString& MenuName, TArray<class FString>* OutMenuContent);
	void HideFriendlyPlayerNameEvent();
	void HideMenuEvent(class FName MenuType);
	void HideRadialItemsMenuEvent();
	void HideReadyRoomPlayerNameEvent();
	void InventorySlot(int32 Index_0, bool bImmediate);
	void OnChatLineAddedEvent(class AGBPlayerState* SenderGBPlayerState, class FName Type, float DisplayTime, const class FString& Message);
	void OnColourBlindnessFilterUpdateEvent();
	void OnInventorySlotEvent(int32 Index_0, bool bImmediate);
	void OnShowHintEvent(const TSoftClassPtr<class UClass>& HintWidgetClass);
	void OnShowHUDEvent();
	void OnSuggestHintEvent(class FName HintName);
	void OpenLinearUserMenu(const class FString& MenuName);
	void OpenRadialUserMenu(const class FString& MenuName);
	void OpenUserMenu(const class FString& MenuName);
	void ShowFriendlyPlayerNameEvent(const class FString& PlayerName, const ETeamElement& PlayerTeamElement);
	void ShowHint(class FName HintName, TSoftClassPtr<class UClass> HintWidgetClass);
	void ShowMenuEvent(class FName MenuType);
	void ShowRadialItemsMenuEvent(const TArray<class AGBInvItem*>& Items);
	void ShowRadialMenuEvent(const TArray<class UUserWidget*>& RadialMenuEntries);
	void ShowReadyRoomPlayerNameEvent(const class FString& PlayerName, const ETeamElement& PlayerTeamElement);
	void ShowWarningEvent(class FName WarningName);
	void SuggestHint(class FName HintName);

	class AActor* GetViewTarget() const;
	bool HintValid(class FName HintName) const;
	bool IsMenuVisibleEvent(class FName MenuType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBHUD">();
	}
	static class AGBHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBHUD>();
	}
};
static_assert(alignof(AGBHUD) == 0x000008, "Wrong alignment on AGBHUD");
static_assert(sizeof(AGBHUD) == 0x000368, "Wrong size on AGBHUD");
static_assert(offsetof(AGBHUD, GBPlayerControllerOwner) == 0x000310, "Member 'AGBHUD::GBPlayerControllerOwner' has a wrong offset!");
static_assert(offsetof(AGBHUD, OnSelectedMenuOptionEvent) == 0x000318, "Member 'AGBHUD::OnSelectedMenuOptionEvent' has a wrong offset!");
static_assert(offsetof(AGBHUD, OnShowHUDChanged) == 0x000338, "Member 'AGBHUD::OnShowHUDChanged' has a wrong offset!");
static_assert(offsetof(AGBHUD, FriendlyNameMinScreenSize) == 0x000348, "Member 'AGBHUD::FriendlyNameMinScreenSize' has a wrong offset!");
static_assert(offsetof(AGBHUD, TimeToIdentifyPlayer) == 0x00034C, "Member 'AGBHUD::TimeToIdentifyPlayer' has a wrong offset!");

// Class GroundBranch.GBIngameMapWidget
// 0x0050 (0x02B0 - 0x0260)
class UGBIngameMapWidget : public UUserWidget
{
public:
	class UButton*                                GoAlphaBtn;                                        // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                GoBravoBtn;                                        // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                GoCharlieBtn;                                      // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                GoDeltaBtn;                                        // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                HoldBtn;                                           // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                AdvanceBtn;                                        // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                AdvanceForceBtn;                                   // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                AssaultBtn;                                        // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                SuppressBtn;                                       // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ReconBtn;                                          // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UGBPlayerCommandComponent* GetCommandComp() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBIngameMapWidget">();
	}
	static class UGBIngameMapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBIngameMapWidget>();
	}
};
static_assert(alignof(UGBIngameMapWidget) == 0x000008, "Wrong alignment on UGBIngameMapWidget");
static_assert(sizeof(UGBIngameMapWidget) == 0x0002B0, "Wrong size on UGBIngameMapWidget");
static_assert(offsetof(UGBIngameMapWidget, GoAlphaBtn) == 0x000260, "Member 'UGBIngameMapWidget::GoAlphaBtn' has a wrong offset!");
static_assert(offsetof(UGBIngameMapWidget, GoBravoBtn) == 0x000268, "Member 'UGBIngameMapWidget::GoBravoBtn' has a wrong offset!");
static_assert(offsetof(UGBIngameMapWidget, GoCharlieBtn) == 0x000270, "Member 'UGBIngameMapWidget::GoCharlieBtn' has a wrong offset!");
static_assert(offsetof(UGBIngameMapWidget, GoDeltaBtn) == 0x000278, "Member 'UGBIngameMapWidget::GoDeltaBtn' has a wrong offset!");
static_assert(offsetof(UGBIngameMapWidget, HoldBtn) == 0x000280, "Member 'UGBIngameMapWidget::HoldBtn' has a wrong offset!");
static_assert(offsetof(UGBIngameMapWidget, AdvanceBtn) == 0x000288, "Member 'UGBIngameMapWidget::AdvanceBtn' has a wrong offset!");
static_assert(offsetof(UGBIngameMapWidget, AdvanceForceBtn) == 0x000290, "Member 'UGBIngameMapWidget::AdvanceForceBtn' has a wrong offset!");
static_assert(offsetof(UGBIngameMapWidget, AssaultBtn) == 0x000298, "Member 'UGBIngameMapWidget::AssaultBtn' has a wrong offset!");
static_assert(offsetof(UGBIngameMapWidget, SuppressBtn) == 0x0002A0, "Member 'UGBIngameMapWidget::SuppressBtn' has a wrong offset!");
static_assert(offsetof(UGBIngameMapWidget, ReconBtn) == 0x0002A8, "Member 'UGBIngameMapWidget::ReconBtn' has a wrong offset!");

// Class GroundBranch.GBInputOverrideInterface
// 0x0000 (0x0000 - 0x0000)
class IGBInputOverrideInterface final
{
public:
	bool OverrideInputAxis(const struct FKey& Key, float Delta, float DeltaTime, int32 NumSamples, bool bGamepad);
	bool OverrideInputKey(const struct FKey& Key, EBPInputEvent EventType, float AmountDepressed, bool bGamepad);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBInputOverrideInterface">();
	}
	static class IGBInputOverrideInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGBInputOverrideInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGBInputOverrideInterface) == 0x000001, "Wrong alignment on IGBInputOverrideInterface");
static_assert(sizeof(IGBInputOverrideInterface) == 0x000001, "Wrong size on IGBInputOverrideInterface");

// Class GroundBranch.GBInsertionPoint
// 0x0118 (0x0338 - 0x0220)
class AGBInsertionPoint final : public AActor
{
public:
	uint8                                         Pad_220[0x18];                                     // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InsertionPointName;                                // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0240(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, SaveGame, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0258(0x0001)(Edit, Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsActive : 1;                                     // 0x0259(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Net, SaveGame, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	bool                                          bTopDownView;                                      // 0x025A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSideView;                                         // 0x025B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class ALevelSequenceActor>     SequenceToPlayBeforeInfil;                         // 0x0260(0x0028)(Edit, SaveGame, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class ALevelSequenceActor>     SequenceToPlayAfterInfil;                          // 0x0288(0x0028)(Edit, SaveGame, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AGBInsertionPoint* InsertionPoint)> OnInsertionPointUpdate;  // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USphereComponent*                       SphereComponent;                                   // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArrowComponent*                        ArrowComponent;                                    // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBillboardComponent*                    SpriteComponent;                                   // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         SpawnOffsetIndex;                                  // 0x02D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x02E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextRenderComponent*                   TextRender;                                        // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MaxSupportedPlayers;                               // 0x0310(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGBPlayerStart*>                 AssociatedPlayerStarts;                            // 0x0318(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           CustomDetailWidgets;                               // 0x0328(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void CreateAssociatedPlayerStarts();
	TArray<class AGBPlayerState*> GetPlayers();
	void InsertionPointUpdated();
	void SetInsertionPointName(class FName NewInsertionPointName);

	int32 GetMaxSupportedPlayers() const;
	int32 GetNumberOfActivePlayerStarts() const;
	TSoftObjectPtr<class ALevelSequenceActor> GetSequenceToPlayAfterInfil() const;
	TSoftObjectPtr<class ALevelSequenceActor> GetSequenceToPlayBeforeInfil() const;
	bool GetSideView() const;
	bool GetTopDownView() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBInsertionPoint">();
	}
	static class AGBInsertionPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBInsertionPoint>();
	}
};
static_assert(alignof(AGBInsertionPoint) == 0x000008, "Wrong alignment on AGBInsertionPoint");
static_assert(sizeof(AGBInsertionPoint) == 0x000338, "Wrong size on AGBInsertionPoint");
static_assert(offsetof(AGBInsertionPoint, InsertionPointName) == 0x000238, "Member 'AGBInsertionPoint::InsertionPointName' has a wrong offset!");
static_assert(offsetof(AGBInsertionPoint, DisplayName) == 0x000240, "Member 'AGBInsertionPoint::DisplayName' has a wrong offset!");
static_assert(offsetof(AGBInsertionPoint, TeamId) == 0x000258, "Member 'AGBInsertionPoint::TeamId' has a wrong offset!");
static_assert(offsetof(AGBInsertionPoint, bTopDownView) == 0x00025A, "Member 'AGBInsertionPoint::bTopDownView' has a wrong offset!");
static_assert(offsetof(AGBInsertionPoint, bSideView) == 0x00025B, "Member 'AGBInsertionPoint::bSideView' has a wrong offset!");
static_assert(offsetof(AGBInsertionPoint, SequenceToPlayBeforeInfil) == 0x000260, "Member 'AGBInsertionPoint::SequenceToPlayBeforeInfil' has a wrong offset!");
static_assert(offsetof(AGBInsertionPoint, SequenceToPlayAfterInfil) == 0x000288, "Member 'AGBInsertionPoint::SequenceToPlayAfterInfil' has a wrong offset!");
static_assert(offsetof(AGBInsertionPoint, OnInsertionPointUpdate) == 0x0002B0, "Member 'AGBInsertionPoint::OnInsertionPointUpdate' has a wrong offset!");
static_assert(offsetof(AGBInsertionPoint, SphereComponent) == 0x0002C0, "Member 'AGBInsertionPoint::SphereComponent' has a wrong offset!");
static_assert(offsetof(AGBInsertionPoint, ArrowComponent) == 0x0002C8, "Member 'AGBInsertionPoint::ArrowComponent' has a wrong offset!");
static_assert(offsetof(AGBInsertionPoint, SpriteComponent) == 0x0002D0, "Member 'AGBInsertionPoint::SpriteComponent' has a wrong offset!");
static_assert(offsetof(AGBInsertionPoint, SpawnOffsetIndex) == 0x0002D8, "Member 'AGBInsertionPoint::SpawnOffsetIndex' has a wrong offset!");
static_assert(offsetof(AGBInsertionPoint, Icon) == 0x0002E0, "Member 'AGBInsertionPoint::Icon' has a wrong offset!");
static_assert(offsetof(AGBInsertionPoint, TextRender) == 0x000308, "Member 'AGBInsertionPoint::TextRender' has a wrong offset!");
static_assert(offsetof(AGBInsertionPoint, MaxSupportedPlayers) == 0x000310, "Member 'AGBInsertionPoint::MaxSupportedPlayers' has a wrong offset!");
static_assert(offsetof(AGBInsertionPoint, AssociatedPlayerStarts) == 0x000318, "Member 'AGBInsertionPoint::AssociatedPlayerStarts' has a wrong offset!");
static_assert(offsetof(AGBInsertionPoint, CustomDetailWidgets) == 0x000328, "Member 'AGBInsertionPoint::CustomDetailWidgets' has a wrong offset!");

// Class GroundBranch.GBInternalMagazineComponent
// 0x0060 (0x0270 - 0x0210)
class UGBInternalMagazineComponent final : public UGBAmmunitionFeedComponent
{
public:
	int32                                         Count;                                             // 0x0208(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ClientCount;                                       // 0x020C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_210[0x8];                                      // 0x0210(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Capacity;                                          // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        BulletId;                                          // 0x021C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGBBulletItem>              BulletItemClass;                                   // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGBBulletItem>              ChamberedRound;                                    // 0x0238(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartPlusOne;                                     // 0x0240(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStayOpenOnLastRound;                              // 0x0241(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsFiringFromOpenBolt : 1;                         // 0x0242(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBoltHeldOpen : 1;                                 // 0x0242(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_243[0x5];                                      // 0x0243(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class UGBAmmunitionFeedComponent* AmmunitionFeedComp)> OnBoltHeldOpenUpdated; // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UGBInternalMagazineComponent* InternalMagComp)> OnCountUpdated; // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddRoundToMagazine();
	class AGBBulletItem* FindCompatibleRound(class AGBCharacter* Character);
	void OnBulletIdUpdated();
	void OnRep_BoltHeldOpen();
	void OnRep_Count();
	void SetBoltHeldOpen(bool bNewBoltIsHeldOpen);
	void SetBulletId(const struct FPrimaryAssetId& NewBulletId);
	void SetChamberedRound(TSubclassOf<class AGBBulletItem> NewChamberedRound);
	void SetCount(int32 NewCount);
	void SetIsFiringFromOpenBolt(bool bNewIsFiringFromOpenBolt);
	void SyncCount();

	bool GetBoltHeldOpen() const;
	TSubclassOf<class AGBBulletItem> GetBulletItemClass() const;
	int32 GetCapacity() const;
	TSubclassOf<class AGBBulletItem> GetChamberedRound() const;
	int32 GetCount() const;
	bool GetIsFiringFromOpenBolt() const;
	bool IsLiveRoundChambered() const;
	bool StartPlusOne() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBInternalMagazineComponent">();
	}
	static class UGBInternalMagazineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBInternalMagazineComponent>();
	}
};
static_assert(alignof(UGBInternalMagazineComponent) == 0x000010, "Wrong alignment on UGBInternalMagazineComponent");
static_assert(sizeof(UGBInternalMagazineComponent) == 0x000270, "Wrong size on UGBInternalMagazineComponent");
static_assert(offsetof(UGBInternalMagazineComponent, Count) == 0x000208, "Member 'UGBInternalMagazineComponent::Count' has a wrong offset!");
static_assert(offsetof(UGBInternalMagazineComponent, ClientCount) == 0x00020C, "Member 'UGBInternalMagazineComponent::ClientCount' has a wrong offset!");
static_assert(offsetof(UGBInternalMagazineComponent, Capacity) == 0x000218, "Member 'UGBInternalMagazineComponent::Capacity' has a wrong offset!");
static_assert(offsetof(UGBInternalMagazineComponent, BulletId) == 0x00021C, "Member 'UGBInternalMagazineComponent::BulletId' has a wrong offset!");
static_assert(offsetof(UGBInternalMagazineComponent, BulletItemClass) == 0x000230, "Member 'UGBInternalMagazineComponent::BulletItemClass' has a wrong offset!");
static_assert(offsetof(UGBInternalMagazineComponent, ChamberedRound) == 0x000238, "Member 'UGBInternalMagazineComponent::ChamberedRound' has a wrong offset!");
static_assert(offsetof(UGBInternalMagazineComponent, bStartPlusOne) == 0x000240, "Member 'UGBInternalMagazineComponent::bStartPlusOne' has a wrong offset!");
static_assert(offsetof(UGBInternalMagazineComponent, bStayOpenOnLastRound) == 0x000241, "Member 'UGBInternalMagazineComponent::bStayOpenOnLastRound' has a wrong offset!");
static_assert(offsetof(UGBInternalMagazineComponent, OnBoltHeldOpenUpdated) == 0x000248, "Member 'UGBInternalMagazineComponent::OnBoltHeldOpenUpdated' has a wrong offset!");
static_assert(offsetof(UGBInternalMagazineComponent, OnCountUpdated) == 0x000258, "Member 'UGBInternalMagazineComponent::OnCountUpdated' has a wrong offset!");

// Class GroundBranch.GBInvItemAttachment_SocketTag
// 0x0000 (0x0448 - 0x0448)
class AGBInvItemAttachment_SocketTag : public AGBInvItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBInvItemAttachment_SocketTag">();
	}
	static class AGBInvItemAttachment_SocketTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBInvItemAttachment_SocketTag>();
	}
};
static_assert(alignof(AGBInvItemAttachment_SocketTag) == 0x000008, "Wrong alignment on AGBInvItemAttachment_SocketTag");
static_assert(sizeof(AGBInvItemAttachment_SocketTag) == 0x000448, "Wrong size on AGBInvItemAttachment_SocketTag");

// Class GroundBranch.GBInvItemAudioEventSet
// 0x0050 (0x0080 - 0x0030)
class UGBInvItemAudioEventSet final : public UPrimaryDataAsset
{
public:
	TMap<class FName, class UAkAudioEvent*>       AudioEvents;                                       // 0x0030(0x0050)(Edit, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	class UAkAudioEvent* GetAudioEvent(class FName MontageName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBInvItemAudioEventSet">();
	}
	static class UGBInvItemAudioEventSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBInvItemAudioEventSet>();
	}
};
static_assert(alignof(UGBInvItemAudioEventSet) == 0x000008, "Wrong alignment on UGBInvItemAudioEventSet");
static_assert(sizeof(UGBInvItemAudioEventSet) == 0x000080, "Wrong size on UGBInvItemAudioEventSet");
static_assert(offsetof(UGBInvItemAudioEventSet, AudioEvents) == 0x000030, "Member 'UGBInvItemAudioEventSet::AudioEvents' has a wrong offset!");

// Class GroundBranch.GBInvItemDragDropOperation
// 0x0028 (0x00B0 - 0x0088)
class UGBInvItemDragDropOperation : public UDragDropOperation
{
public:
	class UCanvasPanel*                           FloatingCanvas;                                    // 0x0088(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UDragDropOperation* Operation)> OnDraggedItemAttached;       // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UDragDropOperation* Operation)> OnDraggedItemDestroyed;      // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class UUserWidget* CreateFloatingWidget(TSubclassOf<class UUserWidget> WidgetClass);
	void EndDragCleanup();
	void Init();
	void MakeInvItemInteractive(class AGBInvItem* InvItemn);

	class AGBInvItem* GetInvItem() const;
	class AGBInvItem* GetRootInvItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBInvItemDragDropOperation">();
	}
	static class UGBInvItemDragDropOperation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBInvItemDragDropOperation>();
	}
};
static_assert(alignof(UGBInvItemDragDropOperation) == 0x000008, "Wrong alignment on UGBInvItemDragDropOperation");
static_assert(sizeof(UGBInvItemDragDropOperation) == 0x0000B0, "Wrong size on UGBInvItemDragDropOperation");
static_assert(offsetof(UGBInvItemDragDropOperation, FloatingCanvas) == 0x000088, "Member 'UGBInvItemDragDropOperation::FloatingCanvas' has a wrong offset!");
static_assert(offsetof(UGBInvItemDragDropOperation, OnDraggedItemAttached) == 0x000090, "Member 'UGBInvItemDragDropOperation::OnDraggedItemAttached' has a wrong offset!");
static_assert(offsetof(UGBInvItemDragDropOperation, OnDraggedItemDestroyed) == 0x0000A0, "Member 'UGBInvItemDragDropOperation::OnDraggedItemDestroyed' has a wrong offset!");

// Class GroundBranch.GBInvItemEffectSet
// 0x0050 (0x0080 - 0x0030)
class UGBInvItemEffectSet final : public UPrimaryDataAsset
{
public:
	TMap<class FName, class UNiagaraSystem*>      Effects;                                           // 0x0030(0x0050)(Edit, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	class UNiagaraSystem* GetEffect(class FName EffectName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBInvItemEffectSet">();
	}
	static class UGBInvItemEffectSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBInvItemEffectSet>();
	}
};
static_assert(alignof(UGBInvItemEffectSet) == 0x000008, "Wrong alignment on UGBInvItemEffectSet");
static_assert(sizeof(UGBInvItemEffectSet) == 0x000080, "Wrong size on UGBInvItemEffectSet");
static_assert(offsetof(UGBInvItemEffectSet, Effects) == 0x000030, "Member 'UGBInvItemEffectSet::Effects' has a wrong offset!");

// Class GroundBranch.GBInvItemMontageSet
// 0x0050 (0x0080 - 0x0030)
class UGBInvItemMontageSet final : public UPrimaryDataAsset
{
public:
	TMap<class FName, class UAnimMontage*>        Montages;                                          // 0x0030(0x0050)(Edit, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	class UAnimMontage* GetMontage(class FName MontageName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBInvItemMontageSet">();
	}
	static class UGBInvItemMontageSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBInvItemMontageSet>();
	}
};
static_assert(alignof(UGBInvItemMontageSet) == 0x000008, "Wrong alignment on UGBInvItemMontageSet");
static_assert(sizeof(UGBInvItemMontageSet) == 0x000080, "Wrong size on UGBInvItemMontageSet");
static_assert(offsetof(UGBInvItemMontageSet, Montages) == 0x000030, "Member 'UGBInvItemMontageSet::Montages' has a wrong offset!");

// Class GroundBranch.GBInvItemPickupComponent
// 0x0088 (0x0138 - 0x00B0)
class UGBInvItemPickupComponent final : public UActorComponent
{
public:
	EGBInvItemPickupShape                         PickupShape;                                       // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               PickupShapeRelativeRotation;                       // 0x00B4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                PickupShapeScale;                                  // 0x00C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   InvItemPickupWidgetClass;                          // 0x00D0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PickupTag;                                         // 0x00F8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AltPickupTag;                                      // 0x0100(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBInvItem*                             PickupTarget;                                      // 0x0108(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBInvItem*                             AltPickupTarget;                                   // 0x0110(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitDelay;                                         // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UShapeComponent*                        ShapeComponent;                                    // 0x0120(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputComponent*                        InputComponent;                                    // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init();
	void OnBeginCursorOver(class UPrimitiveComponent* TouchedComponent);
	void OnEndCursorOver(class UPrimitiveComponent* TouchedComponent);
	void SetAltPickupTarget(class AGBInvItem* NewAltPickupTarget);
	void SetPickupShapeScale(const struct FVector& NewPickupShapeScale);
	void SetPickupTarget(class AGBInvItem* NewPickupTarget);

	class AGBInvItem* GetAltPickupTarget() const;
	class AGBInvItem* GetPickupTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBInvItemPickupComponent">();
	}
	static class UGBInvItemPickupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBInvItemPickupComponent>();
	}
};
static_assert(alignof(UGBInvItemPickupComponent) == 0x000008, "Wrong alignment on UGBInvItemPickupComponent");
static_assert(sizeof(UGBInvItemPickupComponent) == 0x000138, "Wrong size on UGBInvItemPickupComponent");
static_assert(offsetof(UGBInvItemPickupComponent, PickupShape) == 0x0000B0, "Member 'UGBInvItemPickupComponent::PickupShape' has a wrong offset!");
static_assert(offsetof(UGBInvItemPickupComponent, PickupShapeRelativeRotation) == 0x0000B4, "Member 'UGBInvItemPickupComponent::PickupShapeRelativeRotation' has a wrong offset!");
static_assert(offsetof(UGBInvItemPickupComponent, PickupShapeScale) == 0x0000C0, "Member 'UGBInvItemPickupComponent::PickupShapeScale' has a wrong offset!");
static_assert(offsetof(UGBInvItemPickupComponent, InvItemPickupWidgetClass) == 0x0000D0, "Member 'UGBInvItemPickupComponent::InvItemPickupWidgetClass' has a wrong offset!");
static_assert(offsetof(UGBInvItemPickupComponent, PickupTag) == 0x0000F8, "Member 'UGBInvItemPickupComponent::PickupTag' has a wrong offset!");
static_assert(offsetof(UGBInvItemPickupComponent, AltPickupTag) == 0x000100, "Member 'UGBInvItemPickupComponent::AltPickupTag' has a wrong offset!");
static_assert(offsetof(UGBInvItemPickupComponent, PickupTarget) == 0x000108, "Member 'UGBInvItemPickupComponent::PickupTarget' has a wrong offset!");
static_assert(offsetof(UGBInvItemPickupComponent, AltPickupTarget) == 0x000110, "Member 'UGBInvItemPickupComponent::AltPickupTarget' has a wrong offset!");
static_assert(offsetof(UGBInvItemPickupComponent, InitDelay) == 0x000118, "Member 'UGBInvItemPickupComponent::InitDelay' has a wrong offset!");
static_assert(offsetof(UGBInvItemPickupComponent, ShapeComponent) == 0x000120, "Member 'UGBInvItemPickupComponent::ShapeComponent' has a wrong offset!");
static_assert(offsetof(UGBInvItemPickupComponent, InputComponent) == 0x000128, "Member 'UGBInvItemPickupComponent::InputComponent' has a wrong offset!");

// Class GroundBranch.GBInvItemPickupWidget
// 0x0008 (0x0268 - 0x0260)
class UGBInvItemPickupWidget : public UUserWidget
{
public:
	class UGBInvItemPickupComponent*              InvItemPickupComp;                                 // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsValidPickupTarget(const class AGBInvItem* PickupTarget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBInvItemPickupWidget">();
	}
	static class UGBInvItemPickupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBInvItemPickupWidget>();
	}
};
static_assert(alignof(UGBInvItemPickupWidget) == 0x000008, "Wrong alignment on UGBInvItemPickupWidget");
static_assert(sizeof(UGBInvItemPickupWidget) == 0x000268, "Wrong size on UGBInvItemPickupWidget");
static_assert(offsetof(UGBInvItemPickupWidget, InvItemPickupComp) == 0x000260, "Member 'UGBInvItemPickupWidget::InvItemPickupComp' has a wrong offset!");

// Class GroundBranch.GBInvItemSkin
// 0x0030 (0x0060 - 0x0030)
class UGBInvItemSkin final : public UPrimaryDataAsset
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0030(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGBInvItemSkinMaterialInfo>     InvItemSkinMaterials;                              // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected)

public:
	const TArray<struct FGBInvItemSkinMaterialInfo> GetInvItemSkinMaterials() const;
	struct FGameplayTagContainer GetTags() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBInvItemSkin">();
	}
	static class UGBInvItemSkin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBInvItemSkin>();
	}
};
static_assert(alignof(UGBInvItemSkin) == 0x000008, "Wrong alignment on UGBInvItemSkin");
static_assert(sizeof(UGBInvItemSkin) == 0x000060, "Wrong size on UGBInvItemSkin");
static_assert(offsetof(UGBInvItemSkin, Tags) == 0x000030, "Member 'UGBInvItemSkin::Tags' has a wrong offset!");
static_assert(offsetof(UGBInvItemSkin, InvItemSkinMaterials) == 0x000050, "Member 'UGBInvItemSkin::InvItemSkinMaterials' has a wrong offset!");

// Class GroundBranch.GBInvItemSkinInfo
// 0x0080 (0x00B0 - 0x0030)
class UGBInvItemSkinInfo final : public UPrimaryDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoClear, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Tags;                                              // 0x0070(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SubstituteNameTags;                                // 0x0090(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBInvItemSkinInfo">();
	}
	static class UGBInvItemSkinInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBInvItemSkinInfo>();
	}
};
static_assert(alignof(UGBInvItemSkinInfo) == 0x000008, "Wrong alignment on UGBInvItemSkinInfo");
static_assert(sizeof(UGBInvItemSkinInfo) == 0x0000B0, "Wrong size on UGBInvItemSkinInfo");
static_assert(offsetof(UGBInvItemSkinInfo, DisplayName) == 0x000030, "Member 'UGBInvItemSkinInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(UGBInvItemSkinInfo, Icon) == 0x000048, "Member 'UGBInvItemSkinInfo::Icon' has a wrong offset!");
static_assert(offsetof(UGBInvItemSkinInfo, Tags) == 0x000070, "Member 'UGBInvItemSkinInfo::Tags' has a wrong offset!");
static_assert(offsetof(UGBInvItemSkinInfo, SubstituteNameTags) == 0x000090, "Member 'UGBInvItemSkinInfo::SubstituteNameTags' has a wrong offset!");

// Class GroundBranch.GBItemBeamComponent
// 0x0050 (0x0250 - 0x0200)
class UGBItemBeamComponent final : public USceneComponent
{
public:
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      CollisionTraceObjectTypes;                         // 0x0200(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         TraceDistance;                                     // 0x0210(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BeamDir;                                           // 0x0214(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BeamStartPoint;                                    // 0x0220(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BeamEndPointBias;                                  // 0x022C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BeamEndPointBiasCharacter;                         // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BeamEndPoint;                                      // 0x0234(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BeamDistance;                                      // 0x0240(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_244[0xC];                                      // 0x0244(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnColourBlindnessFilterUpdateEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBItemBeamComponent">();
	}
	static class UGBItemBeamComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBItemBeamComponent>();
	}
};
static_assert(alignof(UGBItemBeamComponent) == 0x000010, "Wrong alignment on UGBItemBeamComponent");
static_assert(sizeof(UGBItemBeamComponent) == 0x000250, "Wrong size on UGBItemBeamComponent");
static_assert(offsetof(UGBItemBeamComponent, CollisionTraceObjectTypes) == 0x000200, "Member 'UGBItemBeamComponent::CollisionTraceObjectTypes' has a wrong offset!");
static_assert(offsetof(UGBItemBeamComponent, TraceDistance) == 0x000210, "Member 'UGBItemBeamComponent::TraceDistance' has a wrong offset!");
static_assert(offsetof(UGBItemBeamComponent, BeamDir) == 0x000214, "Member 'UGBItemBeamComponent::BeamDir' has a wrong offset!");
static_assert(offsetof(UGBItemBeamComponent, BeamStartPoint) == 0x000220, "Member 'UGBItemBeamComponent::BeamStartPoint' has a wrong offset!");
static_assert(offsetof(UGBItemBeamComponent, BeamEndPointBias) == 0x00022C, "Member 'UGBItemBeamComponent::BeamEndPointBias' has a wrong offset!");
static_assert(offsetof(UGBItemBeamComponent, BeamEndPointBiasCharacter) == 0x000230, "Member 'UGBItemBeamComponent::BeamEndPointBiasCharacter' has a wrong offset!");
static_assert(offsetof(UGBItemBeamComponent, BeamEndPoint) == 0x000234, "Member 'UGBItemBeamComponent::BeamEndPoint' has a wrong offset!");
static_assert(offsetof(UGBItemBeamComponent, BeamDistance) == 0x000240, "Member 'UGBItemBeamComponent::BeamDistance' has a wrong offset!");

// Class GroundBranch.GBItemMeshByTagsUserData
// 0x0040 (0x0068 - 0x0028)
class UGBItemMeshByTagsUserData final : public UAssetUserData
{
public:
	TArray<struct FGBItemMeshByTagsInfo>          ItemMeshByTagsList;                                // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         DefaultItemMeshIndex;                              // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequiredOnDedicatedServer;                        // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D[0x1B];                                      // 0x003D(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnLoadMeshCompleteDelegate;                        // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnCosmeticTagsUpdated(const struct FGameplayTagContainer& InCosmeticTags);
	void OnLoadMeshComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBItemMeshByTagsUserData">();
	}
	static class UGBItemMeshByTagsUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBItemMeshByTagsUserData>();
	}
};
static_assert(alignof(UGBItemMeshByTagsUserData) == 0x000008, "Wrong alignment on UGBItemMeshByTagsUserData");
static_assert(sizeof(UGBItemMeshByTagsUserData) == 0x000068, "Wrong size on UGBItemMeshByTagsUserData");
static_assert(offsetof(UGBItemMeshByTagsUserData, ItemMeshByTagsList) == 0x000028, "Member 'UGBItemMeshByTagsUserData::ItemMeshByTagsList' has a wrong offset!");
static_assert(offsetof(UGBItemMeshByTagsUserData, DefaultItemMeshIndex) == 0x000038, "Member 'UGBItemMeshByTagsUserData::DefaultItemMeshIndex' has a wrong offset!");
static_assert(offsetof(UGBItemMeshByTagsUserData, bRequiredOnDedicatedServer) == 0x00003C, "Member 'UGBItemMeshByTagsUserData::bRequiredOnDedicatedServer' has a wrong offset!");
static_assert(offsetof(UGBItemMeshByTagsUserData, OnLoadMeshCompleteDelegate) == 0x000058, "Member 'UGBItemMeshByTagsUserData::OnLoadMeshCompleteDelegate' has a wrong offset!");

// Class GroundBranch.GBItemMorphByTagsUserData
// 0x0018 (0x0040 - 0x0028)
class UGBItemMorphByTagsUserData final : public UAssetUserData
{
public:
	TArray<struct FGBItemMorphByTagsInfo>         ItemMorphByTagsList;                               // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         DefaultItemMorphIndex;                             // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCosmeticTagsUpdated(const struct FGameplayTagContainer& InCosmeticTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBItemMorphByTagsUserData">();
	}
	static class UGBItemMorphByTagsUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBItemMorphByTagsUserData>();
	}
};
static_assert(alignof(UGBItemMorphByTagsUserData) == 0x000008, "Wrong alignment on UGBItemMorphByTagsUserData");
static_assert(sizeof(UGBItemMorphByTagsUserData) == 0x000040, "Wrong size on UGBItemMorphByTagsUserData");
static_assert(offsetof(UGBItemMorphByTagsUserData, ItemMorphByTagsList) == 0x000028, "Member 'UGBItemMorphByTagsUserData::ItemMorphByTagsList' has a wrong offset!");
static_assert(offsetof(UGBItemMorphByTagsUserData, DefaultItemMorphIndex) == 0x000038, "Member 'UGBItemMorphByTagsUserData::DefaultItemMorphIndex' has a wrong offset!");

// Class GroundBranch.GBItemProjectile
// 0x0070 (0x0290 - 0x0220)
class AGBItemProjectile : public AActor
{
public:
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       CollisionComp;                                     // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGBItemProjectileMovementComponent*     ItemProjectileMovement;                            // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBInvItem*                             AssociatedItem;                                    // 0x0240(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Velocity;                                          // 0x0248(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0xC];                                      // 0x0254(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPreBounceRotationRate;                          // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPostBouncedRotationRate;                        // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0xC];                                      // 0x0268(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBetweenImpacts;                                // 0x0274(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);
	void OnProxyAssociatedItemParentDestroyed(class AActor* DestroyedActor);
	void OnReplaceClientsideProxyEvent(class AGBInvItem* ClientsideProxyAssociatedItem, bool bSyncedLocations);
	void OnStop(const struct FHitResult& HitResult);
	void UpdateAssociatedItem();

	bool IsClientsideProxy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBItemProjectile">();
	}
	static class AGBItemProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBItemProjectile>();
	}
};
static_assert(alignof(AGBItemProjectile) == 0x000008, "Wrong alignment on AGBItemProjectile");
static_assert(sizeof(AGBItemProjectile) == 0x000290, "Wrong size on AGBItemProjectile");
static_assert(offsetof(AGBItemProjectile, CollisionComp) == 0x000230, "Member 'AGBItemProjectile::CollisionComp' has a wrong offset!");
static_assert(offsetof(AGBItemProjectile, ItemProjectileMovement) == 0x000238, "Member 'AGBItemProjectile::ItemProjectileMovement' has a wrong offset!");
static_assert(offsetof(AGBItemProjectile, AssociatedItem) == 0x000240, "Member 'AGBItemProjectile::AssociatedItem' has a wrong offset!");
static_assert(offsetof(AGBItemProjectile, Velocity) == 0x000248, "Member 'AGBItemProjectile::Velocity' has a wrong offset!");
static_assert(offsetof(AGBItemProjectile, MaxPreBounceRotationRate) == 0x000260, "Member 'AGBItemProjectile::MaxPreBounceRotationRate' has a wrong offset!");
static_assert(offsetof(AGBItemProjectile, MaxPostBouncedRotationRate) == 0x000264, "Member 'AGBItemProjectile::MaxPostBouncedRotationRate' has a wrong offset!");
static_assert(offsetof(AGBItemProjectile, TimeBetweenImpacts) == 0x000274, "Member 'AGBItemProjectile::TimeBetweenImpacts' has a wrong offset!");

// Class GroundBranch.GBItemProjectileMovementComponent
// 0x0030 (0x0200 - 0x01D0)
class UGBItemProjectileMovementComponent final : public UProjectileMovementComponent
{
public:
	struct FGameplayTagContainer                  IgnoredPMTags;                                     // 0x01D0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0[0x10];                                     // 0x01F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBItemProjectileMovementComponent">();
	}
	static class UGBItemProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBItemProjectileMovementComponent>();
	}
};
static_assert(alignof(UGBItemProjectileMovementComponent) == 0x000010, "Wrong alignment on UGBItemProjectileMovementComponent");
static_assert(sizeof(UGBItemProjectileMovementComponent) == 0x000200, "Wrong size on UGBItemProjectileMovementComponent");
static_assert(offsetof(UGBItemProjectileMovementComponent, IgnoredPMTags) == 0x0001D0, "Member 'UGBItemProjectileMovementComponent::IgnoredPMTags' has a wrong offset!");

// Class GroundBranch.GBItemViewOverlayWidget
// 0x0018 (0x0278 - 0x0260)
class UGBItemViewOverlayWidget final : public UUserWidget
{
public:
	bool                                          bMustBeEquipped;                                   // 0x0260(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBInvItem*                             AssociatedItem;                                    // 0x0268(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAssociatedItemDestroyed(class AActor* DestroyedActor);
	void SetAssociatedItem(class AGBInvItem* Item);

	class AGBInvItem* GetAssociatedItem() const;
	class AGBCharacter* GetGBCharacterViewTarget() const;
	class AGBPlayerController* GetOwningGBPlayerController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBItemViewOverlayWidget">();
	}
	static class UGBItemViewOverlayWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBItemViewOverlayWidget>();
	}
};
static_assert(alignof(UGBItemViewOverlayWidget) == 0x000008, "Wrong alignment on UGBItemViewOverlayWidget");
static_assert(sizeof(UGBItemViewOverlayWidget) == 0x000278, "Wrong size on UGBItemViewOverlayWidget");
static_assert(offsetof(UGBItemViewOverlayWidget, bMustBeEquipped) == 0x000260, "Member 'UGBItemViewOverlayWidget::bMustBeEquipped' has a wrong offset!");
static_assert(offsetof(UGBItemViewOverlayWidget, AssociatedItem) == 0x000268, "Member 'UGBItemViewOverlayWidget::AssociatedItem' has a wrong offset!");

// Class GroundBranch.GBKitFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGBKitFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString AILoadoutToFullLoadoutFileName(const class UObject* WorldContextObject, const class FString& LoadoutFileName);
	static struct FLuaValue ConvertItemBuildToLuaTable(const class UObject* WorldContextObject, class UVaRestJsonObject* ItemBuildJson, bool bSplitItemField);
	static class FName ConvertKitFileNameToLoadoutName(const class UObject* WorldContextObject, const class FString& LoadoutFileName);
	static void ConvertOldKitsInPath(const class UObject* WorldContextObject, const class FString& Path, const class FString& Extension);
	static class AGBKitInfo* CreateDummyKitInfo(class UObject* WorldContextObject);
	static class FString CreateJsonTypeString(const struct FGameplayTagContainer& InvItemTags);
	static bool CreateKitFromItem(const class FString& BuildName, class AGBInvItem* Item, bool bUnversioned, class UVaRestJsonObject** OutKitJsonObj);
	static bool CreateKitFromItems(const TArray<class AGBInvItem*>& Items, class UVaRestJsonObject** OutKitJsonObj);
	static class AGBKitInfo* CreateKitInfo(class UObject* WorldContextObject, const class FName& KitName, class UVaRestJsonObject* KitJsonObj);
	static class FString GetBuildNameField();
	static class FString GetChildrenField();
	static class FString GetDefaultBotLoadoutsPath(const class FName& TeamName);
	static const class FName GetDefaultItemBuildTag();
	static class AGBKitInfo* GetDefaultKitInfo(const class UObject* WorldContextObject, const class FName& LoadoutName);
	static class FString GetDefaultLoadoutFilename(const class FName& LoadoutName);
	static class FString GetDefaultPatchesPath();
	static class FString GetFallbackPatchPathField();
	static class FString GetFallbackPatchTintField();
	static class FString GetFullPatchPath(const class FString& PatchName);
	static class FString GetHashField();
	static class FString GetItemBuildField();
	static class FString GetItemDataField();
	static class FString GetItemField();
	static class FString GetKitExtension();
	static bool GetKitItemList(class AActor* Owner, class UVaRestJsonObject* KitJsonObj, class FName ProfileName, bool bSkipAuth, TArray<class AGBInvItem*>* OutItems);
	static bool GetKitPrimaryAssetIds(class UVaRestJsonObject* KitJsonObj, TArray<struct FPrimaryAssetId>* OutPrimaryAssetIds);
	static struct FGBKitValidationInfo GetKitValidationInfo(const class UObject* WorldContextObject, class FName LoadoutName, class UVaRestJsonObject* KitJsonObj, const struct FGameplayTagContainer& RequiredInvItemTypeTags, const struct FGameplayTagContainer& ExcludeInvItemTags);
	static int32 GetKitVersion();
	static class FString GetModifiedField();
	static void GetPatchAuthorAndName(const class FString& PatchFilename, class FString* OutAuthor, class FString* OutPatchName);
	static class FString GetPatchPathField();
	static class FString GetPatchTintField();
	static class FString GetPresetNameField();
	static class FString GetPresetsField();
	static struct FGameplayTagContainer GetRequiredInvItemTypeTags();
	static class FString GetSkinField();
	static class FString GetTypeField();
	static class FString GetUserBotLoadoutsPath(const class FName& TeamName);
	static class FString GetUserItemBuildFilename(const class FString& Type, const class FString& ItemBuild);
	static class FString GetUserItemBuildPath(const class FString& Type);
	static class FString GetUserLoadoutFilename(const class FName& LoadoutName);
	static class FString GetUserPatchesPath();
	static class FString GetUserPresetFilename(const class FString& Type, const class FString& Preset);
	static class FString GetUserPresetsPath(const class FString& Type);
	static class FString GetVersionField();
	static bool HasKitsToConvert();
	static bool HasRequiredInvItemTypeTags(const TArray<struct FPrimaryAssetId>& PrimaryAssetIds, const struct FGameplayTagContainer& RequiredInvItemTypeTags);
	static void KitDump(const class FString& Message, class UVaRestJsonObject* KitJsonObj);
	static bool KitValidation_Failed(const struct FGBKitValidationInfo& KitValidationInfo);
	static class FString KitValidation_ToString(const struct FGBKitValidationInfo& KitValidationInfo);
	static bool LoadKitFile(const class FString& Filename, class UVaRestJsonObject** OutKitJsonObj);
	static bool LoadPatch(const class FString& PatchFilename, class UTexture2D** OutPatchImage, class UTexture2D** OutPatchNormal, int32* OutImageWidth, int32* OutImageHeight, const class UObject* WorldContextObject);
	static class FString MakeValidLoadoutFilename(const class FString& Filename);
	static bool ProcessFailedKit(const class UObject* WorldContextObject, class UVaRestJsonObject* KitJsonObj, const struct FGBKitValidationInfo& KitValidationInfo, bool bRemove);
	static class FString StripItemTypePrefix(const class FString& InvItemTypeAsString);
	static void ValidateOrReplaceInvItemSkin(const class FName& ProfileName, const struct FGameplayTag& InvItemSkinTypeTag, const struct FPrimaryAssetId& DesiredInvItemSkinId, const class AGBCharacter* Character, struct FPrimaryAssetId* OutValidInvItemSkinId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBKitFunctionLibrary">();
	}
	static class UGBKitFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBKitFunctionLibrary>();
	}
};
static_assert(alignof(UGBKitFunctionLibrary) == 0x000008, "Wrong alignment on UGBKitFunctionLibrary");
static_assert(sizeof(UGBKitFunctionLibrary) == 0x000028, "Wrong size on UGBKitFunctionLibrary");

// Class GroundBranch.GBKitInfo
// 0x0120 (0x0340 - 0x0220)
class AGBKitInfo final : public AInfo
{
public:
	struct FGBReplicatedString                    ReplicatedLoadout;                                 // 0x0220(0x0018)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         bIsDefaultKit : 1;                                 // 0x0238(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_239[0x2F];                                     // 0x0239(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGBCharacter*>                   CharacterArray;                                    // 0x0268(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGBPatchAtlasInfo>              PatchAtlasInfos;                                   // 0x0280(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 PatchColourTextureAtlas;                           // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 PatchNormalTextureAtlas;                           // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CallSign;                                          // 0x02C0(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   CallSignPatchWidgetClass;                          // 0x02D8(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   CallSignHeightMapPatchWidgetClass;                 // 0x0300(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        CallSignHeightMapConverterMaterial;                // 0x0328(0x0018)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddPatch(const struct FGameplayTag& PatchNameTag, const class FString& PatchPath, const struct FSoftObjectPath& TintMaterial, const class FString& FallbackPatchPath, const struct FSoftObjectPath& FallbackTintMaterial);
	void ApplyToCharacter(class AGBCharacter* Character);
	void ClearPatchAtlas();
	void OnLoadPrimaryAssetsComplete();
	void OnRep_ReplicatedLoadout();
	void SetCallSign(const class FString& NewCallSign);
	void UpdateAssociatedCharacterPatches();
	void UpdatePatchTextureAtlas();

	class UVaRestJsonObject* BP_GetKitJsonObj() const;
	class FString GetCallSign() const;
	class FName GetKitName() const;
	class UTextureRenderTarget2D* GetPatchColourTextureAtlas() const;
	class UTextureRenderTarget2D* GetPatchNormalTextureAtlas() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBKitInfo">();
	}
	static class AGBKitInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBKitInfo>();
	}
};
static_assert(alignof(AGBKitInfo) == 0x000008, "Wrong alignment on AGBKitInfo");
static_assert(sizeof(AGBKitInfo) == 0x000340, "Wrong size on AGBKitInfo");
static_assert(offsetof(AGBKitInfo, ReplicatedLoadout) == 0x000220, "Member 'AGBKitInfo::ReplicatedLoadout' has a wrong offset!");
static_assert(offsetof(AGBKitInfo, CharacterArray) == 0x000268, "Member 'AGBKitInfo::CharacterArray' has a wrong offset!");
static_assert(offsetof(AGBKitInfo, PatchAtlasInfos) == 0x000280, "Member 'AGBKitInfo::PatchAtlasInfos' has a wrong offset!");
static_assert(offsetof(AGBKitInfo, PatchColourTextureAtlas) == 0x000298, "Member 'AGBKitInfo::PatchColourTextureAtlas' has a wrong offset!");
static_assert(offsetof(AGBKitInfo, PatchNormalTextureAtlas) == 0x0002A0, "Member 'AGBKitInfo::PatchNormalTextureAtlas' has a wrong offset!");
static_assert(offsetof(AGBKitInfo, CallSign) == 0x0002C0, "Member 'AGBKitInfo::CallSign' has a wrong offset!");
static_assert(offsetof(AGBKitInfo, CallSignPatchWidgetClass) == 0x0002D8, "Member 'AGBKitInfo::CallSignPatchWidgetClass' has a wrong offset!");
static_assert(offsetof(AGBKitInfo, CallSignHeightMapPatchWidgetClass) == 0x000300, "Member 'AGBKitInfo::CallSignHeightMapPatchWidgetClass' has a wrong offset!");
static_assert(offsetof(AGBKitInfo, CallSignHeightMapConverterMaterial) == 0x000328, "Member 'AGBKitInfo::CallSignHeightMapConverterMaterial' has a wrong offset!");

// Class GroundBranch.GBSquad
// 0x0020 (0x0240 - 0x0220)
class AGBSquad final : public AInfo
{
public:
	TSubclassOf<class AGBSquadState>              SquadStateClass;                                   // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGBSquadState*                          SquadState;                                        // 0x0228(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AController*>                    SquadMembers;                                      // 0x0230(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBSquad">();
	}
	static class AGBSquad* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBSquad>();
	}
};
static_assert(alignof(AGBSquad) == 0x000008, "Wrong alignment on AGBSquad");
static_assert(sizeof(AGBSquad) == 0x000240, "Wrong size on AGBSquad");
static_assert(offsetof(AGBSquad, SquadStateClass) == 0x000220, "Member 'AGBSquad::SquadStateClass' has a wrong offset!");
static_assert(offsetof(AGBSquad, SquadState) == 0x000228, "Member 'AGBSquad::SquadState' has a wrong offset!");
static_assert(offsetof(AGBSquad, SquadMembers) == 0x000230, "Member 'AGBSquad::SquadMembers' has a wrong offset!");

// Class GroundBranch.GBKytAIInterface
// 0x0000 (0x0000 - 0x0000)
class IGBKytAIInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBKytAIInterface">();
	}
	static class IGBKytAIInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGBKytAIInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGBKytAIInterface) == 0x000001, "Wrong alignment on IGBKytAIInterface");
static_assert(sizeof(IGBKytAIInterface) == 0x000001, "Wrong size on IGBKytAIInterface");

// Class GroundBranch.GBKytController
// 0x0198 (0x0490 - 0x02F8)
class AGBKytController : public AKytController
{
public:
	uint8                                         Pad_2F8[0x14];                                     // 0x02F8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKyAISettings                          AISettings;                                        // 0x030C(0x0064)(BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FKyAICapabilities                      AICapabilities;                                    // 0x0370(0x0002)(BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EAIRulesEngage                                LastReceivedROE;                                   // 0x0372(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIGoCodes                                    LastReceivedGoCode;                                // 0x0373(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIMoveCommand                         LastReceivedMoveCommand;                           // 0x0378(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAIMoveCommand>                 Waypoints;                                         // 0x0390(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBCharacter*                           ControlledGBChar;                                  // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Morale;                                            // 0x03B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightHealth;                                      // 0x03B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightTargetHealth;                                // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightDistance;                                    // 0x03BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightWeaponAmmo;                                  // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnAIFirstDetection;                                // 0x03C4(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C5[0x3];                                      // 0x03C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                bGlobalFleeLocation;                               // 0x03C8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlashlightStunned;                                // 0x03D4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D5[0xB];                                      // 0x03D5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOnTarget;                                         // 0x03E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxTimeOnTarget;                                   // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeDeviation;                                  // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceForPenalty;                             // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceForPenalty;                             // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceDeviation;                              // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddedMissDeviation;                                // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AimingBone;                                        // 0x03FC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialMissTargetThreshold;                        // 0x0404(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldMissTarget;                                 // 0x0408(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAimAtTarget;                              // 0x0409(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40A[0x2E];                                     // 0x040A(0x002E)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBAISquad*                             Squad;                                             // 0x0438(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBAIGuardPoint*                        CurrentGuardPoint;                                 // 0x0440(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKytBlackboard*                         CommonBB;                                          // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0x3C];                                     // 0x0450(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bWantsPlayerState : 1;                             // 0x048C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_48D[0x3];                                      // 0x048D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AICharacterDied(const struct FVector& DeathLocation);
	void ClearSquad();
	void CommandIssued(int32 CommandIdx, class AActor* Commander, const struct FVector& OptLocation, class AActor* OptTargetActor);
	bool ComputeAndSetNextGuardPoint();
	void DebugFreeze(bool bShouldFreeze);
	void FindHidingSpot(class AActor* HideFrom, TSubclassOf<class AActor> ActorClassFilter, TArray<class AActor*>* OutHidingSpots);
	void FlashlightWarn(class AGBCharacter* InstigatorChar);
	void Freeze(float FreezeTime);
	uint8 GetAIState();
	float GetAlertness();
	class UKytBlackboard* GetCommonBlackboard();
	int32 GetPerceptionCount();
	float GetVisibilityModifier(class AGBCharacter* Target);
	void GrenadeWarn(const struct FVector& Location);
	bool HasTarget();
	bool IsFrozen();
	void MoveCommandUpdated(const struct FAIMoveCommand& NextMoveCommand);
	bool NeedsReload();
	void OnLoadoutApplied(class AGBCharacter* InGBCharacter);
	void ReceiveGoCodeChanged(EAIGoCodes NewGoCode);
	void ReceiveMoveCommand(const struct FAIMoveCommand& MoveCommand);
	void ReceiveROEChanged(EAIRulesEngage NewROE);
	void Reload();
	void SetAIFocus(class AActor* FocusTarget);
	void SetAIState(EGBAIState NewState);
	void SetSearchTime(float NewValue);
	void SetSquad(class AGBAISquad* NewSquad);
	void SetWantsPlayerState(bool bValue);
	void UdpateAimTarget(class AActor* NewAimTarget);
	void UnFreeze();
	bool UpdateBlackboardSearchParams(const struct FVector& TargetLocation, const struct FVector& SearchDirection, float SearchTime);
	void UpdateCurrentShooterBB();

	class AGBCharacter* GetGBChar() const;
	struct FVector GetGrenadeLaunchVelocity() const;
	float GetSearchTime() const;
	class AGBAISquad* GetSquad() const;
	uint8 GetSquadSize() const;
	float GetSuppressionValue() const;
	float GetTimeOnCurrentTarget() const;
	bool IsAlive() const;
	bool IsDebugFrozen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBKytController">();
	}
	static class AGBKytController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBKytController>();
	}
};
static_assert(alignof(AGBKytController) == 0x000008, "Wrong alignment on AGBKytController");
static_assert(sizeof(AGBKytController) == 0x000490, "Wrong size on AGBKytController");
static_assert(offsetof(AGBKytController, AISettings) == 0x00030C, "Member 'AGBKytController::AISettings' has a wrong offset!");
static_assert(offsetof(AGBKytController, AICapabilities) == 0x000370, "Member 'AGBKytController::AICapabilities' has a wrong offset!");
static_assert(offsetof(AGBKytController, LastReceivedROE) == 0x000372, "Member 'AGBKytController::LastReceivedROE' has a wrong offset!");
static_assert(offsetof(AGBKytController, LastReceivedGoCode) == 0x000373, "Member 'AGBKytController::LastReceivedGoCode' has a wrong offset!");
static_assert(offsetof(AGBKytController, LastReceivedMoveCommand) == 0x000378, "Member 'AGBKytController::LastReceivedMoveCommand' has a wrong offset!");
static_assert(offsetof(AGBKytController, Waypoints) == 0x000390, "Member 'AGBKytController::Waypoints' has a wrong offset!");
static_assert(offsetof(AGBKytController, ControlledGBChar) == 0x0003A8, "Member 'AGBKytController::ControlledGBChar' has a wrong offset!");
static_assert(offsetof(AGBKytController, Morale) == 0x0003B0, "Member 'AGBKytController::Morale' has a wrong offset!");
static_assert(offsetof(AGBKytController, WeightHealth) == 0x0003B4, "Member 'AGBKytController::WeightHealth' has a wrong offset!");
static_assert(offsetof(AGBKytController, WeightTargetHealth) == 0x0003B8, "Member 'AGBKytController::WeightTargetHealth' has a wrong offset!");
static_assert(offsetof(AGBKytController, WeightDistance) == 0x0003BC, "Member 'AGBKytController::WeightDistance' has a wrong offset!");
static_assert(offsetof(AGBKytController, WeightWeaponAmmo) == 0x0003C0, "Member 'AGBKytController::WeightWeaponAmmo' has a wrong offset!");
static_assert(offsetof(AGBKytController, OnAIFirstDetection) == 0x0003C4, "Member 'AGBKytController::OnAIFirstDetection' has a wrong offset!");
static_assert(offsetof(AGBKytController, bGlobalFleeLocation) == 0x0003C8, "Member 'AGBKytController::bGlobalFleeLocation' has a wrong offset!");
static_assert(offsetof(AGBKytController, bFlashlightStunned) == 0x0003D4, "Member 'AGBKytController::bFlashlightStunned' has a wrong offset!");
static_assert(offsetof(AGBKytController, bOnTarget) == 0x0003E0, "Member 'AGBKytController::bOnTarget' has a wrong offset!");
static_assert(offsetof(AGBKytController, MaxTimeOnTarget) == 0x0003E4, "Member 'AGBKytController::MaxTimeOnTarget' has a wrong offset!");
static_assert(offsetof(AGBKytController, MaxTimeDeviation) == 0x0003E8, "Member 'AGBKytController::MaxTimeDeviation' has a wrong offset!");
static_assert(offsetof(AGBKytController, MinDistanceForPenalty) == 0x0003EC, "Member 'AGBKytController::MinDistanceForPenalty' has a wrong offset!");
static_assert(offsetof(AGBKytController, MaxDistanceForPenalty) == 0x0003F0, "Member 'AGBKytController::MaxDistanceForPenalty' has a wrong offset!");
static_assert(offsetof(AGBKytController, MaxDistanceDeviation) == 0x0003F4, "Member 'AGBKytController::MaxDistanceDeviation' has a wrong offset!");
static_assert(offsetof(AGBKytController, AddedMissDeviation) == 0x0003F8, "Member 'AGBKytController::AddedMissDeviation' has a wrong offset!");
static_assert(offsetof(AGBKytController, AimingBone) == 0x0003FC, "Member 'AGBKytController::AimingBone' has a wrong offset!");
static_assert(offsetof(AGBKytController, InitialMissTargetThreshold) == 0x000404, "Member 'AGBKytController::InitialMissTargetThreshold' has a wrong offset!");
static_assert(offsetof(AGBKytController, bShouldMissTarget) == 0x000408, "Member 'AGBKytController::bShouldMissTarget' has a wrong offset!");
static_assert(offsetof(AGBKytController, bOverrideAimAtTarget) == 0x000409, "Member 'AGBKytController::bOverrideAimAtTarget' has a wrong offset!");
static_assert(offsetof(AGBKytController, Squad) == 0x000438, "Member 'AGBKytController::Squad' has a wrong offset!");
static_assert(offsetof(AGBKytController, CurrentGuardPoint) == 0x000440, "Member 'AGBKytController::CurrentGuardPoint' has a wrong offset!");
static_assert(offsetof(AGBKytController, CommonBB) == 0x000448, "Member 'AGBKytController::CommonBB' has a wrong offset!");

// Class GroundBranch.GBKytDetectableActor
// 0x0018 (0x0238 - 0x0220)
class AGBKytDetectableActor : public AActor
{
public:
	bool                                          bContinuousDetection;                              // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          CalledActors;                                      // 0x0228(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void Detected(class AActor* DetectedBy);
	bool ShouldBeUsedAsTarget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBKytDetectableActor">();
	}
	static class AGBKytDetectableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBKytDetectableActor>();
	}
};
static_assert(alignof(AGBKytDetectableActor) == 0x000008, "Wrong alignment on AGBKytDetectableActor");
static_assert(sizeof(AGBKytDetectableActor) == 0x000238, "Wrong size on AGBKytDetectableActor");
static_assert(offsetof(AGBKytDetectableActor, bContinuousDetection) == 0x000220, "Member 'AGBKytDetectableActor::bContinuousDetection' has a wrong offset!");
static_assert(offsetof(AGBKytDetectableActor, CalledActors) == 0x000228, "Member 'AGBKytDetectableActor::CalledActors' has a wrong offset!");

// Class GroundBranch.GBKytFriendlyController
// 0x0038 (0x04C8 - 0x0490)
class AGBKytFriendlyController : public AGBKytController
{
public:
	bool                                          bActiveCombat;                                     // 0x0490(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerFiredRecently;                              // 0x0491(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_492[0x6];                                      // 0x0492(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UKytBlackboard*                         CommandBB;                                         // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PushTime;                                          // 0x04A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A4[0x24];                                     // 0x04A4(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyPushForce();
	void CommandReceived(EGBAICommands Command, const struct FVector& Location, class AActor* Actor);
	class UKytBlackboard* GetCommandBlackboard();
	void OnControlledCharacterHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void ResetPushState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBKytFriendlyController">();
	}
	static class AGBKytFriendlyController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBKytFriendlyController>();
	}
};
static_assert(alignof(AGBKytFriendlyController) == 0x000008, "Wrong alignment on AGBKytFriendlyController");
static_assert(sizeof(AGBKytFriendlyController) == 0x0004C8, "Wrong size on AGBKytFriendlyController");
static_assert(offsetof(AGBKytFriendlyController, bActiveCombat) == 0x000490, "Member 'AGBKytFriendlyController::bActiveCombat' has a wrong offset!");
static_assert(offsetof(AGBKytFriendlyController, bPlayerFiredRecently) == 0x000491, "Member 'AGBKytFriendlyController::bPlayerFiredRecently' has a wrong offset!");
static_assert(offsetof(AGBKytFriendlyController, CommandBB) == 0x000498, "Member 'AGBKytFriendlyController::CommandBB' has a wrong offset!");
static_assert(offsetof(AGBKytFriendlyController, PushTime) == 0x0004A0, "Member 'AGBKytFriendlyController::PushTime' has a wrong offset!");

// Class GroundBranch.GBTubeMagComponent
// 0x0060 (0x0270 - 0x0210)
class UGBTubeMagComponent final : public UGBAmmunitionFeedComponent
{
public:
	TArray<TSubclassOf<class AGBBulletItem>>      TubeContents;                                      // 0x0208(0x0010)(Net, ZeroConstructor, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AGBBulletItem>>      ClientTubeContents;                                // 0x0218(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Capacity;                                          // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        BulletId;                                          // 0x0234(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGBBulletItem>              BulletItemClass;                                   // 0x0248(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGBBulletItem>              ChamberedRound;                                    // 0x0250(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartPlusOne;                                     // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStayOpenOnLastRound;                              // 0x0259(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsFiringFromOpenBolt : 1;                         // 0x025A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBoltHeldOpen : 1;                                 // 0x025A(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_25B[0x5];                                      // 0x025B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class UGBAmmunitionFeedComponent* AmmunitionFeedComp)> OnBoltHeldOpenUpdated; // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool AddRoundToTube(TSubclassOf<class AGBBulletItem> NewRound);
	void AddToTube(TSubclassOf<class AGBBulletItem> NewBulletItem);
	class AGBBulletItem* FindCompatibleRound(class AGBCharacter* Character);
	TArray<TSubclassOf<class AGBBulletItem>> GetTubeContents();
	void OnBulletIdUpdated();
	void OnRep_BoltHeldOpen();
	void OnRep_TubeContents();
	TSubclassOf<class AGBBulletItem> RemoveFromTube();
	void SetBoltHeldOpen(bool bNewBoltIsHeldOpen);
	void SetBulletId(const struct FPrimaryAssetId& NewBulletId);
	void SetChamberedRound(TSubclassOf<class AGBBulletItem> NewChamberedRound);
	void SetIsFiringFromOpenBolt(bool bNewIsFiringFromOpenBolt);
	void SyncTubeContents();

	bool GetBoltHeldOpen() const;
	TSubclassOf<class AGBBulletItem> GetBulletItemClass() const;
	int32 GetCapacity() const;
	TSubclassOf<class AGBBulletItem> GetChamberedRound() const;
	int32 GetCount() const;
	bool GetIsFiringFromOpenBolt() const;
	bool IsLiveRoundChambered() const;
	bool StartPlusOne() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBTubeMagComponent">();
	}
	static class UGBTubeMagComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBTubeMagComponent>();
	}
};
static_assert(alignof(UGBTubeMagComponent) == 0x000010, "Wrong alignment on UGBTubeMagComponent");
static_assert(sizeof(UGBTubeMagComponent) == 0x000270, "Wrong size on UGBTubeMagComponent");
static_assert(offsetof(UGBTubeMagComponent, TubeContents) == 0x000208, "Member 'UGBTubeMagComponent::TubeContents' has a wrong offset!");
static_assert(offsetof(UGBTubeMagComponent, ClientTubeContents) == 0x000218, "Member 'UGBTubeMagComponent::ClientTubeContents' has a wrong offset!");
static_assert(offsetof(UGBTubeMagComponent, Capacity) == 0x000230, "Member 'UGBTubeMagComponent::Capacity' has a wrong offset!");
static_assert(offsetof(UGBTubeMagComponent, BulletId) == 0x000234, "Member 'UGBTubeMagComponent::BulletId' has a wrong offset!");
static_assert(offsetof(UGBTubeMagComponent, BulletItemClass) == 0x000248, "Member 'UGBTubeMagComponent::BulletItemClass' has a wrong offset!");
static_assert(offsetof(UGBTubeMagComponent, ChamberedRound) == 0x000250, "Member 'UGBTubeMagComponent::ChamberedRound' has a wrong offset!");
static_assert(offsetof(UGBTubeMagComponent, bStartPlusOne) == 0x000258, "Member 'UGBTubeMagComponent::bStartPlusOne' has a wrong offset!");
static_assert(offsetof(UGBTubeMagComponent, bStayOpenOnLastRound) == 0x000259, "Member 'UGBTubeMagComponent::bStayOpenOnLastRound' has a wrong offset!");
static_assert(offsetof(UGBTubeMagComponent, OnBoltHeldOpenUpdated) == 0x000260, "Member 'UGBTubeMagComponent::OnBoltHeldOpenUpdated' has a wrong offset!");

// Class GroundBranch.GBKytFriendlySpawn
// 0x0008 (0x0228 - 0x0220)
class AGBKytFriendlySpawn final : public AActor
{
public:
	TSubclassOf<class AGBCharacter>               FriendlyAIClassOverride;                           // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBKytFriendlySpawn">();
	}
	static class AGBKytFriendlySpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBKytFriendlySpawn>();
	}
};
static_assert(alignof(AGBKytFriendlySpawn) == 0x000008, "Wrong alignment on AGBKytFriendlySpawn");
static_assert(sizeof(AGBKytFriendlySpawn) == 0x000228, "Wrong size on AGBKytFriendlySpawn");
static_assert(offsetof(AGBKytFriendlySpawn, FriendlyAIClassOverride) == 0x000220, "Member 'AGBKytFriendlySpawn::FriendlyAIClassOverride' has a wrong offset!");

// Class GroundBranch.GBKytStatics
// 0x0000 (0x0028 - 0x0028)
class UGBKytStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool DoesPathExist(const class UObject* WorldContextObject, const struct FVector& InStart, const struct FVector& InEnd);
	static bool GetRandomReachablePointInRadius(const class UObject* WorldContextObject, const struct FVector& InOrigin, float Radius, struct FVector* OutRandomPoint);
	static bool IsOnNavMesh(const class UObject* WorldContextObject, const struct FVector& PointToCheck, const struct FVector& ErrorTolerance, struct FVector* OutResolvedLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBKytStatics">();
	}
	static class UGBKytStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBKytStatics>();
	}
};
static_assert(alignof(UGBKytStatics) == 0x000008, "Wrong alignment on UGBKytStatics");
static_assert(sizeof(UGBKytStatics) == 0x000028, "Wrong size on UGBKytStatics");

// Class GroundBranch.GBLadder
// 0x0110 (0x0330 - 0x0220)
class AGBLadder : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          PlayerCollisionComp;                               // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGBLadderComponent*                     LadderComp;                                        // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          MountVolume;                                       // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          TopMountVolume;                                    // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGBNavLinkUseActorComponent*            NavLinkUseActorComp;                               // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   InteractionWidget;                                 // 0x0250(0x0028)(Edit, BlueprintVisible, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           GameplayAbilityClasses;                            // 0x0278(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayTag                           BottomMountTag;                                    // 0x0288(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           TopMountTag;                                       // 0x0290(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           BottomDismountTag;                                 // 0x0298(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           TopDismountTag;                                    // 0x02A0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 VisualTarget;                                      // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TopNavLinkLocation;                                // 0x02B0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BottomNavLinkLocation;                             // 0x02BC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseKytNavLinks;                                   // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        TopUserWaitLocations;                              // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        BottomUserWaitLocations;                           // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x40];                                     // 0x02F0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginCursorOver(class UPrimitiveComponent* TouchedComponent);
	void OnEndCursorOver(class UPrimitiveComponent* TouchedComponent);
	void SetupLadder();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLadder">();
	}
	static class AGBLadder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBLadder>();
	}
};
static_assert(alignof(AGBLadder) == 0x000008, "Wrong alignment on AGBLadder");
static_assert(sizeof(AGBLadder) == 0x000330, "Wrong size on AGBLadder");
static_assert(offsetof(AGBLadder, PlayerCollisionComp) == 0x000228, "Member 'AGBLadder::PlayerCollisionComp' has a wrong offset!");
static_assert(offsetof(AGBLadder, LadderComp) == 0x000230, "Member 'AGBLadder::LadderComp' has a wrong offset!");
static_assert(offsetof(AGBLadder, MountVolume) == 0x000238, "Member 'AGBLadder::MountVolume' has a wrong offset!");
static_assert(offsetof(AGBLadder, TopMountVolume) == 0x000240, "Member 'AGBLadder::TopMountVolume' has a wrong offset!");
static_assert(offsetof(AGBLadder, NavLinkUseActorComp) == 0x000248, "Member 'AGBLadder::NavLinkUseActorComp' has a wrong offset!");
static_assert(offsetof(AGBLadder, InteractionWidget) == 0x000250, "Member 'AGBLadder::InteractionWidget' has a wrong offset!");
static_assert(offsetof(AGBLadder, GameplayAbilityClasses) == 0x000278, "Member 'AGBLadder::GameplayAbilityClasses' has a wrong offset!");
static_assert(offsetof(AGBLadder, BottomMountTag) == 0x000288, "Member 'AGBLadder::BottomMountTag' has a wrong offset!");
static_assert(offsetof(AGBLadder, TopMountTag) == 0x000290, "Member 'AGBLadder::TopMountTag' has a wrong offset!");
static_assert(offsetof(AGBLadder, BottomDismountTag) == 0x000298, "Member 'AGBLadder::BottomDismountTag' has a wrong offset!");
static_assert(offsetof(AGBLadder, TopDismountTag) == 0x0002A0, "Member 'AGBLadder::TopDismountTag' has a wrong offset!");
static_assert(offsetof(AGBLadder, VisualTarget) == 0x0002A8, "Member 'AGBLadder::VisualTarget' has a wrong offset!");
static_assert(offsetof(AGBLadder, TopNavLinkLocation) == 0x0002B0, "Member 'AGBLadder::TopNavLinkLocation' has a wrong offset!");
static_assert(offsetof(AGBLadder, BottomNavLinkLocation) == 0x0002BC, "Member 'AGBLadder::BottomNavLinkLocation' has a wrong offset!");
static_assert(offsetof(AGBLadder, bUseKytNavLinks) == 0x0002C8, "Member 'AGBLadder::bUseKytNavLinks' has a wrong offset!");
static_assert(offsetof(AGBLadder, TopUserWaitLocations) == 0x0002D0, "Member 'AGBLadder::TopUserWaitLocations' has a wrong offset!");
static_assert(offsetof(AGBLadder, BottomUserWaitLocations) == 0x0002E0, "Member 'AGBLadder::BottomUserWaitLocations' has a wrong offset!");

// Class GroundBranch.GBLadderComponent
// 0x0020 (0x04A0 - 0x0480)
class UGBLadderComponent final : public UBoxComponent
{
public:
	TMulticastInlineDelegate<void(class UGBLadderComponent* LadderComponent, class AGBCharacter* LadderUser)> OnLadderMounted; // 0x0480(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UGBLadderComponent* LadderComponent, class AGBCharacter* LadderUser)> OnLadderDismounted; // 0x0490(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	float GetLadderBottom() const;
	float GetLadderTop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLadderComponent">();
	}
	static class UGBLadderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBLadderComponent>();
	}
};
static_assert(alignof(UGBLadderComponent) == 0x000010, "Wrong alignment on UGBLadderComponent");
static_assert(sizeof(UGBLadderComponent) == 0x0004A0, "Wrong size on UGBLadderComponent");
static_assert(offsetof(UGBLadderComponent, OnLadderMounted) == 0x000480, "Member 'UGBLadderComponent::OnLadderMounted' has a wrong offset!");
static_assert(offsetof(UGBLadderComponent, OnLadderDismounted) == 0x000490, "Member 'UGBLadderComponent::OnLadderDismounted' has a wrong offset!");

// Class GroundBranch.GBVOIPAudioComponent
// 0x0030 (0x0430 - 0x0400)
class UGBVOIPAudioComponent final : public UAkAudioInputComponent
{
public:
	uint8                                         Pad_3F8[0x38];                                     // 0x03F8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBVOIPAudioComponent">();
	}
	static class UGBVOIPAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBVOIPAudioComponent>();
	}
};
static_assert(alignof(UGBVOIPAudioComponent) == 0x000010, "Wrong alignment on UGBVOIPAudioComponent");
static_assert(sizeof(UGBVOIPAudioComponent) == 0x000430, "Wrong size on UGBVOIPAudioComponent");

// Class GroundBranch.GBLevelSummary
// 0x0038 (0x0060 - 0x0028)
class UGBLevelSummary final : public UObject
{
public:
	class FString                                 Title;                                             // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Author;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, AssetRegistrySearchable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLevelSummary">();
	}
	static class UGBLevelSummary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBLevelSummary>();
	}
};
static_assert(alignof(UGBLevelSummary) == 0x000008, "Wrong alignment on UGBLevelSummary");
static_assert(sizeof(UGBLevelSummary) == 0x000060, "Wrong size on UGBLevelSummary");
static_assert(offsetof(UGBLevelSummary, Title) == 0x000028, "Member 'UGBLevelSummary::Title' has a wrong offset!");
static_assert(offsetof(UGBLevelSummary, Author) == 0x000038, "Member 'UGBLevelSummary::Author' has a wrong offset!");
static_assert(offsetof(UGBLevelSummary, Description) == 0x000048, "Member 'UGBLevelSummary::Description' has a wrong offset!");

// Class GroundBranch.GBLocalPlayer
// 0x0008 (0x0260 - 0x0258)
class UGBLocalPlayer final : public ULocalPlayer
{
public:
	class UGBPlayerSettings*                      PlayerSettings;                                    // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Benchmark(const class FString& Parameters);

	class UGBPlayerSettings* GetPlayerSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLocalPlayer">();
	}
	static class UGBLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBLocalPlayer>();
	}
};
static_assert(alignof(UGBLocalPlayer) == 0x000008, "Wrong alignment on UGBLocalPlayer");
static_assert(sizeof(UGBLocalPlayer) == 0x000260, "Wrong size on UGBLocalPlayer");
static_assert(offsetof(UGBLocalPlayer, PlayerSettings) == 0x000258, "Member 'UGBLocalPlayer::PlayerSettings' has a wrong offset!");

// Class GroundBranch.GBLuaActorPackage
// 0x0000 (0x00C0 - 0x00C0)
class UGBLuaActorPackage final : public ULuaBlueprintPackage
{
public:
	void AddTag(const struct FLuaValue& InActor, const struct FLuaValue& InTag) const;
	class AActor* GetActorRefInternal(const struct FLuaValue& PossibleActor) const;
	struct FLuaValue GetLocation(const struct FLuaValue& InActor) const;
	struct FLuaValue GetName(const struct FLuaValue& InActor) const;
	struct FLuaValue GetOverlappingPlayers(const struct FLuaValue& InActor) const;
	struct FLuaValue GetOverlaps(const struct FLuaValue& InActor, const struct FLuaValue& InActorClass) const;
	struct FLuaValue GetRotation(const struct FLuaValue& InActor) const;
	struct FLuaValue GetTag(const struct FLuaValue& InActor, const struct FLuaValue& Index_0) const;
	struct FLuaValue GetTags(const struct FLuaValue& InActor) const;
	struct FLuaValue GetTeamId(const struct FLuaValue& InActor) const;
	struct FLuaValue HasTag(const struct FLuaValue& InActor, const struct FLuaValue& InTag) const;
	struct FLuaValue IsActive(const struct FLuaValue& InActor) const;
	struct FLuaValue IsColliding(const struct FLuaValue& InActor) const;
	struct FLuaValue IsOverlapping(const struct FLuaValue& InActor, const struct FLuaValue& OtherActor) const;
	struct FLuaValue IsWithinTriggerVolume(const struct FLuaValue& InActor, const struct FLuaValue& InGameTrigger) const;
	void RemoveTag(const struct FLuaValue& InActor, const struct FLuaValue& InTag) const;
	void SetActive(const struct FLuaValue& InActor, const struct FLuaValue& InNewActive) const;
	void SetEnableCollision(const struct FLuaValue& InActor, const struct FLuaValue& Enabled) const;
	void SetHidden(const struct FLuaValue& InActor, const struct FLuaValue& inHidden) const;
	struct FLuaValue SetTeamId(const struct FLuaValue& InActor, const struct FLuaValue& InTeamId) const;
	struct FLuaValue ToString(const struct FLuaValue& InActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLuaActorPackage">();
	}
	static class UGBLuaActorPackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBLuaActorPackage>();
	}
};
static_assert(alignof(UGBLuaActorPackage) == 0x000008, "Wrong alignment on UGBLuaActorPackage");
static_assert(sizeof(UGBLuaActorPackage) == 0x0000C0, "Wrong size on UGBLuaActorPackage");

// Class GroundBranch.GBLuaAIPackage
// 0x0000 (0x00C0 - 0x00C0)
class UGBLuaAIPackage final : public ULuaBlueprintPackage
{
public:
	void DisableFleeState();
	struct FLuaValue GetSpawnIsActiveAtCurrentTimeOfDay(const struct FLuaValue& InSpawnPoint);
	void TriggerFleeState(const struct FLuaValue& FleeFromLocation);
	struct FLuaValue VerifyAILoadoutExists(const struct FLuaValue& InLoadoutFilename);

	struct FLuaValue CheckLocationReachable(const struct FLuaValue& InStartLoc, const struct FLuaValue& InEndLoc) const;
	void CleanUp(const struct FLuaValue& InAIControllerTag) const;
	void Create(const struct FLuaValue& InSpawnPoint, const struct FLuaValue& InAIControllerTag, const struct FLuaValue& InFreezeTime) const;
	void CreateOverDuration(const struct FLuaValue& InDuration, const struct FLuaValue& InCount, const struct FLuaValue& InOrderedSpawnPoints, const struct FLuaValue& InAIControllerTag) const;
	void CreateWithTransform(const struct FLuaValue& InVirtualSpawnPoint, const struct FLuaValue& InSpawnTransform, const struct FLuaValue& InAIControllerTag, const struct FLuaValue& InFreezeTime) const;
	struct FLuaValue GetAIHotspotName(const struct FLuaValue& InAIHotspot) const;
	struct FLuaValue GetControllers(const struct FLuaValue& InControllerClass, const struct FLuaValue& InTag, const struct FLuaValue& InTeamId, const struct FLuaValue& InSquadId) const;
	struct FLuaValue GetGuardPointName(const struct FLuaValue& InGuardPoint) const;
	struct FLuaValue GetMaxCount() const;
	struct FLuaValue GetRandomReachablePointInRadius(const struct FLuaValue& InOrigin, const struct FLuaValue& InRadius) const;
	struct FLuaValue GetSpawnPointInfo(const struct FLuaValue& InSpawnPoint) const;
	struct FLuaValue GetSquadId(const struct FLuaValue& InAIController) const;
	struct FLuaValue GetSquadOrders(const struct FLuaValue& InAIController) const;
	struct FLuaValue IsAI(const struct FLuaValue& InAIController, const struct FLuaValue& InAIControllerTag) const;
	struct FLuaValue IsOnNavMesh(const struct FLuaValue& InLocationOrActor) const;
	struct FLuaValue IsSpawnPointInHotspot(const struct FLuaValue& InAISpawnPoint, const struct FLuaValue& InAIHotspot) const;
	void KillAI(const struct FLuaValue& AIController) const;
	struct FLuaValue ProjectPointToNavigation(const struct FLuaValue& InPoint, const struct FLuaValue& InQueryExtent) const;
	void SetSearchTarget(const struct FLuaValue& InAIController, const struct FLuaValue& InTargetLocation, const struct FLuaValue& InSearchTime) const;
	void SetSquadOrders(const struct FLuaValue& InControllerClass, const struct FLuaValue& InTag, const struct FLuaValue& InTeamId, const struct FLuaValue& InSquadId, const struct FLuaValue& InSquadOrders) const;
	void SetSquadOrdersForAIController(const struct FLuaValue& InAIController, const struct FLuaValue& InSquadOrders) const;
	void SetSquadSearchTarget(const struct FLuaValue& InControllerClass, const struct FLuaValue& InTag, const struct FLuaValue& InTeamId, const struct FLuaValue& InSquadId, const struct FLuaValue& InTargetLocation, const struct FLuaValue& InSearchTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLuaAIPackage">();
	}
	static class UGBLuaAIPackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBLuaAIPackage>();
	}
};
static_assert(alignof(UGBLuaAIPackage) == 0x000008, "Wrong alignment on UGBLuaAIPackage");
static_assert(sizeof(UGBLuaAIPackage) == 0x0000C0, "Wrong size on UGBLuaAIPackage");

// Class GroundBranch.GBLuaComponent
// 0x0000 (0x0170 - 0x0170)
class UGBLuaComponent final : public ULuaComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLuaComponent">();
	}
	static class UGBLuaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBLuaComponent>();
	}
};
static_assert(alignof(UGBLuaComponent) == 0x000008, "Wrong alignment on UGBLuaComponent");
static_assert(sizeof(UGBLuaComponent) == 0x000170, "Wrong size on UGBLuaComponent");

// Class GroundBranch.GBLuaGameModePackage
// 0x0018 (0x00D8 - 0x00C0)
class UGBLuaGameModePackage final : public ULuaBlueprintPackage
{
public:
	int32                                         NumberOfMovementsToTrack;                          // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoBalanceLightTouchSetting;                      // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 PastMovementsTable;                                // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void BalanceTeams(const struct FLuaValue& InAttackingTeamId, const struct FLuaValue& InDefendingTeamId, const struct FLuaValue& InIdealTeamSizeDifference, const struct FLuaValue& InAutoBalanceType);
	void CreateBlackOut(const struct FLuaValue& InTeamId, const struct FLuaValue& FadeIn);
	void EnterPlayArea(const struct FLuaValue& InPlayerIdOrObject);
	void EnterReadyRoom(const struct FLuaValue& InPlayerIdOrObject);
	struct FLuaValue GetBestLateComerInsertionPoint(const struct FLuaValue& InPlayerIdOrObject);
	struct FLuaValue GetCurrentPlayingSequenceInfo();
	struct FLuaValue GetExfilSequenceActors(const struct FLuaValue& InExtractionPoint);
	struct FLuaValue GetGameStatValue(const struct FLuaValue& InGameStatKey);
	struct FLuaValue GetInfilSequenceActors(const struct FLuaValue& InInsertionPoint);
	struct FLuaValue GetMainSequenceActors();
	struct FLuaValue GetMissionCompletionFraction();
	struct FLuaValue GetSearchablePropType(const struct FLuaValue& InSearchableProp);
	struct FLuaValue GetSearchablePropYieldsIntel(const struct FLuaValue& InSearchableProp);
	struct FLuaValue IsSequencePlaying();
	void NotifyMissionSettingValueChanged(const struct FLuaValue& InSettingName);
	void NotifyObjectiveStatusUpdate(const struct FLuaValue& InTeamId, const struct FLuaValue& InMissionObjectiveActor, const struct FLuaValue& InStatusUpdateType, const struct FLuaValue& InFloatParam);
	struct FLuaValue PrepLatecomer(const struct FLuaValue& InPlayerIdOrObject);
	void RemoveBlackOut(const struct FLuaValue& InTeamId, const struct FLuaValue& FadeOut);
	void ResetBalanceTeams(const struct FLuaValue& NewNumberOfMovementsToTrack, const struct FLuaValue& NewAutoBalanceLightTouchSetting);
	void SetMissionSettingValue(const struct FLuaValue& SettingName, const struct FLuaValue& SettingValue);
	void SetObjectiveStatus(const struct FLuaValue& InMissionObjectiveActor, const struct FLuaValue& InNewObjectiveStatus);
	void SetSearchablePropYieldsIntel(const struct FLuaValue& InSearchableProp, const struct FLuaValue& NewYieldsIntel);
	void StopCurrentSequencePlayback(const struct FLuaValue& SuppressBlackOutAfter);
	struct FLuaValue TriggerLevelSequenceActor(const struct FLuaValue& InLevelSequenceActor, const struct FLuaValue& IsCutscene, const struct FLuaValue& CanAbort, const struct FLuaValue& ResetActors, const struct FLuaValue& HidePlayers, const struct FLuaValue& BlackOutAfter);

	void AddBots(const struct FLuaValue& InCount, const struct FLuaValue& InTeamId) const;
	void AddGameObjective(const struct FLuaValue& InTeamId, const struct FLuaValue& InName, const struct FLuaValue& InObjectiveType) const;
	void AddGameStat(const struct FLuaValue& InGameStat) const;
	struct FLuaValue AddObjectiveMarker(const struct FLuaValue& InLocation, const struct FLuaValue& InTeamId, const struct FLuaValue& InMarkerName, const struct FLuaValue& InMarkerType, const struct FLuaValue& Inactive) const;
	void AddPlayerTeam(const struct FLuaValue& InTeamId, const struct FLuaValue& InTeamName, const struct FLuaValue& InPlayerLoadoutName) const;
	void AddSearchLocation(const struct FLuaValue& InTeamId, const struct FLuaValue& InName, const struct FLuaValue& InObjectiveType) const;
	void AwardTeamScore(const struct FLuaValue& InTeamId, const struct FLuaValue& InScoreName, const struct FLuaValue& InScoreMultiple) const;
	void BroadcastGameMessage(const struct FLuaValue& InGameMessageId, const struct FLuaValue& InType, const struct FLuaValue& InDuration) const;
	void CancelBenchmark() const;
	void ClearGameObjectives() const;
	void ClearGameStats() const;
	void ClearRoundStageTime() const;
	void ClearSearchLocations() const;
	void ClearVolunteerStatuses() const;
	void EnableExtraLogging() const;
	struct FLuaValue FormatString(const struct FLuaValue& InFormatTable) const;
	void FreezeBots(const struct FLuaValue& InTeamId) const;
	struct FLuaValue GetCurrentMissionTags() const;
	struct FLuaValue GetInsertionPointName(const struct FLuaValue& InInsertionPoint) const;
	struct FLuaValue GetObjectiveInfo(const struct FLuaValue& InMissionObjectiveActor) const;
	struct FLuaValue GetObjectiveScript(const struct FLuaValue& InMissionObjectiveActor) const;
	struct FLuaValue GetObjectiveStatus(const struct FLuaValue& InMissionObjectiveActor) const;
	class FName GetObjectiveStatusAsName(EGBMissionObjectiveStatus ObjectiveStatus) const;
	struct FLuaValue GetPlayerCount(const struct FLuaValue& InExcludeBots) const;
	struct FLuaValue GetPlayerList(const struct FLuaValue& InTeamId, const struct FLuaValue& InExcludeBots) const;
	struct FLuaValue GetPlayerListByLives(const struct FLuaValue& InTeamId, const struct FLuaValue& InMinLives, const struct FLuaValue& InExcludeBots) const;
	struct FLuaValue GetPlayerListByStatus(const struct FLuaValue& InTeamId, const struct FLuaValue& InReadyStatus, const struct FLuaValue& InExcludeBots) const;
	struct FLuaValue GetReadyPlayerTeamCounts(const struct FLuaValue& InExcludeBots) const;
	struct FLuaValue GetRoundStage() const;
	struct FLuaValue GetRoundStageTime() const;
	struct FLuaValue GetScript() const;
	struct FLuaValue GetSpawnProtectionVolumeHasNoImmunity(const struct FLuaValue& InSpawnProtectionVolume) const;
	struct FLuaValue GetTimeOfDay() const;
	struct FLuaValue GetVolunteerList(const struct FLuaValue& InTeamId, const struct FLuaValue& InExcludeBots) const;
	struct FLuaValue GetVolunteerListByLives(const struct FLuaValue& InTeamId, const struct FLuaValue& InMinLives, const struct FLuaValue& InExcludeBots) const;
	struct FLuaValue GetVolunteerListByStatus(const struct FLuaValue& InTeamId, const struct FLuaValue& InReadyStatus, const struct FLuaValue& InExcludeBots) const;
	struct FLuaValue IsEditingMission() const;
	void MakeEveryoneSpectate() const;
	void RemoveBots(const struct FLuaValue& InCount, const struct FLuaValue& InTeamId) const;
	void ResetMatchStats() const;
	void ResetPlayerScores() const;
	void ResetTeamScores() const;
	void ResetWatch() const;
	void ReturnToMenu() const;
	void SendEveryoneToPlayArea() const;
	void SendEveryoneToReadyRoom() const;
	void SendMessageToPlayerById(const int32 InPlayerId, const class FName InMessage, const class FName InMessageType, const float InMessageDuration) const;
	void SetCaptureState(const struct FLuaValue& IsCapturing) const;
	void SetCaptureZone(const struct FLuaValue& InCaptureRadius, const struct FLuaValue& InCaptureHeight, const struct FLuaValue& InDefenderTeamId, const struct FLuaValue& InZoneIsSpherical) const;
	void SetDefaultRoundStageTime(const struct FLuaValue& InRoundStageName, const struct FLuaValue& InNewTimeLimit) const;
	void SetGameModeName(const struct FLuaValue& InGameModeName) const;
	void SetObjectiveLocation(const struct FLuaValue& InObjectiveLocation) const;
	void SetPlayerScoreTypes(const struct FLuaValue& InScoreTypeTable) const;
	void SetPlayerTeamRole(const struct FLuaValue& InTeamId, const struct FLuaValue& InNewRole) const;
	void SetRoundIsTemporaryGameMode(const struct FLuaValue& IsTemporary) const;
	void SetRoundStage(const struct FLuaValue& InRoundStageName) const;
	void SetRoundStageTime(const struct FLuaValue& InRoundStageTime) const;
	void SetTeamAttitude(const struct FLuaValue& InTeamId, const struct FLuaValue& InOtherTeamId, const struct FLuaValue& InAttitude) const;
	void SetTeamScoreTypes(const struct FLuaValue& InScoreTypeTable) const;
	void SetWatchMode(const struct FLuaValue& InWatchMode, const struct FLuaValue& InDisplayBearing, const struct FLuaValue& InDisplayDistance, const struct FLuaValue& InDisplayUpDown, const struct FLuaValue& InMeasure2D) const;
	void SpawnEffectAtLocation(const struct FLuaValue& InEffectClass, const struct FLuaValue& InLocation) const;
	void StartBenchmark() const;
	void UnFreezeBots(const struct FLuaValue& InTeamId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLuaGameModePackage">();
	}
	static class UGBLuaGameModePackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBLuaGameModePackage>();
	}
};
static_assert(alignof(UGBLuaGameModePackage) == 0x000008, "Wrong alignment on UGBLuaGameModePackage");
static_assert(sizeof(UGBLuaGameModePackage) == 0x0000D8, "Wrong size on UGBLuaGameModePackage");
static_assert(offsetof(UGBLuaGameModePackage, NumberOfMovementsToTrack) == 0x0000C0, "Member 'UGBLuaGameModePackage::NumberOfMovementsToTrack' has a wrong offset!");
static_assert(offsetof(UGBLuaGameModePackage, AutoBalanceLightTouchSetting) == 0x0000C4, "Member 'UGBLuaGameModePackage::AutoBalanceLightTouchSetting' has a wrong offset!");
static_assert(offsetof(UGBLuaGameModePackage, PastMovementsTable) == 0x0000C8, "Member 'UGBLuaGameModePackage::PastMovementsTable' has a wrong offset!");

// Class GroundBranch.GBLuaGameplayStaticsPackage
// 0x0000 (0x00C0 - 0x00C0)
class UGBLuaGameplayStaticsPackage final : public ULuaBlueprintPackage
{
public:
	void DisplayDebugLine(const struct FLuaValue& InStartLocation, const struct FLuaValue& InEndLocation, const struct FLuaValue& InDuration) const;
	void DisplayDebugSphere(const struct FLuaValue& InLocation, const struct FLuaValue& InRadius, const struct FLuaValue& InDuration) const;
	struct FLuaValue GetAllActorsOfClass(const struct FLuaValue& InActorClass) const;
	struct FLuaValue GetAllActorsOfClassWithTag(const struct FLuaValue& InActorClass, const struct FLuaValue& InTag) const;
	struct FLuaValue GetAllActorsWithTag(const struct FLuaValue& InTag) const;
	struct FLuaValue GetNetMode() const;
	struct FLuaValue GetPatrolRouteLinkedActors(const struct FLuaValue& InPatrolRouteActor) const;
	struct FLuaValue GetValidatedSpawnLocation(const struct FLuaValue& InSpawnLocation, const struct FLuaValue& InCapsuleHalfHeight, const struct FLuaValue& InCapsuleRadius) const;
	struct FLuaValue PlaceItemAt(const struct FLuaValue& InItemClass, const struct FLuaValue& InLocation, const struct FLuaValue& InRotation) const;
	struct FLuaValue TraceVisible(const struct FLuaValue& InStartLocation, const struct FLuaValue& InEndLocation, const struct FLuaValue& InIgnoreActors, const struct FLuaValue& InDebug) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLuaGameplayStaticsPackage">();
	}
	static class UGBLuaGameplayStaticsPackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBLuaGameplayStaticsPackage>();
	}
};
static_assert(alignof(UGBLuaGameplayStaticsPackage) == 0x000008, "Wrong alignment on UGBLuaGameplayStaticsPackage");
static_assert(sizeof(UGBLuaGameplayStaticsPackage) == 0x0000C0, "Wrong size on UGBLuaGameplayStaticsPackage");

// Class GroundBranch.GBLuaInterface
// 0x0000 (0x0000 - 0x0000)
class IGBLuaInterface final
{
public:
	struct FLuaValue GetLuaTable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLuaInterface">();
	}
	static class IGBLuaInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGBLuaInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGBLuaInterface) == 0x000001, "Wrong alignment on IGBLuaInterface");
static_assert(sizeof(IGBLuaInterface) == 0x000001, "Wrong size on IGBLuaInterface");

// Class GroundBranch.GBLuaInventoryPackage
// 0x0000 (0x00C0 - 0x00C0)
class UGBLuaInventoryPackage final : public ULuaBlueprintPackage
{
public:
	void AddCustomKitTableToLoadoutTable(struct FLuaValue* InCustomKitTable, struct FLuaValue* InLoadoutTable);
	void CreateLoadoutFromTable(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InLoadoutName, const struct FLuaValue& InLoadoutTable, const struct FLuaValue& InSplitItemField);
	struct FLuaValue GetPlayerLoadoutAsTable(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& LoadoutName, const struct FLuaValue& InSplitItemField);
	void RemoveItemTypesFromLoadoutTable(const struct FLuaValue& InItemTypesToRemove, struct FLuaValue* InLoadoutTable, struct FLuaValue* InSplitItemField);
	void SetItemFieldFromTable(const struct FLuaValue& LoadoutReferenceObject, const struct FLuaValue& ItemType, const struct FLuaValue& NewItemData);
	struct FLuaValue VerifyLoadoutExists(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InLoadoutName);

	void ClearItemField(const struct FLuaValue& InKitJsonObj, const struct FLuaValue& InItemType) const;
	struct FLuaValue GetCustomKitAsTable(const struct FLuaValue& InKitFileName, const struct FLuaValue& InSplitItemField) const;
	struct FLuaValue GetItemDisplayName(const struct FLuaValue& InItemType, const struct FLuaValue& InItemAssetPath) const;
	void LimitSupplies(const struct FLuaValue& InKitJsonObj, const struct FLuaValue& InFragsLimit, const struct FLuaValue& InSmokesLimit, const struct FLuaValue& InFlashbangsLimit, const struct FLuaValue& InBreachChargeLimit) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLuaInventoryPackage">();
	}
	static class UGBLuaInventoryPackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBLuaInventoryPackage>();
	}
};
static_assert(alignof(UGBLuaInventoryPackage) == 0x000008, "Wrong alignment on UGBLuaInventoryPackage");
static_assert(sizeof(UGBLuaInventoryPackage) == 0x0000C0, "Wrong size on UGBLuaInventoryPackage");

// Class GroundBranch.GBLuaPlayerPackage
// 0x0000 (0x00C0 - 0x00C0)
class UGBLuaPlayerPackage final : public ULuaBlueprintPackage
{
public:
	void AddIgnoreUseInputReason(const struct FLuaValue& InPlayerIdOrObject);
	void AwardPlayerScore(const struct FLuaValue& InPlayerIdOrObjectState, const struct FLuaValue& InScoreName, const struct FLuaValue& InScoreMultiple);
	void Damage(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InDamageAmount, const struct FLuaValue& InDamageType);
	void FreezePlayer(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InDuration);
	struct FLuaValue GetCallSign(const struct FLuaValue& InPlayerIdOrObject);
	struct FLuaValue GetCharacter(const struct FLuaValue& InPlayerIdOrObject);
	struct FLuaValue GetInsertionPoint(const struct FLuaValue& InPlayerIdOrObject);
	struct FLuaValue GetInventory(const struct FLuaValue& InPlayerIdOrObject);
	struct FLuaValue GetLives(const struct FLuaValue& InPlayerIdOrObject);
	struct FLuaValue GetName(const struct FLuaValue& InPlayerIdOrObject);
	struct FLuaValue GetPlayerStat(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InKey);
	struct FLuaValue GetReadyStatus(const struct FLuaValue& InPlayerIdOrObject);
	struct FLuaValue GetVolunteerStatus(const struct FLuaValue& InPlayerIdOrObject);
	struct FLuaValue GiveItem(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InItemClass, const struct FLuaValue& InEquip);
	struct FLuaValue HasGameplayTag(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InTagName);
	struct FLuaValue HasItemWithTag(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InTag);
	struct FLuaValue IsABot(const struct FLuaValue& InPlayerIdOrObject);
	struct FLuaValue IsAlive(const struct FLuaValue& InPlayerIdOrObject);
	void Kill(const struct FLuaValue& InPlayerIdOrObject);
	void NotifyObjectiveStatusUpdate(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InMissionObjectiveActor, const struct FLuaValue& InStatusUpdateType, const struct FLuaValue& InFloatParam);
	void RemoveIgnoreUseInputReason(const struct FLuaValue& InPlayerIdOrObject);
	void ResetPlayerScores(const struct FLuaValue& InPlayerIdOrObject);
	void SetAllowedToRestart(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InAllowed);
	void SetInsertionPoint(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InNewInsertionPoint);
	void SetLives(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InNewLives);
	void SetReadyStatus(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InNewStatus);
	void SetVolunteerStatus(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InVolunteered);
	void ShowGameMessage(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InMessage, const struct FLuaValue& InType, const struct FLuaValue& InDuration);
	void ShowHint(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InHintName, const struct FLuaValue& InWidgetName);
	void ShowWorldPrompt(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InLocation, const struct FLuaValue& InTag, const struct FLuaValue& InDuration);
	void SpawnEffectAtPlayer(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InEffectClass);
	void Teleport(const struct FLuaValue& InPlayerIdOrObject, const struct FLuaValue& InLocation, const struct FLuaValue& InRotation);
	struct FLuaValue ValidatePlayer(const struct FLuaValue& InPlayerIdOrObject);

	struct FLuaValue CheckCallSignProfanity(const struct FLuaValue& InCallSign) const;
	struct FLuaValue GetPlayerState(const struct FLuaValue& InPlayerIdOrObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLuaPlayerPackage">();
	}
	static class UGBLuaPlayerPackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBLuaPlayerPackage>();
	}
};
static_assert(alignof(UGBLuaPlayerPackage) == 0x000008, "Wrong alignment on UGBLuaPlayerPackage");
static_assert(sizeof(UGBLuaPlayerPackage) == 0x0000C0, "Wrong size on UGBLuaPlayerPackage");

// Class GroundBranch.GBLuaTimerPackage
// 0x0050 (0x0110 - 0x00C0)
class UGBLuaTimerPackage final : public ULuaBlueprintPackage
{
public:
	uint8                                         Pad_C0[0x50];                                      // 0x00C0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAll();
	void ClearTimer(const struct FLuaValue& InTimerHandle);
	void SetTimer(const struct FLuaValue& InTimerHandle, const struct FLuaValue& InTable, const struct FLuaValue& InFunction, const struct FLuaValue& InRate, const struct FLuaValue& InLoop);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLuaTimerPackage">();
	}
	static class UGBLuaTimerPackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBLuaTimerPackage>();
	}
};
static_assert(alignof(UGBLuaTimerPackage) == 0x000008, "Wrong alignment on UGBLuaTimerPackage");
static_assert(sizeof(UGBLuaTimerPackage) == 0x000110, "Wrong size on UGBLuaTimerPackage");

// Class GroundBranch.GBLXRDetectionComponent
// 0x00B0 (0x05F0 - 0x0540)
class UGBLXRDetectionComponent final : public ULXRDetectionComponent
{
public:
	class AGBSky*                                 SkyActor;                                          // 0x0540(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_548[0xA8];                                     // 0x0548(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBLXRDetectionComponent">();
	}
	static class UGBLXRDetectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBLXRDetectionComponent>();
	}
};
static_assert(alignof(UGBLXRDetectionComponent) == 0x000010, "Wrong alignment on UGBLXRDetectionComponent");
static_assert(sizeof(UGBLXRDetectionComponent) == 0x0005F0, "Wrong size on UGBLXRDetectionComponent");
static_assert(offsetof(UGBLXRDetectionComponent, SkyActor) == 0x000540, "Member 'UGBLXRDetectionComponent::SkyActor' has a wrong offset!");

// Class GroundBranch.GBMagazine
// 0x0048 (0x0490 - 0x0448)
class AGBMagazine : public AGBInvItem
{
public:
	TMulticastInlineDelegate<void(const class AGBMagazine* Magazine)> OnCountUpdated;                // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         Capacity;                                          // 0x0458(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InitialCount;                                      // 0x045C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Count;                                             // 0x0460(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        BulletId;                                          // 0x0464(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGBBulletProjectile>        BulletProjectileClass;                             // 0x0478(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TracerFrequency;                                   // 0x0480(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         TracerColourIndex;                                 // 0x0484(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_485[0x3];                                      // 0x0485(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartTracerCount;                                  // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AdjustCount(int32 Amount);
	void OnBulletIdUpdated();
	void OnRep_Count();
	void SetBulletId(const struct FPrimaryAssetId& NewBulletId);
	void SetCount(int32 NewCount);

	TSubclassOf<class AGBBulletProjectile> GetBulletProjectileClass() const;
	int32 GetCapacity() const;
	int32 GetCount() const;
	uint8 GetTraceColourIndexForRound() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBMagazine">();
	}
	static class AGBMagazine* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBMagazine>();
	}
};
static_assert(alignof(AGBMagazine) == 0x000008, "Wrong alignment on AGBMagazine");
static_assert(sizeof(AGBMagazine) == 0x000490, "Wrong size on AGBMagazine");
static_assert(offsetof(AGBMagazine, OnCountUpdated) == 0x000448, "Member 'AGBMagazine::OnCountUpdated' has a wrong offset!");
static_assert(offsetof(AGBMagazine, Capacity) == 0x000458, "Member 'AGBMagazine::Capacity' has a wrong offset!");
static_assert(offsetof(AGBMagazine, InitialCount) == 0x00045C, "Member 'AGBMagazine::InitialCount' has a wrong offset!");
static_assert(offsetof(AGBMagazine, Count) == 0x000460, "Member 'AGBMagazine::Count' has a wrong offset!");
static_assert(offsetof(AGBMagazine, BulletId) == 0x000464, "Member 'AGBMagazine::BulletId' has a wrong offset!");
static_assert(offsetof(AGBMagazine, BulletProjectileClass) == 0x000478, "Member 'AGBMagazine::BulletProjectileClass' has a wrong offset!");
static_assert(offsetof(AGBMagazine, TracerFrequency) == 0x000480, "Member 'AGBMagazine::TracerFrequency' has a wrong offset!");
static_assert(offsetof(AGBMagazine, TracerColourIndex) == 0x000484, "Member 'AGBMagazine::TracerColourIndex' has a wrong offset!");
static_assert(offsetof(AGBMagazine, StartTracerCount) == 0x000488, "Member 'AGBMagazine::StartTracerCount' has a wrong offset!");

// Class GroundBranch.GBMinimap
// 0x0010 (0x0230 - 0x0220)
class AGBMinimap : public AActor
{
public:
	TArray<class FName>                           ApplicableMissionVariantNames;                     // 0x0220(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	TArray<class FName> GetApplicableMissionVariantNames() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBMinimap">();
	}
	static class AGBMinimap* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBMinimap>();
	}
};
static_assert(alignof(AGBMinimap) == 0x000008, "Wrong alignment on AGBMinimap");
static_assert(sizeof(AGBMinimap) == 0x000230, "Wrong size on AGBMinimap");
static_assert(offsetof(AGBMinimap, ApplicableMissionVariantNames) == 0x000220, "Member 'AGBMinimap::ApplicableMissionVariantNames' has a wrong offset!");

// Class GroundBranch.GBMissionData
// 0x00F0 (0x0130 - 0x0040)
class UGBMissionData final : public UHFSave
{
public:
	class FString                                 MapAssetPackageName;                               // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VariantName;                                       // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tags;                                              // 0x0060(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Version;                                           // 0x0070(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ScriptName;                                        // 0x0078(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ScreenshotNames;                                   // 0x0088(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Author;                                            // 0x0098(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OptimalPlayerCount;                                // 0x00A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGBBotRosterInfo>               BotRoster;                                         // 0x00B0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   HotspotCodename;                                   // 0x00C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MissionSequenceNumber;                             // 0x00C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGBMissionImage>                MissionImageList;                                  // 0x00D0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGBMapMarker>                   MapMarkerList;                                     // 0x00E0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   FactionName;                                       // 0x00F0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BedtimeStartHour;                                  // 0x00F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BedtimeEndHour;                                    // 0x00FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseStandardHourForBedtimes;                       // 0x0100(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CampaignTimeDate;                                  // 0x0108(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CampaignTCount;                                    // 0x0118(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGBAILoadoutInfo>               AILoadouts;                                        // 0x0120(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class FString GetCampaignHotspotBriefingToken(const class FName InHotspotCodename);
	static class FString GetCampaignMissionBriefingToken(const class FName InHotspotCodename, const int32 InMissionSequenceNumber, const class FString& BriefingField);
	static class FString GetCampaignMissionNameToken(const class FName InHotspotCodename, const int32 InMissionSequenceNumber);
	static class FString GetCampaignMissionTypeToken(const class FName InHotspotCodename, const int32 InMissionSequenceNumber);
	static class FString GetCampaignObjectiveNameToken(const class FName InHotspotCodename, const int32 InMissionSequenceNumber, const class FString& InMissionTitle);
	static class FString GetMissionSaveAsFilename(const class FName InHotspotCodename, const int32 InMissionSequenceNumber, const class FString& InVariantName, const class FString& InScriptName);
	static struct FGBObjectiveData GetObjectiveDataFromMissionFile(class UObject* WorldContextObject, const class FString& MissionFileName, const bool bIncludeHiddenObjectives);

	bool AddAILoadout(const class UObject* WorldContextObject, const class FString& LoadoutFileName);
	void ClearAILoadouts();
	void ClearBotRoster();
	class AGBKitInfo* CreateLoadoutInfo(const class UObject* WorldContextObject, const bool bIsEditing, const class FString& LoadoutFileName);
	TArray<class FString> GetBotDefs(uint8 TeamId);
	void SetBotDefs(uint8 TeamId, const TArray<class FString>& NewDefs);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBMissionData">();
	}
	static class UGBMissionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBMissionData>();
	}
};
static_assert(alignof(UGBMissionData) == 0x000008, "Wrong alignment on UGBMissionData");
static_assert(sizeof(UGBMissionData) == 0x000130, "Wrong size on UGBMissionData");
static_assert(offsetof(UGBMissionData, MapAssetPackageName) == 0x000040, "Member 'UGBMissionData::MapAssetPackageName' has a wrong offset!");
static_assert(offsetof(UGBMissionData, VariantName) == 0x000050, "Member 'UGBMissionData::VariantName' has a wrong offset!");
static_assert(offsetof(UGBMissionData, Tags) == 0x000060, "Member 'UGBMissionData::Tags' has a wrong offset!");
static_assert(offsetof(UGBMissionData, Version) == 0x000070, "Member 'UGBMissionData::Version' has a wrong offset!");
static_assert(offsetof(UGBMissionData, ScriptName) == 0x000078, "Member 'UGBMissionData::ScriptName' has a wrong offset!");
static_assert(offsetof(UGBMissionData, ScreenshotNames) == 0x000088, "Member 'UGBMissionData::ScreenshotNames' has a wrong offset!");
static_assert(offsetof(UGBMissionData, Author) == 0x000098, "Member 'UGBMissionData::Author' has a wrong offset!");
static_assert(offsetof(UGBMissionData, OptimalPlayerCount) == 0x0000A8, "Member 'UGBMissionData::OptimalPlayerCount' has a wrong offset!");
static_assert(offsetof(UGBMissionData, BotRoster) == 0x0000B0, "Member 'UGBMissionData::BotRoster' has a wrong offset!");
static_assert(offsetof(UGBMissionData, HotspotCodename) == 0x0000C0, "Member 'UGBMissionData::HotspotCodename' has a wrong offset!");
static_assert(offsetof(UGBMissionData, MissionSequenceNumber) == 0x0000C8, "Member 'UGBMissionData::MissionSequenceNumber' has a wrong offset!");
static_assert(offsetof(UGBMissionData, MissionImageList) == 0x0000D0, "Member 'UGBMissionData::MissionImageList' has a wrong offset!");
static_assert(offsetof(UGBMissionData, MapMarkerList) == 0x0000E0, "Member 'UGBMissionData::MapMarkerList' has a wrong offset!");
static_assert(offsetof(UGBMissionData, FactionName) == 0x0000F0, "Member 'UGBMissionData::FactionName' has a wrong offset!");
static_assert(offsetof(UGBMissionData, BedtimeStartHour) == 0x0000F8, "Member 'UGBMissionData::BedtimeStartHour' has a wrong offset!");
static_assert(offsetof(UGBMissionData, BedtimeEndHour) == 0x0000FC, "Member 'UGBMissionData::BedtimeEndHour' has a wrong offset!");
static_assert(offsetof(UGBMissionData, bUseStandardHourForBedtimes) == 0x000100, "Member 'UGBMissionData::bUseStandardHourForBedtimes' has a wrong offset!");
static_assert(offsetof(UGBMissionData, CampaignTimeDate) == 0x000108, "Member 'UGBMissionData::CampaignTimeDate' has a wrong offset!");
static_assert(offsetof(UGBMissionData, CampaignTCount) == 0x000118, "Member 'UGBMissionData::CampaignTCount' has a wrong offset!");
static_assert(offsetof(UGBMissionData, AILoadouts) == 0x000120, "Member 'UGBMissionData::AILoadouts' has a wrong offset!");

// Class GroundBranch.GBMissionObjective
// 0x01E0 (0x0400 - 0x0220)
class AGBMissionObjective final : public AActor
{
public:
	uint8                                         Pad_220[0x18];                                     // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   MissionTypeComboBoxWidget;                         // 0x0238(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ActorListPickerWidget;                             // 0x0260(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PrerequisiteObjectivePickerWidget;                 // 0x0288(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   BoolWidget;                                        // 0x02B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLuaScriptInfo                         ObjectiveLuaScriptInfo;                            // 0x02D8(0x0080)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 ObjectiveScriptFilename;                           // 0x0358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ObjectiveTitle;                                    // 0x0368(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPrimaryObjective;                               // 0x0378(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHiddenObjective;                                // 0x0379(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37A[0x2];                                      // 0x037A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ListDisplayPriority;                               // 0x037C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGenericBool;                                      // 0x0380(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGenericBool2;                                     // 0x0381(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_382[0x6];                                      // 0x0382(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class AActor>>          LinkedActorList;                                   // 0x0388(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, SaveGame, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class AActor>>          PrerequisiteObjectives;                            // 0x0398(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, SaveGame, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         TeamId;                                            // 0x03A8(0x0001)(Edit, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGBMissionObjectiveStatus                     MissionObjectiveStatus;                            // 0x03A9(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSelected;                                       // 0x03AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsActive;                                         // 0x03AB(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBoundToGameState;                                 // 0x03AC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseBool;                                          // 0x03AD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseBool2;                                         // 0x03AE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AF[0x1];                                      // 0x03AF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BoolDescription;                                   // 0x03B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 BoolDescription2;                                  // 0x03C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseLinkedActorList;                               // 0x03D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSingleLinkedActor;                             // 0x03D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseOnlyMissionActors;                             // 0x03D2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDontLinkToSelf;                                   // 0x03D3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     LinkedActorClass;                                  // 0x03D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 LinkedActorDescription;                            // 0x03E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastObjectiveStatusChangeTime;                     // 0x03F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUInt64                                MissionDataModID;                                  // 0x03F8(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class FString GetObjectiveCompleteGenericToken(const class FName ObjectiveType);
	static class FString GetObjectiveCompleteSpecificToken(const class FName InHotspotCodename, const int32 InMissionSequenceNumber, const class FString& InMissionTitle);
	static class FString GetObjectiveFailedGenericToken(const class FName ObjectiveType);
	static class FString GetObjectiveFailedSpecificToken(const class FName InHotspotCodename, const int32 InMissionSequenceNumber, const class FString& InMissionTitle);
	static class FString GetObjectiveSubObjectiveCompleteGenericToken(const class FName ObjectiveType);
	static class FString GetObjectiveSubObjectiveCompleteSpecificToken(const class FName InHotspotCodename, const int32 InMissionSequenceNumber, const class FString& InMissionTitle);
	static class FString GetObjectiveTimedActionGenericToken(const class FName ObjectiveType);
	static class FString GetObjectiveTimedActionSpecificToken(const class FName InHotspotCodename, const int32 InMissionSequenceNumber, const class FString& InMissionTitle);
	static void GetSortedMissionObjectiveInfoSimple(const TArray<struct FGBCampaignMissionObjectiveInfo>& InAllObjectiveInfoList, const uint8 TeamId_0, TArray<struct FGBCampaignMissionObjectiveInfo>* OutPrimaryList, TArray<struct FGBCampaignMissionObjectiveInfo>* OutSecondaryList);
	static void GetSortedMissionObjectives(const TArray<class AGBMissionObjective*>& InAllObjectivesList, const uint8 TeamId_0, TArray<class AGBMissionObjective*>* OutInactiveList, TArray<class AGBMissionObjective*>* OutActiveList, TArray<class AGBMissionObjective*>* OutPartiallyCompleteList, TArray<class AGBMissionObjective*>* OutFailedList, TArray<class AGBMissionObjective*>* OutCompletedList);
	static void GetSortedMissionObjectivesSimple(const TArray<class AGBMissionObjective*>& InAllObjectivesList, const uint8 TeamId_0, TArray<class AGBMissionObjective*>* OutPrimaryList, TArray<class AGBMissionObjective*>* OutSecondaryList);

	struct FLuaValue GetObjectiveScriptTable();
	void OnObjectiveStatusChanged(class AGBMissionObjective* MissionObjective);
	void OnRep_MissionObjectiveStatus();
	void OnSearchReportedInVolume(class AGBGameTrigger* GameTrigger, class AGBSearchableProp* SearchedActor);
	void ReloadObjectiveScriptData();
	void ResetObjectiveStatus();
	void SetGenericBool(const bool bNewGenericBool);
	void SetGenericBool2(const bool bNewGenericBool2);
	void SetLinkedActorList(const TArray<TSoftObjectPtr<class AActor>>& NewLinkedActorList);
	void SetMissionObjectiveStatus(const EGBMissionObjectiveStatus NewMissionObjectiveStatus);
	void SetObjectiveType(const class FString& NewObjectiveScriptFilename);
	void SetPrerequisiteObjectives(const TArray<TSoftObjectPtr<class AActor>>& NewPrerequisiteObjectives);
	bool WaitingOnPrerequisiteObjectives();

	class FName GetBestMissionStatusUpdateToken() const;
	class FString GetBoolDescription() const;
	class FString GetBoolDescription2() const;
	bool GetDontLinkToSelf() const;
	bool GetGenericBool() const;
	bool GetGenericBool2() const;
	bool GetIsHiddenObjective() const;
	bool GetIsPrimaryObjective() const;
	TSubclassOf<class AActor> GetLinkedActorClass() const;
	class FString GetLinkedActorDescription() const;
	TArray<TSoftObjectPtr<class AActor>> GetLinkedActorList() const;
	int32 GetListDisplayPriority() const;
	EGBMissionObjectiveStatus GetMissionObjectiveStatus() const;
	class FString GetObjectiveScriptFilename() const;
	class FString GetObjectiveTitle() const;
	class FName GetObjectiveType() const;
	TArray<TSoftObjectPtr<class AActor>> GetPrerequisiteObjectives() const;
	bool GetUseBool() const;
	bool GetUseBool2() const;
	bool GetUseLinkedActorList() const;
	bool GetUseOnlyMissionActors() const;
	bool GetUseSingleLinkedActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBMissionObjective">();
	}
	static class AGBMissionObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBMissionObjective>();
	}
};
static_assert(alignof(AGBMissionObjective) == 0x000008, "Wrong alignment on AGBMissionObjective");
static_assert(sizeof(AGBMissionObjective) == 0x000400, "Wrong size on AGBMissionObjective");
static_assert(offsetof(AGBMissionObjective, MissionTypeComboBoxWidget) == 0x000238, "Member 'AGBMissionObjective::MissionTypeComboBoxWidget' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, ActorListPickerWidget) == 0x000260, "Member 'AGBMissionObjective::ActorListPickerWidget' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, PrerequisiteObjectivePickerWidget) == 0x000288, "Member 'AGBMissionObjective::PrerequisiteObjectivePickerWidget' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, BoolWidget) == 0x0002B0, "Member 'AGBMissionObjective::BoolWidget' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, ObjectiveLuaScriptInfo) == 0x0002D8, "Member 'AGBMissionObjective::ObjectiveLuaScriptInfo' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, ObjectiveScriptFilename) == 0x000358, "Member 'AGBMissionObjective::ObjectiveScriptFilename' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, ObjectiveTitle) == 0x000368, "Member 'AGBMissionObjective::ObjectiveTitle' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, bIsPrimaryObjective) == 0x000378, "Member 'AGBMissionObjective::bIsPrimaryObjective' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, bIsHiddenObjective) == 0x000379, "Member 'AGBMissionObjective::bIsHiddenObjective' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, ListDisplayPriority) == 0x00037C, "Member 'AGBMissionObjective::ListDisplayPriority' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, bGenericBool) == 0x000380, "Member 'AGBMissionObjective::bGenericBool' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, bGenericBool2) == 0x000381, "Member 'AGBMissionObjective::bGenericBool2' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, LinkedActorList) == 0x000388, "Member 'AGBMissionObjective::LinkedActorList' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, PrerequisiteObjectives) == 0x000398, "Member 'AGBMissionObjective::PrerequisiteObjectives' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, TeamId) == 0x0003A8, "Member 'AGBMissionObjective::TeamId' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, MissionObjectiveStatus) == 0x0003A9, "Member 'AGBMissionObjective::MissionObjectiveStatus' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, bIsSelected) == 0x0003AA, "Member 'AGBMissionObjective::bIsSelected' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, bIsActive) == 0x0003AB, "Member 'AGBMissionObjective::bIsActive' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, bBoundToGameState) == 0x0003AC, "Member 'AGBMissionObjective::bBoundToGameState' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, bUseBool) == 0x0003AD, "Member 'AGBMissionObjective::bUseBool' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, bUseBool2) == 0x0003AE, "Member 'AGBMissionObjective::bUseBool2' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, BoolDescription) == 0x0003B0, "Member 'AGBMissionObjective::BoolDescription' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, BoolDescription2) == 0x0003C0, "Member 'AGBMissionObjective::BoolDescription2' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, bUseLinkedActorList) == 0x0003D0, "Member 'AGBMissionObjective::bUseLinkedActorList' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, bUseSingleLinkedActor) == 0x0003D1, "Member 'AGBMissionObjective::bUseSingleLinkedActor' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, bUseOnlyMissionActors) == 0x0003D2, "Member 'AGBMissionObjective::bUseOnlyMissionActors' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, bDontLinkToSelf) == 0x0003D3, "Member 'AGBMissionObjective::bDontLinkToSelf' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, LinkedActorClass) == 0x0003D8, "Member 'AGBMissionObjective::LinkedActorClass' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, LinkedActorDescription) == 0x0003E0, "Member 'AGBMissionObjective::LinkedActorDescription' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, LastObjectiveStatusChangeTime) == 0x0003F0, "Member 'AGBMissionObjective::LastObjectiveStatusChangeTime' has a wrong offset!");
static_assert(offsetof(AGBMissionObjective, MissionDataModID) == 0x0003F8, "Member 'AGBMissionObjective::MissionDataModID' has a wrong offset!");

// Class GroundBranch.GBNavArea_UseActorNavLink
// 0x0000 (0x0048 - 0x0048)
class UGBNavArea_UseActorNavLink final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBNavArea_UseActorNavLink">();
	}
	static class UGBNavArea_UseActorNavLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBNavArea_UseActorNavLink>();
	}
};
static_assert(alignof(UGBNavArea_UseActorNavLink) == 0x000008, "Wrong alignment on UGBNavArea_UseActorNavLink");
static_assert(sizeof(UGBNavArea_UseActorNavLink) == 0x000048, "Wrong size on UGBNavArea_UseActorNavLink");

// Class GroundBranch.GBNavBlocker
// 0x0010 (0x0258 - 0x0248)
class AGBNavBlocker : public AGBMissionVolume
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsActive;                                         // 0x0250(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActiveStateChangedEvent(const bool bNewActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBNavBlocker">();
	}
	static class AGBNavBlocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBNavBlocker>();
	}
};
static_assert(alignof(AGBNavBlocker) == 0x000008, "Wrong alignment on AGBNavBlocker");
static_assert(sizeof(AGBNavBlocker) == 0x000258, "Wrong size on AGBNavBlocker");
static_assert(offsetof(AGBNavBlocker, bIsActive) == 0x000250, "Member 'AGBNavBlocker::bIsActive' has a wrong offset!");

// Class GroundBranch.GBNavLinkProxy_Ladder
// 0x0010 (0x0280 - 0x0270)
class AGBNavLinkProxy_Ladder final : public AGBNavLinkProxy
{
public:
	class AActor*                                 LadderRef;                                         // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGBLadderComponent*                     LadderComponentRef;                                // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class AActor* GetLadderRef() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBNavLinkProxy_Ladder">();
	}
	static class AGBNavLinkProxy_Ladder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBNavLinkProxy_Ladder>();
	}
};
static_assert(alignof(AGBNavLinkProxy_Ladder) == 0x000008, "Wrong alignment on AGBNavLinkProxy_Ladder");
static_assert(sizeof(AGBNavLinkProxy_Ladder) == 0x000280, "Wrong size on AGBNavLinkProxy_Ladder");
static_assert(offsetof(AGBNavLinkProxy_Ladder, LadderRef) == 0x000270, "Member 'AGBNavLinkProxy_Ladder::LadderRef' has a wrong offset!");
static_assert(offsetof(AGBNavLinkProxy_Ladder, LadderComponentRef) == 0x000278, "Member 'AGBNavLinkProxy_Ladder::LadderComponentRef' has a wrong offset!");

// Class GroundBranch.GBNavLinkUseActorComponent
// 0x0090 (0x0170 - 0x00E0)
class UGBNavLinkUseActorComponent final : public UNavRelevantComponent
{
public:
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNavigationLink                        Link;                                              // 0x00E8(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UGBNavArea_UseActorNavLink> LeftAreaClass;                                     // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LeftAreaExtent;                                    // 0x0138(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LeftAreaOffset;                                    // 0x0144(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGBNavArea_UseActorNavLink> RightAreaClass;                                    // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RightAreaExtent;                                   // 0x0158(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RightAreaOffset;                                   // 0x0164(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBNavLinkUseActorComponent">();
	}
	static class UGBNavLinkUseActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBNavLinkUseActorComponent>();
	}
};
static_assert(alignof(UGBNavLinkUseActorComponent) == 0x000008, "Wrong alignment on UGBNavLinkUseActorComponent");
static_assert(sizeof(UGBNavLinkUseActorComponent) == 0x000170, "Wrong size on UGBNavLinkUseActorComponent");
static_assert(offsetof(UGBNavLinkUseActorComponent, Link) == 0x0000E8, "Member 'UGBNavLinkUseActorComponent::Link' has a wrong offset!");
static_assert(offsetof(UGBNavLinkUseActorComponent, LeftAreaClass) == 0x000130, "Member 'UGBNavLinkUseActorComponent::LeftAreaClass' has a wrong offset!");
static_assert(offsetof(UGBNavLinkUseActorComponent, LeftAreaExtent) == 0x000138, "Member 'UGBNavLinkUseActorComponent::LeftAreaExtent' has a wrong offset!");
static_assert(offsetof(UGBNavLinkUseActorComponent, LeftAreaOffset) == 0x000144, "Member 'UGBNavLinkUseActorComponent::LeftAreaOffset' has a wrong offset!");
static_assert(offsetof(UGBNavLinkUseActorComponent, RightAreaClass) == 0x000150, "Member 'UGBNavLinkUseActorComponent::RightAreaClass' has a wrong offset!");
static_assert(offsetof(UGBNavLinkUseActorComponent, RightAreaExtent) == 0x000158, "Member 'UGBNavLinkUseActorComponent::RightAreaExtent' has a wrong offset!");
static_assert(offsetof(UGBNavLinkUseActorComponent, RightAreaOffset) == 0x000164, "Member 'UGBNavLinkUseActorComponent::RightAreaOffset' has a wrong offset!");

// Class GroundBranch.GBOperatorDataAsset
// 0x00A8 (0x00D8 - 0x0030)
class UGBOperatorDataAsset final : public UPrimaryDataAsset
{
public:
	bool                                          bGeneric;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RecruitmentOrder;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFemale;                                           // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FirstName;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Surname;                                           // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CodeName;                                          // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Biography;                                         // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 LoadoutFileName;                                   // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPoseAsset>              RosterPose;                                        // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGBOperatorSpecialisation                     Specialisation;                                    // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Birthday;                                          // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class FName MakeUniqueId(const class FString& FirstName_0, const class FString& Surname_0);

	struct FGBOperatorDetails GetOperatorDetails();

	class FString GetUniqueCodename() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBOperatorDataAsset">();
	}
	static class UGBOperatorDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBOperatorDataAsset>();
	}
};
static_assert(alignof(UGBOperatorDataAsset) == 0x000008, "Wrong alignment on UGBOperatorDataAsset");
static_assert(sizeof(UGBOperatorDataAsset) == 0x0000D8, "Wrong size on UGBOperatorDataAsset");
static_assert(offsetof(UGBOperatorDataAsset, bGeneric) == 0x000030, "Member 'UGBOperatorDataAsset::bGeneric' has a wrong offset!");
static_assert(offsetof(UGBOperatorDataAsset, RecruitmentOrder) == 0x000034, "Member 'UGBOperatorDataAsset::RecruitmentOrder' has a wrong offset!");
static_assert(offsetof(UGBOperatorDataAsset, bFemale) == 0x000038, "Member 'UGBOperatorDataAsset::bFemale' has a wrong offset!");
static_assert(offsetof(UGBOperatorDataAsset, FirstName) == 0x000040, "Member 'UGBOperatorDataAsset::FirstName' has a wrong offset!");
static_assert(offsetof(UGBOperatorDataAsset, Surname) == 0x000050, "Member 'UGBOperatorDataAsset::Surname' has a wrong offset!");
static_assert(offsetof(UGBOperatorDataAsset, CodeName) == 0x000060, "Member 'UGBOperatorDataAsset::CodeName' has a wrong offset!");
static_assert(offsetof(UGBOperatorDataAsset, Biography) == 0x000078, "Member 'UGBOperatorDataAsset::Biography' has a wrong offset!");
static_assert(offsetof(UGBOperatorDataAsset, LoadoutFileName) == 0x000090, "Member 'UGBOperatorDataAsset::LoadoutFileName' has a wrong offset!");
static_assert(offsetof(UGBOperatorDataAsset, RosterPose) == 0x0000A0, "Member 'UGBOperatorDataAsset::RosterPose' has a wrong offset!");
static_assert(offsetof(UGBOperatorDataAsset, Specialisation) == 0x0000C8, "Member 'UGBOperatorDataAsset::Specialisation' has a wrong offset!");
static_assert(offsetof(UGBOperatorDataAsset, Birthday) == 0x0000D0, "Member 'UGBOperatorDataAsset::Birthday' has a wrong offset!");

// Class GroundBranch.GBPatch
// 0x0050 (0x0498 - 0x0448)
class AGBPatch : public AGBInvItem
{
public:
	uint8                                         Pad_448[0x10];                                     // 0x0448(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGBPatchInfo                           PatchInfo;                                         // 0x0458(0x0040)(Net, Protected, NativeAccessSpecifierProtected)

public:
	void ApplyPatch();
	void OnLoadPatchTintsComplete();
	void OnPlayerStateDelegate(class AGBPlayerState* GBPlayerState);
	void OnRep_PatchInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPatch">();
	}
	static class AGBPatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBPatch>();
	}
};
static_assert(alignof(AGBPatch) == 0x000008, "Wrong alignment on AGBPatch");
static_assert(sizeof(AGBPatch) == 0x000498, "Wrong size on AGBPatch");
static_assert(offsetof(AGBPatch, PatchInfo) == 0x000458, "Member 'AGBPatch::PatchInfo' has a wrong offset!");

// Class GroundBranch.GBPatchGeneratorWidget
// 0x0000 (0x0260 - 0x0260)
class UGBPatchGeneratorWidget final : public UUserWidget
{
public:
	void SetCallSignEvent(const class FString& NewCallSign);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPatchGeneratorWidget">();
	}
	static class UGBPatchGeneratorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBPatchGeneratorWidget>();
	}
};
static_assert(alignof(UGBPatchGeneratorWidget) == 0x000008, "Wrong alignment on UGBPatchGeneratorWidget");
static_assert(sizeof(UGBPatchGeneratorWidget) == 0x000260, "Wrong size on UGBPatchGeneratorWidget");

// Class GroundBranch.GBPlatform
// 0x0088 (0x04D0 - 0x0448)
class AGBPlatform : public AGBInvItem
{
public:
	class USkeletalMeshComponent*                 PlatformMeshComponent;                             // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 WoundParameterName;                                // 0x0450(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_460[0x8];                                      // 0x0460(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           WoundBoneList;                                     // 0x0468(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DumpPouchClass;                                    // 0x0478(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   RadioPouchClass;                                   // 0x04A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RadioSocket;                                       // 0x04C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTakeHit(const class FName& RefBoneName, const struct FVector& RefPosPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPlatform">();
	}
	static class AGBPlatform* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBPlatform>();
	}
};
static_assert(alignof(AGBPlatform) == 0x000008, "Wrong alignment on AGBPlatform");
static_assert(sizeof(AGBPlatform) == 0x0004D0, "Wrong size on AGBPlatform");
static_assert(offsetof(AGBPlatform, PlatformMeshComponent) == 0x000448, "Member 'AGBPlatform::PlatformMeshComponent' has a wrong offset!");
static_assert(offsetof(AGBPlatform, WoundParameterName) == 0x000450, "Member 'AGBPlatform::WoundParameterName' has a wrong offset!");
static_assert(offsetof(AGBPlatform, WoundBoneList) == 0x000468, "Member 'AGBPlatform::WoundBoneList' has a wrong offset!");
static_assert(offsetof(AGBPlatform, DumpPouchClass) == 0x000478, "Member 'AGBPlatform::DumpPouchClass' has a wrong offset!");
static_assert(offsetof(AGBPlatform, RadioPouchClass) == 0x0004A0, "Member 'AGBPlatform::RadioPouchClass' has a wrong offset!");
static_assert(offsetof(AGBPlatform, RadioSocket) == 0x0004C8, "Member 'AGBPlatform::RadioSocket' has a wrong offset!");

// Class GroundBranch.GBPlayerCameraManager
// 0x00A0 (0x28B0 - 0x2810)
class AGBPlayerCameraManager : public APlayerCameraManager
{
public:
	float                                         ShoulderCamDistance;                               // 0x2810(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ShoulderCamOffset;                                 // 0x2814(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName OldCameraStyle, class FName NewCameraStyle)> OnCameraStyleChanged; // 0x2820(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2830[0x30];                                    // 0x2830(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USpringArmComponent*                    CameraBoom;                                        // 0x2860(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        SelfieCam;                                         // 0x2868(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGBCameraModifier>          HeadCamCameraModifierClass;                        // 0x2870(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraClippingRadius;                              // 0x2878(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_287C[0x4];                                     // 0x287C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CameraClippingBones;                               // 0x2880(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<EObjectTypeQuery>                      TraceObjectTypes;                                  // 0x2890(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<EPhysicalSurface>                      SurfaceTypesToIgnore;                              // 0x28A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	class FName GetCameraStyle() const;
	float GetViewPitchMax() const;
	float GetViewPitchMin() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPlayerCameraManager">();
	}
	static class AGBPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBPlayerCameraManager>();
	}
};
static_assert(alignof(AGBPlayerCameraManager) == 0x000010, "Wrong alignment on AGBPlayerCameraManager");
static_assert(sizeof(AGBPlayerCameraManager) == 0x0028B0, "Wrong size on AGBPlayerCameraManager");
static_assert(offsetof(AGBPlayerCameraManager, ShoulderCamDistance) == 0x002810, "Member 'AGBPlayerCameraManager::ShoulderCamDistance' has a wrong offset!");
static_assert(offsetof(AGBPlayerCameraManager, ShoulderCamOffset) == 0x002814, "Member 'AGBPlayerCameraManager::ShoulderCamOffset' has a wrong offset!");
static_assert(offsetof(AGBPlayerCameraManager, OnCameraStyleChanged) == 0x002820, "Member 'AGBPlayerCameraManager::OnCameraStyleChanged' has a wrong offset!");
static_assert(offsetof(AGBPlayerCameraManager, CameraBoom) == 0x002860, "Member 'AGBPlayerCameraManager::CameraBoom' has a wrong offset!");
static_assert(offsetof(AGBPlayerCameraManager, SelfieCam) == 0x002868, "Member 'AGBPlayerCameraManager::SelfieCam' has a wrong offset!");
static_assert(offsetof(AGBPlayerCameraManager, HeadCamCameraModifierClass) == 0x002870, "Member 'AGBPlayerCameraManager::HeadCamCameraModifierClass' has a wrong offset!");
static_assert(offsetof(AGBPlayerCameraManager, CameraClippingRadius) == 0x002878, "Member 'AGBPlayerCameraManager::CameraClippingRadius' has a wrong offset!");
static_assert(offsetof(AGBPlayerCameraManager, CameraClippingBones) == 0x002880, "Member 'AGBPlayerCameraManager::CameraClippingBones' has a wrong offset!");
static_assert(offsetof(AGBPlayerCameraManager, TraceObjectTypes) == 0x002890, "Member 'AGBPlayerCameraManager::TraceObjectTypes' has a wrong offset!");
static_assert(offsetof(AGBPlayerCameraManager, SurfaceTypesToIgnore) == 0x0028A0, "Member 'AGBPlayerCameraManager::SurfaceTypesToIgnore' has a wrong offset!");

// Class GroundBranch.GBPlayerCommandComponent
// 0x0068 (0x0118 - 0x00B0)
class UGBPlayerCommandComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(EGBAICommands Command)> OnCommandSelected;                         // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EAIRulesEngage NewROE)> OnROEChanged;                              // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EAIGoCodes NewGoCode)> OnGoCodeIssued;                             // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FAIMoveCommand& NewMoveCommand)> OnMoveCommandIssued; // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AGBSquad*                               Squad;                                             // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x20];                                      // 0x00F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FAIMoveCommand AddWaypoint(const struct FVector& Location, EAIGoCodes GoCode);
	void ChangeROE(EAIRulesEngage NewROE);
	void DistributeCommand(EGBAICommands Command, const struct FVector& OptLocation, class AActor* OptActor);
	void IssueGoCommand(EAIGoCodes NewGoCode);
	void SetWaypoint(const struct FAIMoveCommand& MoveCommand);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPlayerCommandComponent">();
	}
	static class UGBPlayerCommandComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBPlayerCommandComponent>();
	}
};
static_assert(alignof(UGBPlayerCommandComponent) == 0x000008, "Wrong alignment on UGBPlayerCommandComponent");
static_assert(sizeof(UGBPlayerCommandComponent) == 0x000118, "Wrong size on UGBPlayerCommandComponent");
static_assert(offsetof(UGBPlayerCommandComponent, OnCommandSelected) == 0x0000B0, "Member 'UGBPlayerCommandComponent::OnCommandSelected' has a wrong offset!");
static_assert(offsetof(UGBPlayerCommandComponent, OnROEChanged) == 0x0000C0, "Member 'UGBPlayerCommandComponent::OnROEChanged' has a wrong offset!");
static_assert(offsetof(UGBPlayerCommandComponent, OnGoCodeIssued) == 0x0000D0, "Member 'UGBPlayerCommandComponent::OnGoCodeIssued' has a wrong offset!");
static_assert(offsetof(UGBPlayerCommandComponent, OnMoveCommandIssued) == 0x0000E0, "Member 'UGBPlayerCommandComponent::OnMoveCommandIssued' has a wrong offset!");
static_assert(offsetof(UGBPlayerCommandComponent, Squad) == 0x0000F0, "Member 'UGBPlayerCommandComponent::Squad' has a wrong offset!");

// Class GroundBranch.GBPlayerInput
// 0x0070 (0x0418 - 0x03A8)
class UGBPlayerInput final : public UPlayerInput
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInputExecKeyMapping>           ExecMappings;                                      // 0x03B0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint32                                        Version;                                           // 0x03C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x54];                                     // 0x03C4(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyPlayerSettings(class UGBPlayerSettings* PlayerSettings);
	void ValidateInputSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPlayerInput">();
	}
	static class UGBPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBPlayerInput>();
	}
};
static_assert(alignof(UGBPlayerInput) == 0x000008, "Wrong alignment on UGBPlayerInput");
static_assert(sizeof(UGBPlayerInput) == 0x000418, "Wrong size on UGBPlayerInput");
static_assert(offsetof(UGBPlayerInput, ExecMappings) == 0x0003B0, "Member 'UGBPlayerInput::ExecMappings' has a wrong offset!");
static_assert(offsetof(UGBPlayerInput, Version) == 0x0003C0, "Member 'UGBPlayerInput::Version' has a wrong offset!");

// Class GroundBranch.GBPlayerNightVisionStatus
// 0x0030 (0x0250 - 0x0220)
class AGBPlayerNightVisionStatus final : public AActor
{
public:
	class AGBPlayerController*                    GBPlayerController;                                // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasNVGEnabledTag;                                 // 0x0238(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bEnabled)> OnPlayerNightVisionStatusChanged;                  // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Init();
	void OnCameraStyleChanged(class FName OldCameraStyle, class FName NewCameraStyle);
	void OnSpectatorNightVisionModeChanged(class AGBPlayerController* PlayerController);
	void OnViewTargetChanged(class AGBPlayerController* PlayerController);

	bool GetPlayerNightVisionStatus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPlayerNightVisionStatus">();
	}
	static class AGBPlayerNightVisionStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBPlayerNightVisionStatus>();
	}
};
static_assert(alignof(AGBPlayerNightVisionStatus) == 0x000008, "Wrong alignment on AGBPlayerNightVisionStatus");
static_assert(sizeof(AGBPlayerNightVisionStatus) == 0x000250, "Wrong size on AGBPlayerNightVisionStatus");
static_assert(offsetof(AGBPlayerNightVisionStatus, GBPlayerController) == 0x000220, "Member 'AGBPlayerNightVisionStatus::GBPlayerController' has a wrong offset!");
static_assert(offsetof(AGBPlayerNightVisionStatus, bHasNVGEnabledTag) == 0x000238, "Member 'AGBPlayerNightVisionStatus::bHasNVGEnabledTag' has a wrong offset!");
static_assert(offsetof(AGBPlayerNightVisionStatus, OnPlayerNightVisionStatusChanged) == 0x000240, "Member 'AGBPlayerNightVisionStatus::OnPlayerNightVisionStatusChanged' has a wrong offset!");

// Class GroundBranch.GBPortalSystemManager
// 0x0000 (0x0338 - 0x0338)
class AGBPortalSystemManager final : public APortalSystemManager
{
public:
	void RemoveLight(class ULightComponent* LightComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBPortalSystemManager">();
	}
	static class AGBPortalSystemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBPortalSystemManager>();
	}
};
static_assert(alignof(AGBPortalSystemManager) == 0x000008, "Wrong alignment on AGBPortalSystemManager");
static_assert(sizeof(AGBPortalSystemManager) == 0x000338, "Wrong size on AGBPortalSystemManager");

// Class GroundBranch.GBRadialMenuElementWidget
// 0x0028 (0x0288 - 0x0260)
class UGBRadialMenuElementWidget : public UUserWidget
{
public:
	class UImage*                                 ElementIcon;                                       // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayText;                                       // 0x0268(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         ElementIndex;                                      // 0x0280(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBRadialMenuElementWidget">();
	}
	static class UGBRadialMenuElementWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBRadialMenuElementWidget>();
	}
};
static_assert(alignof(UGBRadialMenuElementWidget) == 0x000008, "Wrong alignment on UGBRadialMenuElementWidget");
static_assert(sizeof(UGBRadialMenuElementWidget) == 0x000288, "Wrong size on UGBRadialMenuElementWidget");
static_assert(offsetof(UGBRadialMenuElementWidget, ElementIcon) == 0x000260, "Member 'UGBRadialMenuElementWidget::ElementIcon' has a wrong offset!");
static_assert(offsetof(UGBRadialMenuElementWidget, DisplayText) == 0x000268, "Member 'UGBRadialMenuElementWidget::DisplayText' has a wrong offset!");
static_assert(offsetof(UGBRadialMenuElementWidget, ElementIndex) == 0x000280, "Member 'UGBRadialMenuElementWidget::ElementIndex' has a wrong offset!");

// Class GroundBranch.GBRailAttachment
// 0x0030 (0x0478 - 0x0448)
class AGBRailAttachment : public AGBInvItem
{
public:
	struct FRepRailAttachment                     RailAttachmentReplication;                         // 0x0448(0x0018)(Net, Transient, RepNotify, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UGBRailMountComponent*                  RootMountPoint;                                    // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RecoilSlot;                                        // 0x0468(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinRecoilSlotsRequired;                            // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxRecoilSlotsRequired;                            // 0x0470(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class AGBRailAttachment*> GetAttachmentOverlaps(bool bForceCollision);
	bool GetBackOffset(struct FVector* OutBackOffset);
	ERailMountValidation GetRailMountValidation();
	TArray<struct FVector> GetValidMountPointOffsets(class AGBInvItem* BaseItem);
	void GetValidRailOffsetsFor(class AGBFirearm* ParentFirearm, TArray<struct FValidatedRecoilSlots>* OutValidatedRecoilSlots);
	bool IsCompatibleWithRail(class UGBRailComponent* RailComp);
	bool IsNotTooFarBack(class AGBFirearm* ParentFirearm, const struct FVector& WorldLocation);
	bool IsNotTooFarForward(class AGBFirearm* ParentFirearm, const struct FVector& WorldLocation);
	void OnRep_RailAttachmentReplication();
	void SetRecoilSlot(int32 NewRecoilSlot);
	bool StackCheck(const class UGBRailComponent* RailComp);

	TArray<class UGBRailMountComponent*> GetMountPoints() const;
	int32 GetRecoilSlot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBRailAttachment">();
	}
	static class AGBRailAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBRailAttachment>();
	}
};
static_assert(alignof(AGBRailAttachment) == 0x000008, "Wrong alignment on AGBRailAttachment");
static_assert(sizeof(AGBRailAttachment) == 0x000478, "Wrong size on AGBRailAttachment");
static_assert(offsetof(AGBRailAttachment, RailAttachmentReplication) == 0x000448, "Member 'AGBRailAttachment::RailAttachmentReplication' has a wrong offset!");
static_assert(offsetof(AGBRailAttachment, RootMountPoint) == 0x000460, "Member 'AGBRailAttachment::RootMountPoint' has a wrong offset!");
static_assert(offsetof(AGBRailAttachment, RecoilSlot) == 0x000468, "Member 'AGBRailAttachment::RecoilSlot' has a wrong offset!");
static_assert(offsetof(AGBRailAttachment, MinRecoilSlotsRequired) == 0x00046C, "Member 'AGBRailAttachment::MinRecoilSlotsRequired' has a wrong offset!");
static_assert(offsetof(AGBRailAttachment, MaxRecoilSlotsRequired) == 0x000470, "Member 'AGBRailAttachment::MaxRecoilSlotsRequired' has a wrong offset!");

// Class GroundBranch.GBRailMountComponent
// 0x0000 (0x0200 - 0x0200)
class UGBRailMountComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBRailMountComponent">();
	}
	static class UGBRailMountComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBRailMountComponent>();
	}
};
static_assert(alignof(UGBRailMountComponent) == 0x000010, "Wrong alignment on UGBRailMountComponent");
static_assert(sizeof(UGBRailMountComponent) == 0x000200, "Wrong size on UGBRailMountComponent");

// Class GroundBranch.GBRestraint
// 0x0130 (0x0578 - 0x0448)
class AGBRestraint final : public AGBInvItem
{
public:
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   LeadHostageInteractionWidget;                      // 0x0450(0x0028)(Edit, BlueprintVisible, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   LeadHostageFinishInteractionWidget;                // 0x0478(0x0028)(Edit, BlueprintVisible, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   RemoveRestraintsInteractionWidget;                 // 0x04A0(0x0028)(Edit, BlueprintVisible, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntimidationRange;                                 // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloseIntimidationRange;                            // 0x04CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GunPointDotProd;                                   // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeadingOffset;                                     // 0x04D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeadingCloseEnough;                                // 0x04D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeadingRotationSpeed;                              // 0x04DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeadingRotationMinVelSpeed;                        // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeadingRotationMaxVelSpeed;                        // 0x04E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistFromHostageToLeader;                        // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoLOSHostageToLeaderTimeout;                       // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGBPlayerState*                         UsingGBPlayerState;                                // 0x04F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasIntimidators;                                  // 0x04F8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F9[0x7];                                      // 0x04F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AGBPlayerState*, float>            Intimidators;                                      // 0x0500(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class AGBPlayerState*                         GBInstigatorPlayerState;                           // 0x0550(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_558[0x20];                                     // 0x0558(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakOffLeadingHostage();
	void ClearLeadHostageInteractionWidget();
	bool HasLineOfSightToHostage(const struct FVector& TraceFrom, const class AActor* IgnoreActor);
	void OnBeginCursorOver(class UPrimitiveComponent* TouchedComponent);
	void OnEndCursorOver(class UPrimitiveComponent* TouchedComponent);
	void OnPlayerInteractionChanged(class AGBPlayerState* GBPlayerState);
	void OnRep_HasIntimidators(bool PreviousValue);
	void OnStatusUpdated();
	void RemoveAllHostageEquipment();
	void SetLeadingRelationship(class AGBPlayerState* LeadingPlayerState, class AGBPlayerState* LedPlayerState);
	void UnsetLeadingRelationship(class AGBPlayerState* LeadingPlayerState, class AGBPlayerState* LedPlayerState);
	void UpdatePlayerInteractionStatus(class AGBPlayerState* PreviousValue);

	class AGBPlayerState* GetUsingGBPlayerState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBRestraint">();
	}
	static class AGBRestraint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBRestraint>();
	}
};
static_assert(alignof(AGBRestraint) == 0x000008, "Wrong alignment on AGBRestraint");
static_assert(sizeof(AGBRestraint) == 0x000578, "Wrong size on AGBRestraint");
static_assert(offsetof(AGBRestraint, LeadHostageInteractionWidget) == 0x000450, "Member 'AGBRestraint::LeadHostageInteractionWidget' has a wrong offset!");
static_assert(offsetof(AGBRestraint, LeadHostageFinishInteractionWidget) == 0x000478, "Member 'AGBRestraint::LeadHostageFinishInteractionWidget' has a wrong offset!");
static_assert(offsetof(AGBRestraint, RemoveRestraintsInteractionWidget) == 0x0004A0, "Member 'AGBRestraint::RemoveRestraintsInteractionWidget' has a wrong offset!");
static_assert(offsetof(AGBRestraint, IntimidationRange) == 0x0004C8, "Member 'AGBRestraint::IntimidationRange' has a wrong offset!");
static_assert(offsetof(AGBRestraint, CloseIntimidationRange) == 0x0004CC, "Member 'AGBRestraint::CloseIntimidationRange' has a wrong offset!");
static_assert(offsetof(AGBRestraint, GunPointDotProd) == 0x0004D0, "Member 'AGBRestraint::GunPointDotProd' has a wrong offset!");
static_assert(offsetof(AGBRestraint, LeadingOffset) == 0x0004D4, "Member 'AGBRestraint::LeadingOffset' has a wrong offset!");
static_assert(offsetof(AGBRestraint, LeadingCloseEnough) == 0x0004D8, "Member 'AGBRestraint::LeadingCloseEnough' has a wrong offset!");
static_assert(offsetof(AGBRestraint, LeadingRotationSpeed) == 0x0004DC, "Member 'AGBRestraint::LeadingRotationSpeed' has a wrong offset!");
static_assert(offsetof(AGBRestraint, LeadingRotationMinVelSpeed) == 0x0004E0, "Member 'AGBRestraint::LeadingRotationMinVelSpeed' has a wrong offset!");
static_assert(offsetof(AGBRestraint, LeadingRotationMaxVelSpeed) == 0x0004E4, "Member 'AGBRestraint::LeadingRotationMaxVelSpeed' has a wrong offset!");
static_assert(offsetof(AGBRestraint, MaxDistFromHostageToLeader) == 0x0004E8, "Member 'AGBRestraint::MaxDistFromHostageToLeader' has a wrong offset!");
static_assert(offsetof(AGBRestraint, NoLOSHostageToLeaderTimeout) == 0x0004EC, "Member 'AGBRestraint::NoLOSHostageToLeaderTimeout' has a wrong offset!");
static_assert(offsetof(AGBRestraint, UsingGBPlayerState) == 0x0004F0, "Member 'AGBRestraint::UsingGBPlayerState' has a wrong offset!");
static_assert(offsetof(AGBRestraint, bHasIntimidators) == 0x0004F8, "Member 'AGBRestraint::bHasIntimidators' has a wrong offset!");
static_assert(offsetof(AGBRestraint, Intimidators) == 0x000500, "Member 'AGBRestraint::Intimidators' has a wrong offset!");
static_assert(offsetof(AGBRestraint, GBInstigatorPlayerState) == 0x000550, "Member 'AGBRestraint::GBInstigatorPlayerState' has a wrong offset!");

// Class GroundBranch.GBSequencerEvent
// 0x0018 (0x0238 - 0x0220)
class AGBSequencerEvent final : public AGBEvent
{
public:
	TArray<class ULevelSequence*>                 LevelSequences;                                    // 0x0220(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayNextSequence();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBSequencerEvent">();
	}
	static class AGBSequencerEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBSequencerEvent>();
	}
};
static_assert(alignof(AGBSequencerEvent) == 0x000008, "Wrong alignment on AGBSequencerEvent");
static_assert(sizeof(AGBSequencerEvent) == 0x000238, "Wrong size on AGBSequencerEvent");
static_assert(offsetof(AGBSequencerEvent, LevelSequences) == 0x000220, "Member 'AGBSequencerEvent::LevelSequences' has a wrong offset!");

// Class GroundBranch.GBSky
// 0x0708 (0x1740 - 0x1038)
class AGBSky : public ASkyCreator
{
public:
	uint8                                         Pad_1038[0x10];                                    // 0x1038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitialTimeOfDay;                                  // 0x1048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CycleStartTime;                                    // 0x104C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGBReplicatedDateTime                  ReplicatedDateTime;                                // 0x1050(0x0014)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1064[0x1C];                                    // 0x1064(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlobalSkylightScaling;                             // 0x1080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1084[0x4];                                     // 0x1084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      SkylightScalingMap;                                // 0x1088(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D8[0x8];                                     // 0x10D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SunlightShadowBias;                                // 0x10E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SunlightShadowSlopeBias;                           // 0x10E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSunlightLightShaftBloom;                       // 0x10E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10E9[0x3];                                     // 0x10E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SunlightBloomScale;                                // 0x10EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SunlightBloomThreshold;                            // 0x10F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SunlightBloomMaxBrightness;                        // 0x10F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10F8[0x4];                                     // 0x10F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           MoonLightColour;                                   // 0x10FC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseVolumetricFog;                                 // 0x110C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_110D[0x3];                                     // 0x110D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      VolumetricScatteringIntensityMap;                  // 0x1110(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         FogViewDistance;                                   // 0x1160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1164[0x4];                                     // 0x1164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FLinearColor>        FogInscatteringColourMap;                          // 0x1168(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FLinearColor>        DirectionalInscatteringColourMap;                  // 0x11B8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1208[0x50];                                    // 0x1208(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExtinctionScaleMultiplier;                         // 0x1258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_125C[0x4];                                     // 0x125C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      FogDensityMap;                                     // 0x1260(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, float>                      FogHeightFalloffMap;                               // 0x12B0(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, float>                      FogStartDistanceMap;                               // 0x1300(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         BloomIntensity;                                    // 0x1350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BloomThreshold;                                    // 0x1354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FLinearColor>        LowerHemisphereColourMap;                          // 0x1358(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         DistanceFieldMaxDistance;                          // 0x13A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceFieldOcclusionContrast;                    // 0x13AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceFieldOcclusionExponent;                    // 0x13B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceFieldMinOcclusion;                         // 0x13B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOcclusionCombineMode                         DistanceFieldOcclusionCombineMode;                 // 0x13B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13B9[0x7];                                     // 0x13B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      ExposureBiasMap;                                   // 0x13C0(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, float>                      MinEVMap;                                          // 0x1410(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, float>                      MaxEVMap;                                          // 0x1460(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, float>                      HistogramLogMaxMap;                                // 0x14B0(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         GlobalNVGMultiplier;                               // 0x1500(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1504[0x4];                                     // 0x1504(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      NVGMultiplierMap;                                  // 0x1508(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              SunRiseTimeSpan;                                   // 0x1558(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              SunSetTimeSpan;                                    // 0x1560(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NightBlendTimeProportion;                          // 0x1568(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DayBlendTimeProportion;                            // 0x156C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HardTimeSpanBlendTime;                             // 0x1570(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1574[0x4];                                     // 0x1574(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkyCreatorWeatherPreset*               CurrentWeatherPreset;                              // 0x1578(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NorthOffset;                                       // 0x1580(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SkyboxRotation;                                    // 0x1584(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EGBTimeSpanBlendType, struct FGBBlendedTimeSpan> CachedTimeSpanTagBlendedMap;               // 0x1588(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_15D8[0x48];                                    // 0x15D8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBSky* SkyActor)> OnInitialTimeOfDayChanged;                // 0x1620(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGBSky* SkyActor)> OnSkyUpdate;                              // 0x1630(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ULXRSourceComponent*                    LXRSourceComp;                                     // 0x1640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, float>                      MinLightLevelScaleMap;                             // 0x1648(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1698[0x60];                                    // 0x1698(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkyLightScalingChangeSpeed;                        // 0x16F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16FC[0x4];                                     // 0x16FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FName AlarmName)> OnTimeOfDayAlarm;                    // 0x1700(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           MPC_TimeOfDay;                                     // 0x1710(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1718[0x28];                                    // 0x1718(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GetAmbientNightIllumination(const float InMoonElevation, const float InLunarPhase, class USkyCreatorWeatherPreset* InWeatherPreset);
	static float GetCloudCover(const class USkyCreatorWeatherPreset* InWeatherPreset);
	static float GetFogAmount(const class USkyCreatorWeatherPreset* InWeatherPreset);
	static EGroundCoverType GetGroundCover(const class USkyCreatorWeatherPreset* InWeatherPreset);
	static float GetLunarPhase(int32 InYear, int32 InMonth, int32 InDay);
	static float GetLunarPhaseArea(int32 InYear, int32 InMonth, int32 InDay);
	static float GetLunarPhaseAreaForPhase(float InPhase);
	static class FString GetLunarPhaseName(const float InPhase);
	static float GetMoonIllumination(const float InMoonElevation, const float InLunarPhase, class USkyCreatorWeatherPreset* InWeatherPreset);
	static float GetNightAidedVisibility(const float InMoonIllumination, const float InAmbientIllumination, const class USkyCreatorWeatherPreset* InWeatherPreset);
	static float GetNightUnaidedVisibility(const float InMoonIllumination, const float InAmbientIllumination, const class USkyCreatorWeatherPreset* InWeatherPreset);
	static float GetRainAmount(const class USkyCreatorWeatherPreset* InWeatherPreset);
	static float GetSnowAmount(const class USkyCreatorWeatherPreset* InWeatherPreset);
	static class FName GetVisibilityName(const float InVisibility);
	static float GetWeatherVisibility(const class USkyCreatorWeatherPreset* InWeatherPreset);
	static float GetWindAmount(const class USkyCreatorWeatherPreset* InWeatherPreset);

	void AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);
	void DebugPrintAlarmTimes();
	void EndCycle();
	void EnsureInit();
	float GetCurrentNVGMultiplier();
	float GetMoonlightScalingFactors();
	void GetRandomWeatherPresetCategoryAndType(class FName* OutCategory, class FName* OutType);
	class FName GetRandomWeatherPresetTypeInCategory(const class FName InCategory);
	float GetSkylightScalingFactors();
	void GetSunAndMoonSequence(int32 InYear, int32 InMonth, int32 InDay, int32 NumberOfSteps, TArray<float>* OutTimes, TArray<float>* OutSunSequence, TArray<float>* OutMoonSequence, float* OutSunriseTime, float* OutSunsetTime);
	struct FGBBlendedTimeSpan GetTimeSpanTagBlended(const EGBTimeSpanBlendType BlendType);
	bool IsTimeSpanNearlyEqual(const struct FGBBlendedTimeSpan& Timespan, const class FName DesiredTimeSpan, const float AmountNeeded);
	float MapStandardHourToActualHour(float StandardHour, float InSunriseTime, float InSunsetTime);
	void OnChangedInitialTimeOfDay(const bool bIsTransitionalTime);
	void OnRep_CycleStartTime();
	void OnRep_ReplicatedDateTime();
	void OnTimeChangeEvent(const bool bIsTransitionalTime);
	void OnTimeSpanChangeEvent();
	void ResetTimeOfDayAlarms(const TArray<struct FGBTimeOfDayAlarm>& TimeOfDayAlarmInfo);
	void SetCurrentWeatherPreset(class USkyCreatorWeatherPreset* InWeatherPreset);
	void SetInitialTimeOfDay(int32 NewInitialTimeOfDay);
	void SetLowerHemisphereDesaturateAmount(const float InDesaturateAmount);
	void SetMissionTimePreset(const EMissionTimeLabel InMissionTimePreset);
	void SetMoonlightScaling(float NewMoonlightScaling);
	void SetSkylightScaling(float NewSkylightScaling);
	void SetSkylightScalingOverride(const class FName& Type, float Alpha);
	void SetSunlightScaling(float NewSunlightScaling);
	void SetTimeOfDayAlarms(const TArray<struct FGBTimeOfDayAlarm>& TimeOfDayAlarmInfo);
	void SetTimeOfDayFromString(const class FString& TimeOfDayString);
	void SetWeatherSystemIsEnabled(const bool bIsEnabled);
	void SetYearMonthDay(int32 InYear, int32 InMonth, int32 InDay);
	void StartCycle();
	void UnsetTimeOfDayAlarms(const TArray<struct FGBTimeOfDayAlarm>& TimeOfDayAlarmInfo);
	void UpdateLatLongAndTimeZone();

	TArray<class USkyCreatorWeatherPreset*> GetAllWeatherPresets(bool bAllSeasons, ESeason SelectedSeason) const;
	float GetCurrentMoonlightStrength() const;
	ESeason GetCurrentSeason() const;
	float GetCurrentSunlightStrength() const;
	class USkyCreatorWeatherPreset* GetCurrentWeatherPreset() const;
	bool GetDSTOnDate(int32 InYear, int32 InMonth, int32 InDay) const;
	float GetHour(const bool bGetTargetTime) const;
	void GetHoursMinutesSeconds(int32* OutHours, int32* OutMinutes, int32* OutSeconds) const;
	int32 GetInitialTimeOfDay() const;
	float GetMinLightLevelScale() const;
	EMissionTimeLabel GetMissionTimePreset() const;
	float GetMoonElevation(int32 InYear, int32 InMonth, int32 InDay, int32 InHours, int32 InMinutes, int32 InSeconds) const;
	float GetMoonlightScaling() const;
	float GetNorthOffset() const;
	float GetSkylightScaling() const;
	float GetStandardHour(const bool bGetTargetTime) const;
	float GetSunElevation(int32 InYear, int32 InMonth, int32 InDay, int32 InHours, int32 InMinutes, int32 InSeconds) const;
	float GetSunlightScaling() const;
	float GetSunlightScalingFactors() const;
	void GetSunriseAndSunsetTime(int32 InYear, int32 InMonth, int32 InDay, float* OutSunriseTime, float* OutSunsetTime, int32 NumberOfEvaluationSteps) const;
	class FString GetTimeOfDayString() const;
	class FName GetTimeSpanTag() const;
	void GetWeatherPresetProperties(const class USkyCreatorWeatherPreset* SelectedWeatherPreset, class FName* OutWeatherCategory, class FName* OutWeatherType, class FText* OutWeatherDescription) const;
	TArray<class USkyCreatorWeatherPreset*> GetWeatherPresetsForSeason(ESeason SelectedSeason) const;
	class FString GetWeatherString() const;
	bool GetWeatherSystemIsEnabled() const;
	void GetYearMonthDay(int32* OutYear, int32* OutMonth, int32* OutDay) const;
	float MapActualHourToStandardHour(float ActualHour, float InSunriseTime, float InSunsetTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBSky">();
	}
	static class AGBSky* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBSky>();
	}
};
static_assert(alignof(AGBSky) == 0x000008, "Wrong alignment on AGBSky");
static_assert(sizeof(AGBSky) == 0x001740, "Wrong size on AGBSky");
static_assert(offsetof(AGBSky, InitialTimeOfDay) == 0x001048, "Member 'AGBSky::InitialTimeOfDay' has a wrong offset!");
static_assert(offsetof(AGBSky, CycleStartTime) == 0x00104C, "Member 'AGBSky::CycleStartTime' has a wrong offset!");
static_assert(offsetof(AGBSky, ReplicatedDateTime) == 0x001050, "Member 'AGBSky::ReplicatedDateTime' has a wrong offset!");
static_assert(offsetof(AGBSky, GlobalSkylightScaling) == 0x001080, "Member 'AGBSky::GlobalSkylightScaling' has a wrong offset!");
static_assert(offsetof(AGBSky, SkylightScalingMap) == 0x001088, "Member 'AGBSky::SkylightScalingMap' has a wrong offset!");
static_assert(offsetof(AGBSky, SunlightShadowBias) == 0x0010E0, "Member 'AGBSky::SunlightShadowBias' has a wrong offset!");
static_assert(offsetof(AGBSky, SunlightShadowSlopeBias) == 0x0010E4, "Member 'AGBSky::SunlightShadowSlopeBias' has a wrong offset!");
static_assert(offsetof(AGBSky, bUseSunlightLightShaftBloom) == 0x0010E8, "Member 'AGBSky::bUseSunlightLightShaftBloom' has a wrong offset!");
static_assert(offsetof(AGBSky, SunlightBloomScale) == 0x0010EC, "Member 'AGBSky::SunlightBloomScale' has a wrong offset!");
static_assert(offsetof(AGBSky, SunlightBloomThreshold) == 0x0010F0, "Member 'AGBSky::SunlightBloomThreshold' has a wrong offset!");
static_assert(offsetof(AGBSky, SunlightBloomMaxBrightness) == 0x0010F4, "Member 'AGBSky::SunlightBloomMaxBrightness' has a wrong offset!");
static_assert(offsetof(AGBSky, MoonLightColour) == 0x0010FC, "Member 'AGBSky::MoonLightColour' has a wrong offset!");
static_assert(offsetof(AGBSky, bUseVolumetricFog) == 0x00110C, "Member 'AGBSky::bUseVolumetricFog' has a wrong offset!");
static_assert(offsetof(AGBSky, VolumetricScatteringIntensityMap) == 0x001110, "Member 'AGBSky::VolumetricScatteringIntensityMap' has a wrong offset!");
static_assert(offsetof(AGBSky, FogViewDistance) == 0x001160, "Member 'AGBSky::FogViewDistance' has a wrong offset!");
static_assert(offsetof(AGBSky, FogInscatteringColourMap) == 0x001168, "Member 'AGBSky::FogInscatteringColourMap' has a wrong offset!");
static_assert(offsetof(AGBSky, DirectionalInscatteringColourMap) == 0x0011B8, "Member 'AGBSky::DirectionalInscatteringColourMap' has a wrong offset!");
static_assert(offsetof(AGBSky, ExtinctionScaleMultiplier) == 0x001258, "Member 'AGBSky::ExtinctionScaleMultiplier' has a wrong offset!");
static_assert(offsetof(AGBSky, FogDensityMap) == 0x001260, "Member 'AGBSky::FogDensityMap' has a wrong offset!");
static_assert(offsetof(AGBSky, FogHeightFalloffMap) == 0x0012B0, "Member 'AGBSky::FogHeightFalloffMap' has a wrong offset!");
static_assert(offsetof(AGBSky, FogStartDistanceMap) == 0x001300, "Member 'AGBSky::FogStartDistanceMap' has a wrong offset!");
static_assert(offsetof(AGBSky, BloomIntensity) == 0x001350, "Member 'AGBSky::BloomIntensity' has a wrong offset!");
static_assert(offsetof(AGBSky, BloomThreshold) == 0x001354, "Member 'AGBSky::BloomThreshold' has a wrong offset!");
static_assert(offsetof(AGBSky, LowerHemisphereColourMap) == 0x001358, "Member 'AGBSky::LowerHemisphereColourMap' has a wrong offset!");
static_assert(offsetof(AGBSky, DistanceFieldMaxDistance) == 0x0013A8, "Member 'AGBSky::DistanceFieldMaxDistance' has a wrong offset!");
static_assert(offsetof(AGBSky, DistanceFieldOcclusionContrast) == 0x0013AC, "Member 'AGBSky::DistanceFieldOcclusionContrast' has a wrong offset!");
static_assert(offsetof(AGBSky, DistanceFieldOcclusionExponent) == 0x0013B0, "Member 'AGBSky::DistanceFieldOcclusionExponent' has a wrong offset!");
static_assert(offsetof(AGBSky, DistanceFieldMinOcclusion) == 0x0013B4, "Member 'AGBSky::DistanceFieldMinOcclusion' has a wrong offset!");
static_assert(offsetof(AGBSky, DistanceFieldOcclusionCombineMode) == 0x0013B8, "Member 'AGBSky::DistanceFieldOcclusionCombineMode' has a wrong offset!");
static_assert(offsetof(AGBSky, ExposureBiasMap) == 0x0013C0, "Member 'AGBSky::ExposureBiasMap' has a wrong offset!");
static_assert(offsetof(AGBSky, MinEVMap) == 0x001410, "Member 'AGBSky::MinEVMap' has a wrong offset!");
static_assert(offsetof(AGBSky, MaxEVMap) == 0x001460, "Member 'AGBSky::MaxEVMap' has a wrong offset!");
static_assert(offsetof(AGBSky, HistogramLogMaxMap) == 0x0014B0, "Member 'AGBSky::HistogramLogMaxMap' has a wrong offset!");
static_assert(offsetof(AGBSky, GlobalNVGMultiplier) == 0x001500, "Member 'AGBSky::GlobalNVGMultiplier' has a wrong offset!");
static_assert(offsetof(AGBSky, NVGMultiplierMap) == 0x001508, "Member 'AGBSky::NVGMultiplierMap' has a wrong offset!");
static_assert(offsetof(AGBSky, SunRiseTimeSpan) == 0x001558, "Member 'AGBSky::SunRiseTimeSpan' has a wrong offset!");
static_assert(offsetof(AGBSky, SunSetTimeSpan) == 0x001560, "Member 'AGBSky::SunSetTimeSpan' has a wrong offset!");
static_assert(offsetof(AGBSky, NightBlendTimeProportion) == 0x001568, "Member 'AGBSky::NightBlendTimeProportion' has a wrong offset!");
static_assert(offsetof(AGBSky, DayBlendTimeProportion) == 0x00156C, "Member 'AGBSky::DayBlendTimeProportion' has a wrong offset!");
static_assert(offsetof(AGBSky, HardTimeSpanBlendTime) == 0x001570, "Member 'AGBSky::HardTimeSpanBlendTime' has a wrong offset!");
static_assert(offsetof(AGBSky, CurrentWeatherPreset) == 0x001578, "Member 'AGBSky::CurrentWeatherPreset' has a wrong offset!");
static_assert(offsetof(AGBSky, NorthOffset) == 0x001580, "Member 'AGBSky::NorthOffset' has a wrong offset!");
static_assert(offsetof(AGBSky, SkyboxRotation) == 0x001584, "Member 'AGBSky::SkyboxRotation' has a wrong offset!");
static_assert(offsetof(AGBSky, CachedTimeSpanTagBlendedMap) == 0x001588, "Member 'AGBSky::CachedTimeSpanTagBlendedMap' has a wrong offset!");
static_assert(offsetof(AGBSky, OnInitialTimeOfDayChanged) == 0x001620, "Member 'AGBSky::OnInitialTimeOfDayChanged' has a wrong offset!");
static_assert(offsetof(AGBSky, OnSkyUpdate) == 0x001630, "Member 'AGBSky::OnSkyUpdate' has a wrong offset!");
static_assert(offsetof(AGBSky, LXRSourceComp) == 0x001640, "Member 'AGBSky::LXRSourceComp' has a wrong offset!");
static_assert(offsetof(AGBSky, MinLightLevelScaleMap) == 0x001648, "Member 'AGBSky::MinLightLevelScaleMap' has a wrong offset!");
static_assert(offsetof(AGBSky, SkyLightScalingChangeSpeed) == 0x0016F8, "Member 'AGBSky::SkyLightScalingChangeSpeed' has a wrong offset!");
static_assert(offsetof(AGBSky, OnTimeOfDayAlarm) == 0x001700, "Member 'AGBSky::OnTimeOfDayAlarm' has a wrong offset!");
static_assert(offsetof(AGBSky, MPC_TimeOfDay) == 0x001710, "Member 'AGBSky::MPC_TimeOfDay' has a wrong offset!");

// Class GroundBranch.GBSkylightOverrideVolume
// 0x0010 (0x0268 - 0x0258)
class AGBSkylightOverrideVolume final : public AGBSmartTriggerVolumeBase
{
public:
	float                                         MinLightLevel;                                     // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SkyLightScale;                                     // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGBSky*                                 GBSkyRef;                                          // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBSkylightOverrideVolume">();
	}
	static class AGBSkylightOverrideVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBSkylightOverrideVolume>();
	}
};
static_assert(alignof(AGBSkylightOverrideVolume) == 0x000008, "Wrong alignment on AGBSkylightOverrideVolume");
static_assert(sizeof(AGBSkylightOverrideVolume) == 0x000268, "Wrong size on AGBSkylightOverrideVolume");
static_assert(offsetof(AGBSkylightOverrideVolume, MinLightLevel) == 0x000258, "Member 'AGBSkylightOverrideVolume::MinLightLevel' has a wrong offset!");
static_assert(offsetof(AGBSkylightOverrideVolume, SkyLightScale) == 0x00025C, "Member 'AGBSkylightOverrideVolume::SkyLightScale' has a wrong offset!");
static_assert(offsetof(AGBSkylightOverrideVolume, GBSkyRef) == 0x000260, "Member 'AGBSkylightOverrideVolume::GBSkyRef' has a wrong offset!");

// Class GroundBranch.GBSpatialAudioVolume
// 0x0008 (0x0278 - 0x0270)
class AGBSpatialAudioVolume final : public AAkSpatialAudioVolume
{
public:
	bool                                          bReadyRoomSound;                                   // 0x0270(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerReadyRoomStatusChanged(class AGBPlayerState* GBPlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBSpatialAudioVolume">();
	}
	static class AGBSpatialAudioVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBSpatialAudioVolume>();
	}
};
static_assert(alignof(AGBSpatialAudioVolume) == 0x000008, "Wrong alignment on AGBSpatialAudioVolume");
static_assert(sizeof(AGBSpatialAudioVolume) == 0x000278, "Wrong size on AGBSpatialAudioVolume");
static_assert(offsetof(AGBSpatialAudioVolume, bReadyRoomSound) == 0x000270, "Member 'AGBSpatialAudioVolume::bReadyRoomSound' has a wrong offset!");

// Class GroundBranch.GBSpawnProtectionVolume
// 0x0000 (0x0270 - 0x0270)
class AGBSpawnProtectionVolume final : public AGBGameTriggerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBSpawnProtectionVolume">();
	}
	static class AGBSpawnProtectionVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBSpawnProtectionVolume>();
	}
};
static_assert(alignof(AGBSpawnProtectionVolume) == 0x000008, "Wrong alignment on AGBSpawnProtectionVolume");
static_assert(sizeof(AGBSpawnProtectionVolume) == 0x000270, "Wrong size on AGBSpawnProtectionVolume");

// Class GroundBranch.GBSpectatorPawn
// 0x0030 (0x02D8 - 0x02A8)
class AGBSpectatorPawn : public ASpectatorPawn
{
public:
	class AGBPlayerController*                    GBPlayerController;                                // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LastSpectatorCameraStyle;                          // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraModifier>            SpectatorCameraModifierClass;                      // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           SpectatorNightVisionModes;                         // 0x02C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                SpectatorOverlayClass;                             // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnViewTargetChanged(class AGBPlayerController* PlayerController);
	void ServerSpectatorViewActor(class AActor* ActorTarget);
	void SpectatorSetCamera(class FName NewCameraStyle);
	void SpectatorStopFollowing();
	void SpectatorViewActor(class AActor* ActorTarget);
	void SpectatorViewNextPlayer();
	void SpectatorViewPrevPlayer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBSpectatorPawn">();
	}
	static class AGBSpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBSpectatorPawn>();
	}
};
static_assert(alignof(AGBSpectatorPawn) == 0x000008, "Wrong alignment on AGBSpectatorPawn");
static_assert(sizeof(AGBSpectatorPawn) == 0x0002D8, "Wrong size on AGBSpectatorPawn");
static_assert(offsetof(AGBSpectatorPawn, GBPlayerController) == 0x0002A8, "Member 'AGBSpectatorPawn::GBPlayerController' has a wrong offset!");
static_assert(offsetof(AGBSpectatorPawn, LastSpectatorCameraStyle) == 0x0002B0, "Member 'AGBSpectatorPawn::LastSpectatorCameraStyle' has a wrong offset!");
static_assert(offsetof(AGBSpectatorPawn, SpectatorCameraModifierClass) == 0x0002B8, "Member 'AGBSpectatorPawn::SpectatorCameraModifierClass' has a wrong offset!");
static_assert(offsetof(AGBSpectatorPawn, SpectatorNightVisionModes) == 0x0002C0, "Member 'AGBSpectatorPawn::SpectatorNightVisionModes' has a wrong offset!");
static_assert(offsetof(AGBSpectatorPawn, SpectatorOverlayClass) == 0x0002D0, "Member 'AGBSpectatorPawn::SpectatorOverlayClass' has a wrong offset!");

// Class GroundBranch.GBSquadState
// 0x0050 (0x0270 - 0x0220)
class AGBSquadState final : public AInfo
{
public:
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AGBSquad*                               AuthoritySquad;                                    // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ID;                                                // 0x0238(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SquadColor;                                        // 0x0248(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0258(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerState*>                   PlayerStates;                                      // 0x0260(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	int32 GetSquadAliveCount();
	bool IsSquadAlive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBSquadState">();
	}
	static class AGBSquadState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBSquadState>();
	}
};
static_assert(alignof(AGBSquadState) == 0x000008, "Wrong alignment on AGBSquadState");
static_assert(sizeof(AGBSquadState) == 0x000270, "Wrong size on AGBSquadState");
static_assert(offsetof(AGBSquadState, AuthoritySquad) == 0x000230, "Member 'AGBSquadState::AuthoritySquad' has a wrong offset!");
static_assert(offsetof(AGBSquadState, ID) == 0x000238, "Member 'AGBSquadState::ID' has a wrong offset!");
static_assert(offsetof(AGBSquadState, SquadColor) == 0x000248, "Member 'AGBSquadState::SquadColor' has a wrong offset!");
static_assert(offsetof(AGBSquadState, Index_0) == 0x000258, "Member 'AGBSquadState::Index_0' has a wrong offset!");
static_assert(offsetof(AGBSquadState, PlayerStates) == 0x000260, "Member 'AGBSquadState::PlayerStates' has a wrong offset!");

// Class GroundBranch.GBTimeOfDayAlarmComponent
// 0x0028 (0x00D8 - 0x00B0)
class UGBTimeOfDayAlarmComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetTimeOfDayAlarms();
	void SetTimeOfDayAlarms(const TArray<struct FGBTimeOfDayAlarm>& InTimeOfDayAlarmInfo, TDelegate<void(const class FName AlarmName)> InDelegate);
	void TimeOfDayAlarmsDelegate(const class FName AlarmName);
	void UnsetTimeOfDayAlarms();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBTimeOfDayAlarmComponent">();
	}
	static class UGBTimeOfDayAlarmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBTimeOfDayAlarmComponent>();
	}
};
static_assert(alignof(UGBTimeOfDayAlarmComponent) == 0x000008, "Wrong alignment on UGBTimeOfDayAlarmComponent");
static_assert(sizeof(UGBTimeOfDayAlarmComponent) == 0x0000D8, "Wrong size on UGBTimeOfDayAlarmComponent");

// Class GroundBranch.GBTypes
// 0x0000 (0x0028 - 0x0028)
class UGBTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBTypes">();
	}
	static class UGBTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBTypes>();
	}
};
static_assert(alignof(UGBTypes) == 0x000008, "Wrong alignment on UGBTypes");
static_assert(sizeof(UGBTypes) == 0x000028, "Wrong size on UGBTypes");

// Class GroundBranch.GBUseInterface
// 0x0000 (0x0000 - 0x0000)
class IGBUseInterface final
{
public:
	void AddUser(class AController* Controller);
	class FName AIQuestion(class AController* Controller, class FName UseType);
	class FName AIQuestionWithParams(class AController* Controller, class FName UseType, const class FString& Params_0);
	void AIUse(class AController* Controller, class FName UseType);
	void AIUseWithParams(class AController* Controller, class FName UseType, const class FString& Params_0);
	void ClientUse(class AController* Controller, class FName UseType);
	void ClientUseWithParams(class AController* Controller, class FName UseType, const class FString& Params_0);
	void RemoveUser(class AController* Controller);
	void ServerUse(class AController* Controller, class FName UseType);
	void ServerUseWithParams(class AController* Controller, class FName UseType, const class FString& Params_0);

	int32 GetNumUsers() const;
	bool IsTeamSpecific() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBUseInterface">();
	}
	static class IGBUseInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGBUseInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGBUseInterface) == 0x000001, "Wrong alignment on IGBUseInterface");
static_assert(sizeof(IGBUseInterface) == 0x000001, "Wrong size on IGBUseInterface");

// Class GroundBranch.GBVOIPManager
// 0x00B8 (0x00E0 - 0x0028)
class UGBVOIPManager : public UObject
{
public:
	TArray<class FString>                         MuteList;                                          // 0x0028(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxVoiceDistanceSquared;                           // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x10];                                      // 0x0054(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SampleRate;                                        // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         NumBytesPerSample;                                 // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x17];                                      // 0x0069(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGBVOIPData>                    VOIPDataList;                                      // 0x0080(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGBPlayerCharVoiceInfo>         PlayerCharVoiceList;                               // 0x0090(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          VOIPAudioStartEvent;                               // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          VOIPAudioStopEvent;                                // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          RadioTransmitStartEvent;                           // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          RadioTransmitEndEvent;                             // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGBPlayerState* PlayerState, bool bIsTalking, bool bWasRadio)> OnVOIPEvent; // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	TArray<class FString> GetDeviceNames();
	void OnPlayerCharVoicePostEventCallback(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);
	void SetCharVoiceSwitchEvent(class UAkComponent* AkComponent, bool bIsRadio, bool bIsLocal);
	void SetDevice(const class FString& DeviceName);
	void SetVOIPSwitchEvent(class UAkComponent* AkComponent, EVOIPType VOIPType);

	class FString GetCurrentDeviceName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBVOIPManager">();
	}
	static class UGBVOIPManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGBVOIPManager>();
	}
};
static_assert(alignof(UGBVOIPManager) == 0x000008, "Wrong alignment on UGBVOIPManager");
static_assert(sizeof(UGBVOIPManager) == 0x0000E0, "Wrong size on UGBVOIPManager");
static_assert(offsetof(UGBVOIPManager, MuteList) == 0x000028, "Member 'UGBVOIPManager::MuteList' has a wrong offset!");
static_assert(offsetof(UGBVOIPManager, MaxVoiceDistanceSquared) == 0x000050, "Member 'UGBVOIPManager::MaxVoiceDistanceSquared' has a wrong offset!");
static_assert(offsetof(UGBVOIPManager, SampleRate) == 0x000064, "Member 'UGBVOIPManager::SampleRate' has a wrong offset!");
static_assert(offsetof(UGBVOIPManager, NumBytesPerSample) == 0x000068, "Member 'UGBVOIPManager::NumBytesPerSample' has a wrong offset!");
static_assert(offsetof(UGBVOIPManager, VOIPDataList) == 0x000080, "Member 'UGBVOIPManager::VOIPDataList' has a wrong offset!");
static_assert(offsetof(UGBVOIPManager, PlayerCharVoiceList) == 0x000090, "Member 'UGBVOIPManager::PlayerCharVoiceList' has a wrong offset!");
static_assert(offsetof(UGBVOIPManager, VOIPAudioStartEvent) == 0x0000A0, "Member 'UGBVOIPManager::VOIPAudioStartEvent' has a wrong offset!");
static_assert(offsetof(UGBVOIPManager, VOIPAudioStopEvent) == 0x0000A8, "Member 'UGBVOIPManager::VOIPAudioStopEvent' has a wrong offset!");
static_assert(offsetof(UGBVOIPManager, RadioTransmitStartEvent) == 0x0000B0, "Member 'UGBVOIPManager::RadioTransmitStartEvent' has a wrong offset!");
static_assert(offsetof(UGBVOIPManager, RadioTransmitEndEvent) == 0x0000B8, "Member 'UGBVOIPManager::RadioTransmitEndEvent' has a wrong offset!");
static_assert(offsetof(UGBVOIPManager, OnVOIPEvent) == 0x0000D0, "Member 'UGBVOIPManager::OnVOIPEvent' has a wrong offset!");

// Class GroundBranch.GBWeatherInfo
// 0x0010 (0x0230 - 0x0220)
class AGBWeatherInfo final : public AInfo
{
public:
	class AGBPlayerCameraManager*                 LocalCameraManager;                                // 0x0220(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateTransformTime;                               // 0x0228(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateTransformEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBWeatherInfo">();
	}
	static class AGBWeatherInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBWeatherInfo>();
	}
};
static_assert(alignof(AGBWeatherInfo) == 0x000008, "Wrong alignment on AGBWeatherInfo");
static_assert(sizeof(AGBWeatherInfo) == 0x000230, "Wrong size on AGBWeatherInfo");
static_assert(offsetof(AGBWeatherInfo, LocalCameraManager) == 0x000220, "Member 'AGBWeatherInfo::LocalCameraManager' has a wrong offset!");
static_assert(offsetof(AGBWeatherInfo, UpdateTransformTime) == 0x000228, "Member 'AGBWeatherInfo::UpdateTransformTime' has a wrong offset!");

// Class GroundBranch.GBWorldSettings
// 0x00F8 (0x0498 - 0x03A0)
class AGBWorldSettings final : public AWorldSettings
{
public:
	class UGBLevelSummary*                        LevelSummary;                                      // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGBClimatePreset*                       LocalClimate;                                      // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Latitude;                                          // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Longitude;                                         // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Timezone;                                          // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bObservesDST;                                      // 0x03BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BD[0x3];                                      // 0x03BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESeason>                               AllowedSeasons;                                    // 0x03C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   TerritoryName;                                     // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLocationIsClassified;                             // 0x03D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EMissionTimeLabel>                     PreferredMissionTimes;                             // 0x03E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   DefaultSpatialSoundTag;                            // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AIVisibilityMultiplier;                            // 0x03F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AIHearingMultiplier;                               // 0x03FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        LightVisibilityCurvePath;                          // 0x0400(0x0018)(Edit, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldCreateDebugSquad;                           // 0x0418(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnFriendlyAI;                                  // 0x0419(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41A[0x2];                                      // 0x041A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberFriendlyAI;                                  // 0x041C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class ALevelSequenceActor>     SequenceToPlayBeforeMissionStarts;                 // 0x0420(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class ALevelSequenceActor>     SequenceToPlayAfterMissionSuccess;                 // 0x0448(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class ALevelSequenceActor>     SequenceToPlayAfterMissionFail;                    // 0x0470(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class AGBWorldSettings* GetWorldSettings(const class UObject* WorldContextObject);

	float GetAIHearingMultiplier() const;
	float GetAIVisibilityMultiplier() const;
	TArray<ESeason> GetAllowedSeasons() const;
	class FName GetDefaultSpatialSoundTag() const;
	int32 GetFirstAllowableMonth(int32 StartMonth) const;
	bool GetIsMonthAllowed(int32 InMonth) const;
	float GetLatitude() const;
	class UGBLevelSummary* GetLevelSummary() const;
	TArray<int32> GetListOfAllowableMonthNumbers() const;
	class UGBClimatePreset* GetLocalClimatePreset() const;
	struct FGBClimateSettings GetLocalClimateSettings() const;
	bool GetLocationIsClassified() const;
	float GetLongitude() const;
	int32 GetNumberFriendlyAI() const;
	bool GetObservesDST() const;
	TArray<EMissionTimeLabel> GetPreferredMissionTimes() const;
	TSoftObjectPtr<class ALevelSequenceActor> GetSequenceToPlayAfterMissionFail() const;
	TSoftObjectPtr<class ALevelSequenceActor> GetSequenceToPlayAfterMissionSuccess() const;
	TSoftObjectPtr<class ALevelSequenceActor> GetSequenceToPlayBeforeMissionStarts() const;
	bool GetShouldCreateDebugSquad() const;
	bool GetSpawnFriendlyAI() const;
	class FName GetTerritoryName() const;
	float GetTimeZone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GBWorldSettings">();
	}
	static class AGBWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGBWorldSettings>();
	}
};
static_assert(alignof(AGBWorldSettings) == 0x000008, "Wrong alignment on AGBWorldSettings");
static_assert(sizeof(AGBWorldSettings) == 0x000498, "Wrong size on AGBWorldSettings");
static_assert(offsetof(AGBWorldSettings, LevelSummary) == 0x0003A0, "Member 'AGBWorldSettings::LevelSummary' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, LocalClimate) == 0x0003A8, "Member 'AGBWorldSettings::LocalClimate' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, Latitude) == 0x0003B0, "Member 'AGBWorldSettings::Latitude' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, Longitude) == 0x0003B4, "Member 'AGBWorldSettings::Longitude' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, Timezone) == 0x0003B8, "Member 'AGBWorldSettings::Timezone' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, bObservesDST) == 0x0003BC, "Member 'AGBWorldSettings::bObservesDST' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, AllowedSeasons) == 0x0003C0, "Member 'AGBWorldSettings::AllowedSeasons' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, TerritoryName) == 0x0003D0, "Member 'AGBWorldSettings::TerritoryName' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, bLocationIsClassified) == 0x0003D8, "Member 'AGBWorldSettings::bLocationIsClassified' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, PreferredMissionTimes) == 0x0003E0, "Member 'AGBWorldSettings::PreferredMissionTimes' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, DefaultSpatialSoundTag) == 0x0003F0, "Member 'AGBWorldSettings::DefaultSpatialSoundTag' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, AIVisibilityMultiplier) == 0x0003F8, "Member 'AGBWorldSettings::AIVisibilityMultiplier' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, AIHearingMultiplier) == 0x0003FC, "Member 'AGBWorldSettings::AIHearingMultiplier' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, LightVisibilityCurvePath) == 0x000400, "Member 'AGBWorldSettings::LightVisibilityCurvePath' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, bShouldCreateDebugSquad) == 0x000418, "Member 'AGBWorldSettings::bShouldCreateDebugSquad' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, bSpawnFriendlyAI) == 0x000419, "Member 'AGBWorldSettings::bSpawnFriendlyAI' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, NumberFriendlyAI) == 0x00041C, "Member 'AGBWorldSettings::NumberFriendlyAI' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, SequenceToPlayBeforeMissionStarts) == 0x000420, "Member 'AGBWorldSettings::SequenceToPlayBeforeMissionStarts' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, SequenceToPlayAfterMissionSuccess) == 0x000448, "Member 'AGBWorldSettings::SequenceToPlayAfterMissionSuccess' has a wrong offset!");
static_assert(offsetof(AGBWorldSettings, SequenceToPlayAfterMissionFail) == 0x000470, "Member 'AGBWorldSettings::SequenceToPlayAfterMissionFail' has a wrong offset!");

// Class GroundBranch.JoyColorWheel
// 0x0038 (0x0140 - 0x0108)
class UJoyColorWheel final : public UWidget
{
public:
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           JoyColor;                                          // 0x0118(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipAnimationOnConstruction;                      // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FLinearColor& NewColor)> OnColorChanged;              // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	struct FLinearColor GetColor();
	void SetColor(const struct FLinearColor& NewColor, bool SkipAnimation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JoyColorWheel">();
	}
	static class UJoyColorWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJoyColorWheel>();
	}
};
static_assert(alignof(UJoyColorWheel) == 0x000008, "Wrong alignment on UJoyColorWheel");
static_assert(sizeof(UJoyColorWheel) == 0x000140, "Wrong size on UJoyColorWheel");
static_assert(offsetof(UJoyColorWheel, JoyColor) == 0x000118, "Member 'UJoyColorWheel::JoyColor' has a wrong offset!");
static_assert(offsetof(UJoyColorWheel, bSkipAnimationOnConstruction) == 0x000128, "Member 'UJoyColorWheel::bSkipAnimationOnConstruction' has a wrong offset!");
static_assert(offsetof(UJoyColorWheel, OnColorChanged) == 0x000130, "Member 'UJoyColorWheel::OnColorChanged' has a wrong offset!");

// Class GroundBranch.TKMathFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTKMathFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AreLineSegmentsCrossing(const struct FVector& pointA1, const struct FVector& pointA2, const struct FVector& pointB1, const struct FVector& pointB2);
	static struct FVector ClosestPointOnLineSegment(const struct FVector& Point, const struct FVector& LineStart, const struct FVector& LineEnd);
	static struct FVector ClosestPointOnSphereToLine(const struct FVector& SphereOrigin, float SphereRadius, const struct FVector& LineOrigin, const struct FVector& LineDir);
	static void ClosestPointsOfLineSegments(const struct FVector& Line1Start, const struct FVector& Line1End, const struct FVector& Line2Start, const struct FVector& Line2End, struct FVector* LinePoint1, struct FVector* LinePoint2);
	static bool ClosestPointsOnTwoLines(struct FVector* closestPointLine1, struct FVector* closestPointLine2, const struct FVector& LinePoint1, const struct FVector& lineVec1, const struct FVector& LinePoint2, const struct FVector& lineVec2);
	static void ConvertAnchorToAnchor(const class UObject* WorldContextObject, const struct FAnchors& CurrentAnchor, const struct FMargin& Offsets, const struct FAnchors& TargetAnchor, struct FMargin* ConvertedOffsets);
	static float ConvertPhysicsLinearVelocity(const struct FVector& Velocity, ESpeedUnit SpeedUnit);
	static struct FVector GetVelocityAtPoint(class UPrimitiveComponent* Target, const struct FVector& Point, class FName BoneName, bool DrawDebugInfo);
	static struct FVector GridSnap(const struct FVector& A, float Grid);
	static bool IsEvenNumber(float A);
	static bool IsLineInsideSphere(const struct FVector& LineStart, const struct FVector& LineDir, float LineLength, const struct FVector& SphereOrigin, float SphereRadius);
	static bool IsMultipleOf(int32 A, int32 Multiple);
	static bool IsPointInsideBox(const struct FVector& Point, const struct FVector& BoxOrigin, const struct FVector& BoxExtent);
	static bool IsPowerOfTwo(int32 X);
	static bool LineExtentBoxIntersection(const struct FBox& InBox, const struct FVector& Start, const struct FVector& End, const struct FVector& Extent, struct FVector* HitLocation, struct FVector* HitNormal, float* HitTime);
	static bool LineToLineIntersection(struct FVector* IntersectionPoint, const struct FVector& LinePoint1, const struct FVector& LineDir1, const struct FVector& LinePoint2, const struct FVector& LineDir2);
	static float NegateFloat(float A);
	static int32 NegateInt(int32 A);
	static struct FVector2D NegateVector2D(const struct FVector2D& A);
	static int32 PointOnWhichSideOfLineSegment(const struct FVector& LinePoint1, const struct FVector& LinePoint2, const struct FVector& Point);
	static struct FVector ProjectPointOnLine(const struct FVector& LineOrigin, const struct FVector& LineDirection, const struct FVector& Point);
	static int32 RoundToLowerMultiple(int32 A, int32 Multiple, bool skipSelf);
	static int32 RoundToNearestMultiple(int32 A, int32 Multiple);
	static int32 RoundToUpperMultiple(int32 A, int32 Multiple, bool skipSelf);
	static void SetCenterOfMassOffset(class UPrimitiveComponent* Target, const struct FVector& Offset, class FName BoneName);
	static struct FVector SetVectorLength(const struct FVector& A, float Size);
	static float SignedDistancePlanePoint(const struct FVector& PlaneNormal, const struct FVector& PlanePoint, const struct FVector& Point);
	static bool SphereBoxIntersection(const struct FVector& SphereOrigin, float SphereRadius, const struct FVector& BoxOrigin, const struct FVector& BoxExtent);
	static struct FVector VectorDegreesToRadians(const struct FVector& DegVector);
	static struct FVector VectorRadiansToDegrees(const struct FVector& RadVector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TKMathFunctionLibrary">();
	}
	static class UTKMathFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTKMathFunctionLibrary>();
	}
};
static_assert(alignof(UTKMathFunctionLibrary) == 0x000008, "Wrong alignment on UTKMathFunctionLibrary");
static_assert(sizeof(UTKMathFunctionLibrary) == 0x000028, "Wrong size on UTKMathFunctionLibrary");

}

