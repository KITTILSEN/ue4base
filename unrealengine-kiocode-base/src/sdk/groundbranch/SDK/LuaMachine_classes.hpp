#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: LuaMachine

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "LuaMachine_structs.hpp"
#include "SlateCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class LuaMachine.LuaBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class ULuaBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FLuaValue AssignLuaValueToLuaState(class UObject* WorldContextObject, const struct FLuaValue& Value, TSubclassOf<class ULuaState> State);
	static struct FLuaValue Conv_BoolToLuaValue(const bool Value);
	static struct FLuaValue Conv_FloatToLuaValue(const float Value);
	static struct FLuaValue Conv_IntToLuaValue(const int32 Value);
	static bool Conv_LuaValueToBool(const struct FLuaValue& Value);
	static class UClass* Conv_LuaValueToClass(const struct FLuaValue& Value);
	static float Conv_LuaValueToFloat(const struct FLuaValue& Value);
	static struct FVector Conv_LuaValueToFVector(const struct FLuaValue& Value);
	static int32 Conv_LuaValueToInt(const struct FLuaValue& Value);
	static class FName Conv_LuaValueToName(const struct FLuaValue& Value);
	static class UObject* Conv_LuaValueToObject(const struct FLuaValue& Value);
	static class FString Conv_LuaValueToString(const struct FLuaValue& Value);
	static class FText Conv_LuaValueToText(const struct FLuaValue& Value);
	static struct FLuaValue Conv_NameToLuaValue(const class FName Value);
	static struct FLuaValue Conv_ObjectToLuaValue(class UObject* Object);
	static struct FLuaValue Conv_StringToLuaValue(const class FString& Value);
	static struct FLuaValue Conv_TextToLuaValue(const class FText& Value);
	static struct FLuaValue GetLuaComponentAsLuaValue(class AActor* Actor);
	static struct FLuaValue GetLuaComponentByNameAsLuaValue(class AActor* Actor, const class FString& Name_0);
	static struct FLuaValue GetLuaComponentByStateAndNameAsLuaValue(class AActor* Actor, TSubclassOf<class ULuaState> State, const class FString& Name_0);
	static struct FLuaValue GetLuaComponentByStateAsLuaValue(class AActor* Actor, TSubclassOf<class ULuaState> State);
	static void GetLuaReflectionType(class UObject* InObject, const class FString& Name_0, ELuaReflectionType* LuaReflectionTypes);
	static struct FLuaValue LuaComponentGetField(const struct FLuaValue& LuaComponent, const class FString& Key);
	static struct FLuaValue LuaCreateBool(const bool bInBool);
	static struct FLuaValue LuaCreateInteger(const int32 Value);
	static struct FLuaValue LuaCreateLazyTable(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State);
	static struct FLuaValue LuaCreateNil();
	static struct FLuaValue LuaCreateNumber(const float Value);
	static struct FLuaValue LuaCreateObject(class UObject* InObject);
	static struct FLuaValue LuaCreateObjectInState(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, class UObject* InObject);
	static struct FLuaValue LuaCreateString(const class FString& String);
	static struct FLuaValue LuaCreateTable(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State);
	static struct FLuaValue LuaCreateThread(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const struct FLuaValue& Value);
	static struct FLuaValue LuaCreateUFunction(class UObject* InObject, const class FString& FunctionName);
	static void LuaGCCollect(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State);
	static void LuaGCRestart(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State);
	static void LuaGCStop(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State);
	static struct FLuaValue LuaGetGlobal(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const class FString& Name_0);
	static class ULuaState* LuaGetState(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State);
	static int32 LuaGetTop(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State);
	static int32 LuaGetUsedMemory(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State);
	static struct FLuaValue LuaGlobalCall(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const class FString& Name_0, const TArray<struct FLuaValue>& Args);
	static TArray<struct FLuaValue> LuaGlobalCallMulti(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const class FString& Name_0, const TArray<struct FLuaValue>& Args);
	static struct FLuaValue LuaGlobalCallValue(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const struct FLuaValue& Value, const TArray<struct FLuaValue>& Args);
	static TArray<struct FLuaValue> LuaGlobalCallValueMulti(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const struct FLuaValue& Value, const TArray<struct FLuaValue>& Args);
	static void LuaHttpRequest(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const class FString& Method, const class FString& URL, const TMap<class FString, class FString>& Headers, const struct FLuaValue& Body, const struct FLuaValue& Context, const TDelegate<void(const struct FLuaValue& Context, const struct FLuaValue& Response)>& ResponseReceived, const TDelegate<void(const struct FLuaValue& Context)>& Error);
	static bool LuaLoadPakFile(const class FString& Filename, const class FString& Mountpoint, TArray<struct FLuaValue>* Assets, const class FString& ContentPath, const class FString& AssetRegistryPath);
	static struct FLuaValue LuaNewLuaUserDataObject(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, TSubclassOf<class ULuaUserDataObject> UserDataObjectClass, bool bTrackObject);
	static struct FLuaValue LuaRunByteCode(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const TArray<uint8>& ByteCode, const class FString& CodePath);
	static struct FLuaValue LuaRunCodeAsset(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, class ULuaCode* CodeAsset);
	static struct FLuaValue LuaRunFile(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const class FString& Filename, const bool bIgnoreNonExistent);
	static struct FLuaValue LuaRunNonContentFile(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const class FString& Filename, const bool bIgnoreNonExistent);
	static struct FLuaValue LuaRunString(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const class FString& CodeString, const class FString& CodePath);
	static void LuaRunURL(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const class FString& URL, const TMap<class FString, class FString>& Headers, const class FString& SecurityHeader, const class FString& SignaturePublicExponent, const class FString& SignatureModulus, TDelegate<void(const struct FLuaValue& ReturnValue, bool bWasSuccessful, int32 StatusCode)> Completed);
	static void LuaSetGlobal(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const class FString& Name_0, const struct FLuaValue& Value);
	static void LuaSetUserDataMetaTable(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const struct FLuaValue& MetaTable);
	static void LuaStateDestroy(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State);
	static void LuaStateReload(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State);
	static struct FLuaValue LuaTableAssetToLuaTable(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, class ULuaTableAsset* TableAsset);
	static void LuaTableFillObject(const struct FLuaValue& InTable, class UObject* InObject);
	static struct FLuaValue LuaTableFromMap(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const TMap<class FString, struct FLuaValue>& Map);
	static struct FLuaValue LuaTableGetByIndex(const struct FLuaValue& Table, const int32 Index_0);
	static struct FLuaValue LuaTableGetField(const struct FLuaValue& Table, const class FString& Key);
	static TArray<struct FLuaValue> LuaTableGetKeys(const struct FLuaValue& Table);
	static TArray<struct FLuaValue> LuaTableGetValues(const struct FLuaValue& Table);
	static bool LuaTableImplements(const struct FLuaValue& Table, class ULuaTableAsset* TableAsset);
	static bool LuaTableImplementsAll(const struct FLuaValue& Table, const TArray<class ULuaTableAsset*>& TableAssets);
	static bool LuaTableImplementsAny(const struct FLuaValue& Table, const TArray<class ULuaTableAsset*>& TableAssets);
	static struct FLuaValue LuaTableIndexCall(const struct FLuaValue& InTable, const int32 Index_0, const TArray<struct FLuaValue>& Args);
	static struct FLuaValue LuaTableKeyCall(const struct FLuaValue& InTable, const class FString& Key, const TArray<struct FLuaValue>& Args);
	static struct FLuaValue LuaTableKeyCallWithSelf(const struct FLuaValue& InTable, const class FString& Key, const TArray<struct FLuaValue>& Args);
	static struct FLuaValue LuaTableMergePack(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const TArray<struct FLuaValue>& Values1, const TArray<struct FLuaValue>& Values2);
	static TArray<struct FLuaValue> LuaTableMergeUnpack(const struct FLuaValue& InTable1, const struct FLuaValue& InTable2);
	static struct FLuaValue LuaTablePack(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const TArray<struct FLuaValue>& Values);
	static TArray<struct FLuaValue> LuaTableRange(const struct FLuaValue& InTable, const int32 First, const int32 Last);
	static struct FLuaValue LuaTableSetByIndex(const struct FLuaValue& Table, const int32 Index_0, const struct FLuaValue& Value);
	static struct FLuaValue LuaTableSetField(const struct FLuaValue& Table, const class FString& Key, const struct FLuaValue& Value);
	static struct FLuaValue LuaTableSetMetaTable(const struct FLuaValue& InTable, const struct FLuaValue& InMetaTable);
	static struct FVector LuaTableToVector(const struct FLuaValue& Value);
	static TArray<struct FLuaValue> LuaTableUnpack(const struct FLuaValue& InTable);
	static int32 LuaThreadGetStackTop(const struct FLuaValue& Value);
	static ELuaThreadStatus LuaThreadGetStatus(const struct FLuaValue& Value);
	static TArray<struct FLuaValue> LuaValueArrayAppend(const TArray<struct FLuaValue>& Array, const struct FLuaValue& Value);
	static TArray<struct FLuaValue> LuaValueArrayMerge(const TArray<struct FLuaValue>& Array1, const TArray<struct FLuaValue>& Array2);
	static struct FLuaValue LuaValueCall(const struct FLuaValue& Value, const TArray<struct FLuaValue>& Args);
	static struct FLuaValue LuaValueCallIfNotNil(const struct FLuaValue& Value, const TArray<struct FLuaValue>& Args);
	static TArray<struct FLuaValue> LuaValueCallMulti(const struct FLuaValue& Value, const TArray<struct FLuaValue>& Args);
	static struct FLuaValue LuaValueFromBase64(const class FString& Base64);
	static bool LuaValueFromJson(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const class FString& Json, struct FLuaValue* Value);
	static struct FLuaValue LuaValueFromUTF16(const class FString& String);
	static struct FLuaValue LuaValueFromUTF32(const class FString& String);
	static struct FLuaValue LuaValueFromUTF8(const class FString& String);
	static TSubclassOf<class ULuaState> LuaValueGetOwner(const struct FLuaValue& Value);
	static bool LuaValueIsBoolean(const struct FLuaValue& Value);
	static bool LuaValueIsFunction(const struct FLuaValue& Value);
	static bool LuaValueIsInteger(const struct FLuaValue& Value);
	static bool LuaValueIsNil(const struct FLuaValue& Value);
	static bool LuaValueIsNotNil(const struct FLuaValue& Value);
	static bool LuaValueIsNumber(const struct FLuaValue& Value);
	static bool LuaValueIsOwned(const struct FLuaValue& Value);
	static bool LuaValueIsReferencedInLuaRegistry(const struct FLuaValue& Value);
	static bool LuaValueIsString(const struct FLuaValue& Value);
	static bool LuaValueIsTable(const struct FLuaValue& Value);
	static bool LuaValueIsThread(const struct FLuaValue& Value);
	static int32 LuaValueLength(const struct FLuaValue& Value);
	static class UClass* LuaValueLoadClass(const struct FLuaValue& Value, const bool bDetectBlueprintGeneratedClass);
	static class UObject* LuaValueLoadObject(const struct FLuaValue& Value);
	static TArray<struct FLuaValue> LuaValueResumeMulti(const struct FLuaValue& Value, const TArray<struct FLuaValue>& Args);
	static class FString LuaValueToBase64(const struct FLuaValue& Value);
	static class UClass* LuaValueToBlueprintGeneratedClass(const struct FLuaValue& Value);
	static class FString LuaValueToHexPointer(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const struct FLuaValue& Value);
	static class FString LuaValueToJson(const struct FLuaValue& Value);
	static int64 LuaValueToPointer(class UObject* WorldContextObject, TSubclassOf<class ULuaState> State, const struct FLuaValue& Value);
	static class UTexture2D* LuaValueToTransientTexture(const int32 Width, const int32 Height, const struct FLuaValue& Value, const EPixelFormat PixelFormat, bool bDetectFormat);
	static class FString LuaValueToUTF16(const struct FLuaValue& Value);
	static class FString LuaValueToUTF32(const struct FLuaValue& Value);
	static class FString LuaValueToUTF8(const struct FLuaValue& Value);
	static void LuaValueYield(const struct FLuaValue& Value, const TArray<struct FLuaValue>& Args);
	static void RegisterLuaConsoleCommand(const class FString& CommandName, const struct FLuaValue& LuaConsoleCommand);
	static void SwitchOnLuaValueType(const struct FLuaValue& LuaValue, ELuaValueType* LuaValueTypes);
	static void UnregisterLuaConsoleCommand(const class FString& CommandName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaBlueprintFunctionLibrary">();
	}
	static class ULuaBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(ULuaBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on ULuaBlueprintFunctionLibrary");
static_assert(sizeof(ULuaBlueprintFunctionLibrary) == 0x000028, "Wrong size on ULuaBlueprintFunctionLibrary");

// Class LuaMachine.LuaBlueprintPackage
// 0x0098 (0x00C0 - 0x0028)
class ULuaBlueprintPackage : public UObject
{
public:
	TMap<class FString, struct FLuaValue>         Table;                                             // 0x0028(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FLuaValue                              SelfTable;                                         // 0x0078(0x0048)(NativeAccessSpecifierPublic)

public:
	void ReceiveInit();

	TSubclassOf<class ULuaState> GetLuaState() const;
	struct FLuaValue GetSelfLuaTable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaBlueprintPackage">();
	}
	static class ULuaBlueprintPackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaBlueprintPackage>();
	}
};
static_assert(alignof(ULuaBlueprintPackage) == 0x000008, "Wrong alignment on ULuaBlueprintPackage");
static_assert(sizeof(ULuaBlueprintPackage) == 0x0000C0, "Wrong size on ULuaBlueprintPackage");
static_assert(offsetof(ULuaBlueprintPackage, Table) == 0x000028, "Member 'ULuaBlueprintPackage::Table' has a wrong offset!");
static_assert(offsetof(ULuaBlueprintPackage, SelfTable) == 0x000078, "Member 'ULuaBlueprintPackage::SelfTable' has a wrong offset!");

// Class LuaMachine.LuaMultiLineEditableTextBox
// 0x0AF8 (0x0C20 - 0x0128)
class ULuaMultiLineEditableTextBox final : public UTextLayoutWidget
{
public:
	struct FEditableTextBoxStyle                  WidgetStyle;                                       // 0x0128(0x07F8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTextBlockStyle                        CodeStyle;                                         // 0x0920(0x0270)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLinearColor                           CommentColor;                                      // 0x0B90(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           StringColor;                                       // 0x0BA0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           KeywordColor;                                      // 0x0BB0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           NilColor;                                          // 0x0BC0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BasicColor;                                        // 0x0BD0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           StdLibColor;                                       // 0x0BE0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TabSize;                                           // 0x0BF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReadOnly;                                       // 0x0BF4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHandleTab;                                        // 0x0BF5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHandleArrows;                                     // 0x0BF6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF7[0x1];                                      // 0x0BF7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLuaCustomHighlighter>          CustomTokensMapping;                               // 0x0BF8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C08[0x18];                                     // 0x0C08(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CursorGoTo(int32 Line, int32 Column);
	void MoveCursorDown();
	void MoveCursorLeft();
	void MoveCursorRight();
	void MoveCursorUp();
	void SetText(const class FText& InText);

	int32 GetCursorColumn() const;
	int32 GetCursorLine() const;
	class FText GetSelectedText() const;
	class FText GetText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaMultiLineEditableTextBox">();
	}
	static class ULuaMultiLineEditableTextBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaMultiLineEditableTextBox>();
	}
};
static_assert(alignof(ULuaMultiLineEditableTextBox) == 0x000008, "Wrong alignment on ULuaMultiLineEditableTextBox");
static_assert(sizeof(ULuaMultiLineEditableTextBox) == 0x000C20, "Wrong size on ULuaMultiLineEditableTextBox");
static_assert(offsetof(ULuaMultiLineEditableTextBox, WidgetStyle) == 0x000128, "Member 'ULuaMultiLineEditableTextBox::WidgetStyle' has a wrong offset!");
static_assert(offsetof(ULuaMultiLineEditableTextBox, CodeStyle) == 0x000920, "Member 'ULuaMultiLineEditableTextBox::CodeStyle' has a wrong offset!");
static_assert(offsetof(ULuaMultiLineEditableTextBox, CommentColor) == 0x000B90, "Member 'ULuaMultiLineEditableTextBox::CommentColor' has a wrong offset!");
static_assert(offsetof(ULuaMultiLineEditableTextBox, StringColor) == 0x000BA0, "Member 'ULuaMultiLineEditableTextBox::StringColor' has a wrong offset!");
static_assert(offsetof(ULuaMultiLineEditableTextBox, KeywordColor) == 0x000BB0, "Member 'ULuaMultiLineEditableTextBox::KeywordColor' has a wrong offset!");
static_assert(offsetof(ULuaMultiLineEditableTextBox, NilColor) == 0x000BC0, "Member 'ULuaMultiLineEditableTextBox::NilColor' has a wrong offset!");
static_assert(offsetof(ULuaMultiLineEditableTextBox, BasicColor) == 0x000BD0, "Member 'ULuaMultiLineEditableTextBox::BasicColor' has a wrong offset!");
static_assert(offsetof(ULuaMultiLineEditableTextBox, StdLibColor) == 0x000BE0, "Member 'ULuaMultiLineEditableTextBox::StdLibColor' has a wrong offset!");
static_assert(offsetof(ULuaMultiLineEditableTextBox, TabSize) == 0x000BF0, "Member 'ULuaMultiLineEditableTextBox::TabSize' has a wrong offset!");
static_assert(offsetof(ULuaMultiLineEditableTextBox, bIsReadOnly) == 0x000BF4, "Member 'ULuaMultiLineEditableTextBox::bIsReadOnly' has a wrong offset!");
static_assert(offsetof(ULuaMultiLineEditableTextBox, bHandleTab) == 0x000BF5, "Member 'ULuaMultiLineEditableTextBox::bHandleTab' has a wrong offset!");
static_assert(offsetof(ULuaMultiLineEditableTextBox, bHandleArrows) == 0x000BF6, "Member 'ULuaMultiLineEditableTextBox::bHandleArrows' has a wrong offset!");
static_assert(offsetof(ULuaMultiLineEditableTextBox, CustomTokensMapping) == 0x000BF8, "Member 'ULuaMultiLineEditableTextBox::CustomTokensMapping' has a wrong offset!");

// Class LuaMachine.LuaCode
// 0x0038 (0x0068 - 0x0030)
class ULuaCode final : public UDataAsset
{
public:
	class FText                                   Code;                                              // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bCookAsBytecode;                                   // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 ByteCode;                                          // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCooked;                                           // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaCode">();
	}
	static class ULuaCode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaCode>();
	}
};
static_assert(alignof(ULuaCode) == 0x000008, "Wrong alignment on ULuaCode");
static_assert(sizeof(ULuaCode) == 0x000068, "Wrong size on ULuaCode");
static_assert(offsetof(ULuaCode, Code) == 0x000030, "Member 'ULuaCode::Code' has a wrong offset!");
static_assert(offsetof(ULuaCode, bCookAsBytecode) == 0x000048, "Member 'ULuaCode::bCookAsBytecode' has a wrong offset!");
static_assert(offsetof(ULuaCode, ByteCode) == 0x000050, "Member 'ULuaCode::ByteCode' has a wrong offset!");
static_assert(offsetof(ULuaCode, bCooked) == 0x000060, "Member 'ULuaCode::bCooked' has a wrong offset!");

// Class LuaMachine.LuaState
// 0x02C8 (0x02F0 - 0x0028)
class alignas(0x10) ULuaState : public UObject
{
public:
	class ULuaCode*                               LuaCodeAsset;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LuaFilename;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FLuaValue>         Table;                                             // 0x0040(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FString, TSubclassOf<class ULuaBlueprintPackage>> LuaBlueprintPackagesTable;          // 0x0090(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FString, class ULuaCode*>          RequireTable;                                      // 0x00E0(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bLuaOpenLibs;                                      // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLuaLibsLoader                         LuaLibsLoader;                                     // 0x0131(0x0009)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAddProjectContentDirToPackagePath;                // 0x013A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13B[0x5];                                      // 0x013B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         AppendProjectContentDirSubDir;                     // 0x0140(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 OverridePackagePath;                               // 0x0150(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OverridePackageCPath;                              // 0x0160(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULuaCode*                               UserDataMetaTableFromCodeAsset;                    // 0x0170(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLogError;                                         // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x0179(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLineHook;                                   // 0x017A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCallHook;                                   // 0x017B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableReturnHook;                                 // 0x017C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class ULuaBlueprintPackage*> LuaBlueprintPackages;                           // 0x0180(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0x10];                                     // 0x01D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULuaUserDataObject*>             TrackedLuaUserDataObjects;                         // 0x01E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0[0x30];                                     // 0x01F0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRawLuaFunctionCall;                               // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x6F];                                     // 0x0221(0x006F)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class UObject>, struct FLuaDelegateGroup> LuaDelegatesMap;                   // 0x0290(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<uint8> ToByteCode(const class FString& Code, const class FString& CodePath, class FString* ErrorString);

	struct FLuaValue GetLuaBlueprintPackageTable(const class FString& PackageName);
	struct FLuaValue GetLuaUserDataField(const struct FLuaValue& UserData, const class FString& Key);
	struct FLuaValue GetLuaValueFromProperty(class UObject* InObject, const class FString& PropertyName);
	struct FLuaDebug LuaGetInfo(const int32 Level);
	TMap<class FString, struct FLuaValue> LuaGetLocals(const int32 Level);
	struct FLuaValue NewLuaUserDataObject(TSubclassOf<class ULuaUserDataObject> LuaUserDataObjectClass, bool bTrackObject);
	void ReceiveLuaCallHook(const struct FLuaDebug& LuaDebug);
	void ReceiveLuaError(const class FString& Message);
	void ReceiveLuaLevelAddedToWorld(class ULevel* Level, class UWorld* World);
	void ReceiveLuaLevelRemovedFromWorld(class ULevel* Level, class UWorld* World);
	void ReceiveLuaLineHook(const struct FLuaDebug& LuaDebug);
	void ReceiveLuaReturnHook(const struct FLuaDebug& LuaDebug);
	void ReceiveLuaStateInitialized();
	void ReceiveLuaStatePreInitialized();
	void SetLuaUserDataField(const struct FLuaValue& UserData, const class FString& Key, const struct FLuaValue& Value);
	bool SetPropertyFromLuaValue(class UObject* InObject, const class FString& PropertyName, const struct FLuaValue& Value);
	struct FLuaValue StructToLuaTable(class UScriptStruct* InScriptStruct, const TArray<uint8>& StructData);

	TSubclassOf<class ULuaState> GetSelfLuaState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaState">();
	}
	static class ULuaState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaState>();
	}
};
static_assert(alignof(ULuaState) == 0x000010, "Wrong alignment on ULuaState");
static_assert(sizeof(ULuaState) == 0x0002F0, "Wrong size on ULuaState");
static_assert(offsetof(ULuaState, LuaCodeAsset) == 0x000028, "Member 'ULuaState::LuaCodeAsset' has a wrong offset!");
static_assert(offsetof(ULuaState, LuaFilename) == 0x000030, "Member 'ULuaState::LuaFilename' has a wrong offset!");
static_assert(offsetof(ULuaState, Table) == 0x000040, "Member 'ULuaState::Table' has a wrong offset!");
static_assert(offsetof(ULuaState, LuaBlueprintPackagesTable) == 0x000090, "Member 'ULuaState::LuaBlueprintPackagesTable' has a wrong offset!");
static_assert(offsetof(ULuaState, RequireTable) == 0x0000E0, "Member 'ULuaState::RequireTable' has a wrong offset!");
static_assert(offsetof(ULuaState, bLuaOpenLibs) == 0x000130, "Member 'ULuaState::bLuaOpenLibs' has a wrong offset!");
static_assert(offsetof(ULuaState, LuaLibsLoader) == 0x000131, "Member 'ULuaState::LuaLibsLoader' has a wrong offset!");
static_assert(offsetof(ULuaState, bAddProjectContentDirToPackagePath) == 0x00013A, "Member 'ULuaState::bAddProjectContentDirToPackagePath' has a wrong offset!");
static_assert(offsetof(ULuaState, AppendProjectContentDirSubDir) == 0x000140, "Member 'ULuaState::AppendProjectContentDirSubDir' has a wrong offset!");
static_assert(offsetof(ULuaState, OverridePackagePath) == 0x000150, "Member 'ULuaState::OverridePackagePath' has a wrong offset!");
static_assert(offsetof(ULuaState, OverridePackageCPath) == 0x000160, "Member 'ULuaState::OverridePackageCPath' has a wrong offset!");
static_assert(offsetof(ULuaState, UserDataMetaTableFromCodeAsset) == 0x000170, "Member 'ULuaState::UserDataMetaTableFromCodeAsset' has a wrong offset!");
static_assert(offsetof(ULuaState, bLogError) == 0x000178, "Member 'ULuaState::bLogError' has a wrong offset!");
static_assert(offsetof(ULuaState, bPersistent) == 0x000179, "Member 'ULuaState::bPersistent' has a wrong offset!");
static_assert(offsetof(ULuaState, bEnableLineHook) == 0x00017A, "Member 'ULuaState::bEnableLineHook' has a wrong offset!");
static_assert(offsetof(ULuaState, bEnableCallHook) == 0x00017B, "Member 'ULuaState::bEnableCallHook' has a wrong offset!");
static_assert(offsetof(ULuaState, bEnableReturnHook) == 0x00017C, "Member 'ULuaState::bEnableReturnHook' has a wrong offset!");
static_assert(offsetof(ULuaState, LuaBlueprintPackages) == 0x000180, "Member 'ULuaState::LuaBlueprintPackages' has a wrong offset!");
static_assert(offsetof(ULuaState, TrackedLuaUserDataObjects) == 0x0001E0, "Member 'ULuaState::TrackedLuaUserDataObjects' has a wrong offset!");
static_assert(offsetof(ULuaState, bRawLuaFunctionCall) == 0x000220, "Member 'ULuaState::bRawLuaFunctionCall' has a wrong offset!");
static_assert(offsetof(ULuaState, LuaDelegatesMap) == 0x000290, "Member 'ULuaState::LuaDelegatesMap' has a wrong offset!");

// Class LuaMachine.LuaComponent
// 0x00C0 (0x0170 - 0x00B0)
class ULuaComponent : public UActorComponent
{
public:
	TSubclassOf<class ULuaState>                  LuaState;                                          // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FLuaValue>         Table;                                             // 0x00B8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, struct FLuaValue>         MetaTable;                                         // 0x0108(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bLazy;                                             // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLogError;                                         // 0x0159(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImplicitSelf;                                     // 0x015A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15B[0x5];                                      // 0x015B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FString& Message)> OnLuaError;                         // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	struct FLuaValue LuaCallFunction(const class FString& Name_0, const TArray<struct FLuaValue>& Args, bool bGlobal);
	TArray<struct FLuaValue> LuaCallFunctionMulti(const class FString& Name_0, const TArray<struct FLuaValue>& Args, bool bGlobal);
	struct FLuaValue LuaCallTableIndex(const struct FLuaValue& InTable, int32 Index_0, const TArray<struct FLuaValue>& Args);
	TArray<struct FLuaValue> LuaCallTableIndexMulti(const struct FLuaValue& InTable, int32 Index_0, const TArray<struct FLuaValue>& Args);
	struct FLuaValue LuaCallTableKey(const struct FLuaValue& InTable, const class FString& Key, const TArray<struct FLuaValue>& Args);
	TArray<struct FLuaValue> LuaCallTableKeyMulti(const struct FLuaValue& InTable, const class FString& Key, const TArray<struct FLuaValue>& Args);
	struct FLuaValue LuaCallValue(const struct FLuaValue& Value, const TArray<struct FLuaValue>& Args);
	struct FLuaValue LuaCallValueIfNotNil(const struct FLuaValue& Value, const TArray<struct FLuaValue>& Args);
	TArray<struct FLuaValue> LuaCallValueMulti(const struct FLuaValue& Value, const TArray<struct FLuaValue>& Args);
	TArray<struct FLuaValue> LuaCallValueMultiIfNotNil(const struct FLuaValue& Value, const TArray<struct FLuaValue>& Args);
	class ULuaState* LuaComponentGetState();
	struct FLuaValue LuaGetField(const class FString& Name_0);
	void LuaSetField(const class FString& Name_0, const struct FLuaValue& Value);
	struct FLuaValue ReceiveLuaMetaIndex(const struct FLuaValue& Key);
	bool ReceiveLuaMetaNewIndex(const struct FLuaValue& Key, const struct FLuaValue& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaComponent">();
	}
	static class ULuaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaComponent>();
	}
};
static_assert(alignof(ULuaComponent) == 0x000008, "Wrong alignment on ULuaComponent");
static_assert(sizeof(ULuaComponent) == 0x000170, "Wrong size on ULuaComponent");
static_assert(offsetof(ULuaComponent, LuaState) == 0x0000B0, "Member 'ULuaComponent::LuaState' has a wrong offset!");
static_assert(offsetof(ULuaComponent, Table) == 0x0000B8, "Member 'ULuaComponent::Table' has a wrong offset!");
static_assert(offsetof(ULuaComponent, MetaTable) == 0x000108, "Member 'ULuaComponent::MetaTable' has a wrong offset!");
static_assert(offsetof(ULuaComponent, bLazy) == 0x000158, "Member 'ULuaComponent::bLazy' has a wrong offset!");
static_assert(offsetof(ULuaComponent, bLogError) == 0x000159, "Member 'ULuaComponent::bLogError' has a wrong offset!");
static_assert(offsetof(ULuaComponent, bImplicitSelf) == 0x00015A, "Member 'ULuaComponent::bImplicitSelf' has a wrong offset!");
static_assert(offsetof(ULuaComponent, OnLuaError) == 0x000160, "Member 'ULuaComponent::OnLuaError' has a wrong offset!");

// Class LuaMachine.LuaDelegate
// 0x0058 (0x0080 - 0x0028)
class ULuaDelegate final : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LuaDelegateFunction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaDelegate">();
	}
	static class ULuaDelegate* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaDelegate>();
	}
};
static_assert(alignof(ULuaDelegate) == 0x000008, "Wrong alignment on ULuaDelegate");
static_assert(sizeof(ULuaDelegate) == 0x000080, "Wrong size on ULuaDelegate");

// Class LuaMachine.LuaGlobalNameComponent
// 0x0018 (0x00C8 - 0x00B0)
class ULuaGlobalNameComponent final : public UActorComponent
{
public:
	TSubclassOf<class ULuaState>                  LuaState;                                          // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LuaGlobalName;                                     // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaGlobalNameComponent">();
	}
	static class ULuaGlobalNameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaGlobalNameComponent>();
	}
};
static_assert(alignof(ULuaGlobalNameComponent) == 0x000008, "Wrong alignment on ULuaGlobalNameComponent");
static_assert(sizeof(ULuaGlobalNameComponent) == 0x0000C8, "Wrong size on ULuaGlobalNameComponent");
static_assert(offsetof(ULuaGlobalNameComponent, LuaState) == 0x0000B0, "Member 'ULuaGlobalNameComponent::LuaState' has a wrong offset!");
static_assert(offsetof(ULuaGlobalNameComponent, LuaGlobalName) == 0x0000B8, "Member 'ULuaGlobalNameComponent::LuaGlobalName' has a wrong offset!");

// Class LuaMachine.LuaTableAsset
// 0x0050 (0x0080 - 0x0030)
class ULuaTableAsset final : public UDataAsset
{
public:
	TMap<class FString, struct FLuaValue>         Table;                                             // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaTableAsset">();
	}
	static class ULuaTableAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaTableAsset>();
	}
};
static_assert(alignof(ULuaTableAsset) == 0x000008, "Wrong alignment on ULuaTableAsset");
static_assert(sizeof(ULuaTableAsset) == 0x000080, "Wrong size on ULuaTableAsset");
static_assert(offsetof(ULuaTableAsset, Table) == 0x000030, "Member 'ULuaTableAsset::Table' has a wrong offset!");

// Class LuaMachine.LuaUserDataObject
// 0x00A8 (0x00D0 - 0x0028)
class ULuaUserDataObject final : public UObject
{
public:
	TMap<class FString, struct FLuaValue>         Table;                                             // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FString, struct FLuaValue>         MetaTable;                                         // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bImplicitSelf;                                     // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FString> GetObjectUFunctions(bool bOnlyPublic);
	struct FLuaValue LuaCallFunction(const class FString& Name_0, const TArray<struct FLuaValue>& Args, bool bGlobal);
	struct FLuaValue LuaGetField(const class FString& Name_0);
	void LuaSetField(const class FString& Name_0, const struct FLuaValue& Value);
	void ReceiveLuaGC();
	struct FLuaValue ReceiveLuaMetaIndex(const struct FLuaValue& Key);
	void ReceiveLuaUserDataTableInit();
	struct FLuaValue UFunctionToLuaValue(const class FString& FunctionName);

	TSubclassOf<class ULuaState> GetLuaState() const;
	class ULuaState* GetLuaStateInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaUserDataObject">();
	}
	static class ULuaUserDataObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaUserDataObject>();
	}
};
static_assert(alignof(ULuaUserDataObject) == 0x000008, "Wrong alignment on ULuaUserDataObject");
static_assert(sizeof(ULuaUserDataObject) == 0x0000D0, "Wrong size on ULuaUserDataObject");
static_assert(offsetof(ULuaUserDataObject, Table) == 0x000028, "Member 'ULuaUserDataObject::Table' has a wrong offset!");
static_assert(offsetof(ULuaUserDataObject, MetaTable) == 0x000078, "Member 'ULuaUserDataObject::MetaTable' has a wrong offset!");
static_assert(offsetof(ULuaUserDataObject, bImplicitSelf) == 0x0000C8, "Member 'ULuaUserDataObject::bImplicitSelf' has a wrong offset!");

}

