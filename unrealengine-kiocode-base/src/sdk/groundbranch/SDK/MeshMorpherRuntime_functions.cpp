#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MeshMorpherRuntime

#include "Basic.hpp"

#include "MeshMorpherRuntime_classes.hpp"
#include "MeshMorpherRuntime_parameters.hpp"


namespace SDK
{

// Function MeshMorpherRuntime.MeshMorpherRuntimeLibrary.DoBakeMultiple
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    SkeletalMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<class UMorphTarget*, float>& MorphTargets                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EMeshMorpherBakeBranches*               Out                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshMorpherRuntimeLibrary::DoBakeMultiple(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USkeletalMesh* SkeletalMesh, const TMap<class UMorphTarget*, float>& MorphTargets, EMeshMorpherBakeBranches* Out)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MeshMorpherRuntimeLibrary", "DoBakeMultiple");

	Params::MeshMorpherRuntimeLibrary_DoBakeMultiple Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.SkeletalMesh = SkeletalMesh;
	Parms.MorphTargets = std::move(MorphTargets);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out != nullptr)
		*Out = Parms.Out;
}


// Function MeshMorpherRuntime.MeshMorpherRuntimeLibrary.DoBakeMultipleStandalone
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    SkeletalMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<class UStandaloneMorphTarget*, float>&MorphTargets                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EMeshMorpherBakeBranches*               Out                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshMorpherRuntimeLibrary::DoBakeMultipleStandalone(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USkeletalMesh* SkeletalMesh, const TMap<class UStandaloneMorphTarget*, float>& MorphTargets, EMeshMorpherBakeBranches* Out)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MeshMorpherRuntimeLibrary", "DoBakeMultipleStandalone");

	Params::MeshMorpherRuntimeLibrary_DoBakeMultipleStandalone Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.SkeletalMesh = SkeletalMesh;
	Parms.MorphTargets = std::move(MorphTargets);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out != nullptr)
		*Out = Parms.Out;
}


// Function MeshMorpherRuntime.MeshMorpherRuntimeLibrary.DoBakeSingle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    SkeletalMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMorphTarget*                     MorphTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMeshMorpherBakeBranches*               Out                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshMorpherRuntimeLibrary::DoBakeSingle(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USkeletalMesh* SkeletalMesh, class UMorphTarget* MorphTarget, float Weight, EMeshMorpherBakeBranches* Out)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MeshMorpherRuntimeLibrary", "DoBakeSingle");

	Params::MeshMorpherRuntimeLibrary_DoBakeSingle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.SkeletalMesh = SkeletalMesh;
	Parms.MorphTarget = MorphTarget;
	Parms.Weight = Weight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out != nullptr)
		*Out = Parms.Out;
}


// Function MeshMorpherRuntime.MeshMorpherRuntimeLibrary.DoBakeSingleStandalone
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    SkeletalMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStandaloneMorphTarget*           MorphTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMeshMorpherBakeBranches*               Out                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshMorpherRuntimeLibrary::DoBakeSingleStandalone(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USkeletalMesh* SkeletalMesh, class UStandaloneMorphTarget* MorphTarget, float Weight, EMeshMorpherBakeBranches* Out)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MeshMorpherRuntimeLibrary", "DoBakeSingleStandalone");

	Params::MeshMorpherRuntimeLibrary_DoBakeSingleStandalone Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.SkeletalMesh = SkeletalMesh;
	Parms.MorphTarget = MorphTarget;
	Parms.Weight = Weight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out != nullptr)
		*Out = Parms.Out;
}


// Function MeshMorpherRuntime.MeshMorpherRuntimeLibrary.FindMorphTarget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMesh*                    SkeletalMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMorphTarget*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMorphTarget* UMeshMorpherRuntimeLibrary::FindMorphTarget(class USkeletalMesh* SkeletalMesh, class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MeshMorpherRuntimeLibrary", "FindMorphTarget");

	Params::MeshMorpherRuntimeLibrary_FindMorphTarget Parms{};

	Parms.SkeletalMesh = SkeletalMesh;
	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MeshMorpherRuntime.MeshMorpherRuntimeLibrary.GetMorphTargetsNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMesh*                    SkeletalMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    Names                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMeshMorpherRuntimeLibrary::GetMorphTargetsNames(class USkeletalMesh* SkeletalMesh, TArray<class FName>* Names)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MeshMorpherRuntimeLibrary", "GetMorphTargetsNames");

	Params::MeshMorpherRuntimeLibrary_GetMorphTargetsNames Parms{};

	Parms.SkeletalMesh = SkeletalMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Names != nullptr)
		*Names = std::move(Parms.Names);
}


// Function MeshMorpherRuntime.MeshMorpherRuntimeLibrary.RemoveMorphTarget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMesh*                    SkeletalMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMeshMorpherRuntimeLibrary::RemoveMorphTarget(class USkeletalMesh* SkeletalMesh, class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MeshMorpherRuntimeLibrary", "RemoveMorphTarget");

	Params::MeshMorpherRuntimeLibrary_RemoveMorphTarget Parms{};

	Parms.SkeletalMesh = SkeletalMesh;
	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MeshMorpherRuntime.MeshMorpherWorkerLibrary.Cancel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMeshMorpherWorkerRef&           WorkerReference                                        (Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bIsSuccess                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshMorpherWorkerLibrary::Cancel(class UObject* WorldContextObject, struct FMeshMorpherWorkerRef& WorkerReference, bool* bIsSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MeshMorpherWorkerLibrary", "Cancel");

	Params::MeshMorpherWorkerLibrary_Cancel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorkerReference = std::move(WorkerReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	WorkerReference = std::move(Parms.WorkerReference);

	if (bIsSuccess != nullptr)
		*bIsSuccess = Parms.bIsSuccess;
}


// Function MeshMorpherRuntime.MeshMorpherWorkerLibrary.IsCanceled
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMeshMorpherWorkerRef&     WorkerReference                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMeshMorpherWorkerLibrary::IsCanceled(class UObject* WorldContextObject, const struct FMeshMorpherWorkerRef& WorkerReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MeshMorpherWorkerLibrary", "IsCanceled");

	Params::MeshMorpherWorkerLibrary_IsCanceled Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorkerReference = std::move(WorkerReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MeshMorpherRuntime.MeshMorpherWorkerLibrary.IsRunning
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMeshMorpherWorkerRef&     WorkerReference                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMeshMorpherWorkerLibrary::IsRunning(class UObject* WorldContextObject, const struct FMeshMorpherWorkerRef& WorkerReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MeshMorpherWorkerLibrary", "IsRunning");

	Params::MeshMorpherWorkerLibrary_IsRunning Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorkerReference = std::move(WorkerReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MeshMorpherRuntime.MeshMorpherWorkerLibrary.IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMeshMorpherWorkerRef&     WorkerReference                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMeshMorpherWorkerLibrary::IsValid(class UObject* WorldContextObject, const struct FMeshMorpherWorkerRef& WorkerReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MeshMorpherWorkerLibrary", "IsValid");

	Params::MeshMorpherWorkerLibrary_IsValid Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorkerReference = std::move(WorkerReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MeshMorpherRuntime.MeshMorpherWorkerLibrary.WaitToFinish
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMeshMorpherWorkerRef&     WorkerReference                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshMorpherWorkerLibrary::WaitToFinish(class UObject* WorldContextObject, const struct FMeshMorpherWorkerRef& WorkerReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MeshMorpherWorkerLibrary", "WaitToFinish");

	Params::MeshMorpherWorkerLibrary_WaitToFinish Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorkerReference = std::move(WorkerReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

