#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: LXR

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "LXR_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class LXR.LXRSense
// 0x0000 (0x0000 - 0x0000)
class ILXRSense final
{
public:
	void GetLightSenseTraceLocationAndDirection(struct FVector* Location, struct FRotator* Rotator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LXRSense">();
	}
	static class ILXRSense* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILXRSense>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILXRSense) == 0x000001, "Wrong alignment on ILXRSense");
static_assert(sizeof(ILXRSense) == 0x000001, "Wrong size on ILXRSense");

// Class LXR.LXRSource
// 0x0000 (0x0000 - 0x0000)
class ILXRSource final
{
public:
	ELightState GetLightActorState();
	ELightState GetLightComponentState(const class ULightComponent* LightComponent);
	TArray<class ULightComponent*> GetMyLightComponents();
	bool IsEnabled();
	bool IsLightComponentEnabled(const class ULightComponent* LightComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LXRSource">();
	}
	static class ILXRSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILXRSource>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILXRSource) == 0x000001, "Wrong alignment on ILXRSource");
static_assert(sizeof(ILXRSource) == 0x000001, "Wrong size on ILXRSource");

// Class LXR.LXRDetectionComponent
// 0x0490 (0x0540 - 0x00B0)
class alignas(0x10) ULXRDetectionComponent : public UActorComponent
{
public:
	bool                                          bDrawDebug;                                        // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrintDebug;                                       // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugRelevantAndPassed;                           // 0x00B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugOctreeLights;                                // 0x00B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugSensing;                                     // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugDrawTime;                                     // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugVectorArray;                                 // 0x00BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           TargetSockets;                                     // 0x00C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        TargetVectors;                                     // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAddToSourceWhenDetected;                          // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetIlluminatedTargets;                            // 0x00E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x2];                                       // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ERelevancyCheckType                           RelevancyCheckType;                                // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelevancySmartDistanceMin;                         // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelevancySmartDistanceMax;                         // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelevancySmartCheckRateDivider;                    // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelevancyCheckRate;                                // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RelevancyOctreeCheckBoundsSize;                    // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RelevancyLightBatchCount;                          // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLocationChange;                                // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RelevancyLocationThreshold;                        // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x4];                                      // 0x0108(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ETraceTarget                                  RelevancyTargetType;                               // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetsRequired;                                   // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERelevantTraceType                            RelevantTraceType;                                 // 0x0114(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ETraceTarget                                  RelevantTargetType;                                // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelevantLightCheckRate;                            // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RelevantLightBatchCount;                           // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0124(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TracesRequired;                                    // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxConsecutiveFails;                               // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CombinedLXRColor;                                  // 0x0130(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombinedLXRIntensity;                              // 0x0140(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         IgnoreVisibilityActors;                            // 0x0148(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FLinearColor>              IlluminatedTargets;                                // 0x0158(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class ULXRLightSenseComponent*                SenseComponent;                                    // 0x01A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULXRMemoryComponent*                    MemoryComponent;                                   // 0x01B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULXRSubsystem*                          LXRSubsystem;                                      // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x320];                                    // 0x01C0(0x0320)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class AActor>, int32>     RelevantLightsFailCounts;                          // 0x04E0(0x0050)(NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkyLightComponent*                     SkyLight;                                          // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DelayedInit();

	TArray<struct FVector> GetRelevantTraceTypeTargets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LXRDetectionComponent">();
	}
	static class ULXRDetectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULXRDetectionComponent>();
	}
};
static_assert(alignof(ULXRDetectionComponent) == 0x000010, "Wrong alignment on ULXRDetectionComponent");
static_assert(sizeof(ULXRDetectionComponent) == 0x000540, "Wrong size on ULXRDetectionComponent");
static_assert(offsetof(ULXRDetectionComponent, bDrawDebug) == 0x0000B0, "Member 'ULXRDetectionComponent::bDrawDebug' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, bPrintDebug) == 0x0000B1, "Member 'ULXRDetectionComponent::bPrintDebug' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, bDebugRelevantAndPassed) == 0x0000B2, "Member 'ULXRDetectionComponent::bDebugRelevantAndPassed' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, bDebugOctreeLights) == 0x0000B3, "Member 'ULXRDetectionComponent::bDebugOctreeLights' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, bDebugSensing) == 0x0000B4, "Member 'ULXRDetectionComponent::bDebugSensing' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, DebugDrawTime) == 0x0000B8, "Member 'ULXRDetectionComponent::DebugDrawTime' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, bDebugVectorArray) == 0x0000BC, "Member 'ULXRDetectionComponent::bDebugVectorArray' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, TargetSockets) == 0x0000C0, "Member 'ULXRDetectionComponent::TargetSockets' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, TargetVectors) == 0x0000D0, "Member 'ULXRDetectionComponent::TargetVectors' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, bAddToSourceWhenDetected) == 0x0000E0, "Member 'ULXRDetectionComponent::bAddToSourceWhenDetected' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, bGetIlluminatedTargets) == 0x0000E1, "Member 'ULXRDetectionComponent::bGetIlluminatedTargets' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, RelevancyCheckType) == 0x0000E4, "Member 'ULXRDetectionComponent::RelevancyCheckType' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, RelevancySmartDistanceMin) == 0x0000E8, "Member 'ULXRDetectionComponent::RelevancySmartDistanceMin' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, RelevancySmartDistanceMax) == 0x0000EC, "Member 'ULXRDetectionComponent::RelevancySmartDistanceMax' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, RelevancySmartCheckRateDivider) == 0x0000F0, "Member 'ULXRDetectionComponent::RelevancySmartCheckRateDivider' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, RelevancyCheckRate) == 0x0000F4, "Member 'ULXRDetectionComponent::RelevancyCheckRate' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, RelevancyOctreeCheckBoundsSize) == 0x0000F8, "Member 'ULXRDetectionComponent::RelevancyOctreeCheckBoundsSize' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, RelevancyLightBatchCount) == 0x0000FC, "Member 'ULXRDetectionComponent::RelevancyLightBatchCount' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, bUseLocationChange) == 0x000100, "Member 'ULXRDetectionComponent::bUseLocationChange' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, RelevancyLocationThreshold) == 0x000104, "Member 'ULXRDetectionComponent::RelevancyLocationThreshold' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, RelevancyTargetType) == 0x00010C, "Member 'ULXRDetectionComponent::RelevancyTargetType' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, TargetsRequired) == 0x000110, "Member 'ULXRDetectionComponent::TargetsRequired' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, RelevantTraceType) == 0x000114, "Member 'ULXRDetectionComponent::RelevantTraceType' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, RelevantTargetType) == 0x000118, "Member 'ULXRDetectionComponent::RelevantTargetType' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, RelevantLightCheckRate) == 0x00011C, "Member 'ULXRDetectionComponent::RelevantLightCheckRate' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, RelevantLightBatchCount) == 0x000120, "Member 'ULXRDetectionComponent::RelevantLightBatchCount' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, TraceChannel) == 0x000124, "Member 'ULXRDetectionComponent::TraceChannel' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, TracesRequired) == 0x000128, "Member 'ULXRDetectionComponent::TracesRequired' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, MaxConsecutiveFails) == 0x00012C, "Member 'ULXRDetectionComponent::MaxConsecutiveFails' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, CombinedLXRColor) == 0x000130, "Member 'ULXRDetectionComponent::CombinedLXRColor' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, CombinedLXRIntensity) == 0x000140, "Member 'ULXRDetectionComponent::CombinedLXRIntensity' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, IgnoreVisibilityActors) == 0x000148, "Member 'ULXRDetectionComponent::IgnoreVisibilityActors' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, IlluminatedTargets) == 0x000158, "Member 'ULXRDetectionComponent::IlluminatedTargets' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, SenseComponent) == 0x0001A8, "Member 'ULXRDetectionComponent::SenseComponent' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, MemoryComponent) == 0x0001B0, "Member 'ULXRDetectionComponent::MemoryComponent' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, LXRSubsystem) == 0x0001B8, "Member 'ULXRDetectionComponent::LXRSubsystem' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, RelevantLightsFailCounts) == 0x0004E0, "Member 'ULXRDetectionComponent::RelevantLightsFailCounts' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, SkeletalMeshComponent) == 0x000530, "Member 'ULXRDetectionComponent::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ULXRDetectionComponent, SkyLight) == 0x000538, "Member 'ULXRDetectionComponent::SkyLight' has a wrong offset!");

// Class LXR.LXRFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class ULXRFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FLinearColor ClampTo01Range(const struct FLinearColor& InColor);
	static bool ColorApproximatelyEqualColor(const struct FLinearColor& InColorOne, const struct FLinearColor& InColorTwo);
	static bool ColorEqual_DominantColor(const struct FLinearColor& Color, const struct FDominantColor& DominantColor);
	static bool ColorRemappedRoundedHalfEqualColor(const struct FLinearColor& InColorOne, const struct FLinearColor& InColorTwo);
	static struct FLinearColor DominantToLinearColor(const struct FDominantColor& InDominantColor);
	static bool Equal_FDominantColor(const struct FDominantColor& FirstColor, const struct FDominantColor& SecondColor);
	static struct FDominantColor GetDominantColor(const struct FLinearColor& InColor);
	static struct FLinearColor GetInverseChannels(const struct FLinearColor& InColor);
	static struct FLinearColor GetLinearColorArrayAverage(const TArray<struct FLinearColor>& InColors);
	static float GetMaxOfColorChannels(const struct FLinearColor& InColor);
	static float GetMinOfColorChannels(const struct FLinearColor& InColor);
	static struct FDominantColor GetSecondDominantColor(const struct FLinearColor& InColor);
	static struct FLinearColor RemapColorRangeTo01(const struct FLinearColor& InColor);
	static struct FLinearColor RoundToNearestHalf(const struct FLinearColor& InColor);
	static struct FLinearColor ToggleColorChannels(const struct FLinearColor& InColor, const struct FLinearColor& ToggleChannels);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LXRFunctionLibrary">();
	}
	static class ULXRFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULXRFunctionLibrary>();
	}
};
static_assert(alignof(ULXRFunctionLibrary) == 0x000008, "Wrong alignment on ULXRFunctionLibrary");
static_assert(sizeof(ULXRFunctionLibrary) == 0x000028, "Wrong size on ULXRFunctionLibrary");

// Class LXR.LXRLightSenseComponent
// 0x0230 (0x02E0 - 0x00B0)
class alignas(0x10) ULXRLightSenseComponent final : public UActorComponent
{
public:
	bool                                          bDrawDebug;                                        // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ESenseTraceTransform                          SenseTraceTransform;                               // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERelevantTraceType                            RelevantTraceType;                                 // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckRate;                                         // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConeTraces;                                        // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConeAngle;                                         // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DistancePerSegment;                                // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SenseDistance;                                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinDistancePerTarget;                              // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxConeTraceTargetsPerSegment;                     // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TraceTargetBatchCount;                             // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetsRequired;                                   // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CombinedLXRColor;                                  // 0x00E4(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombinedLXRIntensity;                              // 0x00F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x1C8];                                     // 0x00F8(0x01C8)(Fixing Size After Last Property [ Dumper-7 ])
	class ULXRDetectionComponent*                 OwnerDetectionComponent;                           // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AActor>>          SensedLightsToRemove;                              // 0x02C8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class AActor*> GetSensedActors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LXRLightSenseComponent">();
	}
	static class ULXRLightSenseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULXRLightSenseComponent>();
	}
};
static_assert(alignof(ULXRLightSenseComponent) == 0x000010, "Wrong alignment on ULXRLightSenseComponent");
static_assert(sizeof(ULXRLightSenseComponent) == 0x0002E0, "Wrong size on ULXRLightSenseComponent");
static_assert(offsetof(ULXRLightSenseComponent, bDrawDebug) == 0x0000B0, "Member 'ULXRLightSenseComponent::bDrawDebug' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, bIsEnabled) == 0x0000B1, "Member 'ULXRLightSenseComponent::bIsEnabled' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, SenseTraceTransform) == 0x0000B4, "Member 'ULXRLightSenseComponent::SenseTraceTransform' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, RelevantTraceType) == 0x0000B8, "Member 'ULXRLightSenseComponent::RelevantTraceType' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, CheckRate) == 0x0000BC, "Member 'ULXRLightSenseComponent::CheckRate' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, ConeTraces) == 0x0000C0, "Member 'ULXRLightSenseComponent::ConeTraces' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, ConeAngle) == 0x0000C4, "Member 'ULXRLightSenseComponent::ConeAngle' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, DistancePerSegment) == 0x0000C8, "Member 'ULXRLightSenseComponent::DistancePerSegment' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, SenseDistance) == 0x0000CC, "Member 'ULXRLightSenseComponent::SenseDistance' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, MinDistancePerTarget) == 0x0000D0, "Member 'ULXRLightSenseComponent::MinDistancePerTarget' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, MaxConeTraceTargetsPerSegment) == 0x0000D4, "Member 'ULXRLightSenseComponent::MaxConeTraceTargetsPerSegment' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, TraceTargetBatchCount) == 0x0000D8, "Member 'ULXRLightSenseComponent::TraceTargetBatchCount' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, TargetsRequired) == 0x0000DC, "Member 'ULXRLightSenseComponent::TargetsRequired' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, TraceChannel) == 0x0000E0, "Member 'ULXRLightSenseComponent::TraceChannel' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, CombinedLXRColor) == 0x0000E4, "Member 'ULXRLightSenseComponent::CombinedLXRColor' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, CombinedLXRIntensity) == 0x0000F4, "Member 'ULXRLightSenseComponent::CombinedLXRIntensity' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, OwnerDetectionComponent) == 0x0002C0, "Member 'ULXRLightSenseComponent::OwnerDetectionComponent' has a wrong offset!");
static_assert(offsetof(ULXRLightSenseComponent, SensedLightsToRemove) == 0x0002C8, "Member 'ULXRLightSenseComponent::SensedLightsToRemove' has a wrong offset!");

// Class LXR.LXRMemoryComponent
// 0x00D8 (0x0188 - 0x00B0)
class ULXRMemoryComponent final : public UActorComponent
{
public:
	bool                                          bDrawDebug;                                        // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrintDebug;                                       // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class ULXRSourceComponent* LightSourceComponent, ELightState OldLightState, ELightState NewLightState)> OnLightStateChanged; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class ULXRSourceComponent* LightSourceComponent, const class ULightComponent* LightComponent, ELightState OldLightComponentState, ELightState NewLightComponentState)> OnLightComponentStateChanged; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EMemoryCheckClass                             MemoryCheckClass;                                  // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMemoryDetectionCheckType                     MemoryDetectionCheckType;                          // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0xA8];                                      // 0x00E0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LXRMemoryComponent">();
	}
	static class ULXRMemoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULXRMemoryComponent>();
	}
};
static_assert(alignof(ULXRMemoryComponent) == 0x000008, "Wrong alignment on ULXRMemoryComponent");
static_assert(sizeof(ULXRMemoryComponent) == 0x000188, "Wrong size on ULXRMemoryComponent");
static_assert(offsetof(ULXRMemoryComponent, bDrawDebug) == 0x0000B0, "Member 'ULXRMemoryComponent::bDrawDebug' has a wrong offset!");
static_assert(offsetof(ULXRMemoryComponent, bPrintDebug) == 0x0000B1, "Member 'ULXRMemoryComponent::bPrintDebug' has a wrong offset!");
static_assert(offsetof(ULXRMemoryComponent, OnLightStateChanged) == 0x0000B8, "Member 'ULXRMemoryComponent::OnLightStateChanged' has a wrong offset!");
static_assert(offsetof(ULXRMemoryComponent, OnLightComponentStateChanged) == 0x0000C8, "Member 'ULXRMemoryComponent::OnLightComponentStateChanged' has a wrong offset!");
static_assert(offsetof(ULXRMemoryComponent, MemoryCheckClass) == 0x0000D8, "Member 'ULXRMemoryComponent::MemoryCheckClass' has a wrong offset!");
static_assert(offsetof(ULXRMemoryComponent, MemoryDetectionCheckType) == 0x0000DC, "Member 'ULXRMemoryComponent::MemoryDetectionCheckType' has a wrong offset!");

// Class LXR.LXRMethodObject
// 0x0018 (0x0040 - 0x0028)
class ULXRMethodObject final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULXRSourceComponent*                    SourceComponent;                                   // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class AActor* GetOwner() const;
	class ULXRSourceComponent* GetSourceComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LXRMethodObject">();
	}
	static class ULXRMethodObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULXRMethodObject>();
	}
};
static_assert(alignof(ULXRMethodObject) == 0x000008, "Wrong alignment on ULXRMethodObject");
static_assert(sizeof(ULXRMethodObject) == 0x000040, "Wrong size on ULXRMethodObject");
static_assert(offsetof(ULXRMethodObject, Owner) == 0x000030, "Member 'ULXRMethodObject::Owner' has a wrong offset!");
static_assert(offsetof(ULXRMethodObject, SourceComponent) == 0x000038, "Member 'ULXRMethodObject::SourceComponent' has a wrong offset!");

// Class LXR.LXROctreeVolume
// 0x0000 (0x0258 - 0x0258)
class ALXROctreeVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LXROctreeVolume">();
	}
	static class ALXROctreeVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALXROctreeVolume>();
	}
};
static_assert(alignof(ALXROctreeVolume) == 0x000008, "Wrong alignment on ALXROctreeVolume");
static_assert(sizeof(ALXROctreeVolume) == 0x000258, "Wrong size on ALXROctreeVolume");

// Class LXR.LXRSourceComponent
// 0x00D0 (0x0180 - 0x00B0)
class ULXRSourceComponent final : public UActorComponent
{
public:
	bool                                          bDrawDebug;                                        // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSolo;                                             // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisable;                                          // 0x00B2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysRelevant;                                   // 0x00B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddDetected;                                      // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLightSense;                                 // 0x00B5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMemorizable;                                    // 0x00B6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B7[0x1];                                       // 0x00B7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttenuationMultiplierToBeRelevant;                 // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LXRMultiplier;                                     // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LXRColorMultiplier;                                // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLightSourceData>               LightLXRMultipliers;                               // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLightSourceData>               LightLXRColorMultipliers;                          // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FComponentReference>            ExcludedLights;                                    // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EMethodToUse                                  IsEnabledMethodToUse;                              // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMethodToUse                                  GetSourceActorStateMethodToUse;                    // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMethodToUse                                  GetLightComponentStateMethodToUse;                 // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMethodToUse                                  IsLightComponentEnabledMethodToUse;                // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMethodToUse                                  GetMyLightComponentsMethodToUse;                   // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         LXRMethodObject;                                   // 0x0110(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         DetectedActors;                                    // 0x0128(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreVisibilityActors;                            // 0x0138(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0x10];                                     // 0x0148(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULightComponent*>                MyLightComponents;                                 // 0x0158(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         MyOverlappingActors;                               // 0x0168(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ULXRMethodObject*                       MethodObject;                                      // 0x0178(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	ELightState GetLightComponentState(const class ULightComponent* InComponent) const;
	ELightState GetLightState() const;
	bool IsEnabled() const;
	bool IsLightComponentEnabled(const class ULightComponent* LightComponent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LXRSourceComponent">();
	}
	static class ULXRSourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULXRSourceComponent>();
	}
};
static_assert(alignof(ULXRSourceComponent) == 0x000008, "Wrong alignment on ULXRSourceComponent");
static_assert(sizeof(ULXRSourceComponent) == 0x000180, "Wrong size on ULXRSourceComponent");
static_assert(offsetof(ULXRSourceComponent, bDrawDebug) == 0x0000B0, "Member 'ULXRSourceComponent::bDrawDebug' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, bSolo) == 0x0000B1, "Member 'ULXRSourceComponent::bSolo' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, bDisable) == 0x0000B2, "Member 'ULXRSourceComponent::bDisable' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, bAlwaysRelevant) == 0x0000B3, "Member 'ULXRSourceComponent::bAlwaysRelevant' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, bAddDetected) == 0x0000B4, "Member 'ULXRSourceComponent::bAddDetected' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, bEnableLightSense) == 0x0000B5, "Member 'ULXRSourceComponent::bEnableLightSense' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, bIsMemorizable) == 0x0000B6, "Member 'ULXRSourceComponent::bIsMemorizable' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, AttenuationMultiplierToBeRelevant) == 0x0000B8, "Member 'ULXRSourceComponent::AttenuationMultiplierToBeRelevant' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, LXRMultiplier) == 0x0000BC, "Member 'ULXRSourceComponent::LXRMultiplier' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, LXRColorMultiplier) == 0x0000C0, "Member 'ULXRSourceComponent::LXRColorMultiplier' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, LightLXRMultipliers) == 0x0000C8, "Member 'ULXRSourceComponent::LightLXRMultipliers' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, LightLXRColorMultipliers) == 0x0000D8, "Member 'ULXRSourceComponent::LightLXRColorMultipliers' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, ExcludedLights) == 0x0000E8, "Member 'ULXRSourceComponent::ExcludedLights' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, IsEnabledMethodToUse) == 0x0000F8, "Member 'ULXRSourceComponent::IsEnabledMethodToUse' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, GetSourceActorStateMethodToUse) == 0x0000FC, "Member 'ULXRSourceComponent::GetSourceActorStateMethodToUse' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, GetLightComponentStateMethodToUse) == 0x000100, "Member 'ULXRSourceComponent::GetLightComponentStateMethodToUse' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, IsLightComponentEnabledMethodToUse) == 0x000104, "Member 'ULXRSourceComponent::IsLightComponentEnabledMethodToUse' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, GetMyLightComponentsMethodToUse) == 0x000108, "Member 'ULXRSourceComponent::GetMyLightComponentsMethodToUse' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, LXRMethodObject) == 0x000110, "Member 'ULXRSourceComponent::LXRMethodObject' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, DetectedActors) == 0x000128, "Member 'ULXRSourceComponent::DetectedActors' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, IgnoreVisibilityActors) == 0x000138, "Member 'ULXRSourceComponent::IgnoreVisibilityActors' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, MyLightComponents) == 0x000158, "Member 'ULXRSourceComponent::MyLightComponents' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, MyOverlappingActors) == 0x000168, "Member 'ULXRSourceComponent::MyOverlappingActors' has a wrong offset!");
static_assert(offsetof(ULXRSourceComponent, MethodObject) == 0x000178, "Member 'ULXRSourceComponent::MethodObject' has a wrong offset!");

// Class LXR.LXRSubsystem
// 0x0160 (0x0190 - 0x0030)
class ULXRSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          LightSources;                                      // 0x0068(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AActor>>          LXRActorsNotInOctreeYetBuffer;                     // 0x0078(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x108];                                     // 0x0088(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterLight(class AActor* LightSource);
	void UnregisterLight(class AActor* LightSource);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LXRSubsystem">();
	}
	static class ULXRSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULXRSubsystem>();
	}
};
static_assert(alignof(ULXRSubsystem) == 0x000008, "Wrong alignment on ULXRSubsystem");
static_assert(sizeof(ULXRSubsystem) == 0x000190, "Wrong size on ULXRSubsystem");
static_assert(offsetof(ULXRSubsystem, LightSources) == 0x000068, "Member 'ULXRSubsystem::LightSources' has a wrong offset!");
static_assert(offsetof(ULXRSubsystem, LXRActorsNotInOctreeYetBuffer) == 0x000078, "Member 'ULXRSubsystem::LXRActorsNotInOctreeYetBuffer' has a wrong offset!");

}

