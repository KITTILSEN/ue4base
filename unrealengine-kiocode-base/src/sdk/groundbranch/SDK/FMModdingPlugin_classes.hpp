#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FMModdingPlugin

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "FMModdingPlugin_structs.hpp"
#include "ModKit_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class FMModdingPlugin.FMModdingAdmin
// 0x0000 (0x0028 - 0x0028)
class UFMModdingAdmin final : public UObject
{
public:
	static class UFMModdingAdmin* Get();

	bool AdminSet(const class FString& UniqueId, const struct FZKReplicatedContent& Content);

	bool FillRequest(const class FString& UniqueId, const class FName& RequestType, struct FZKReplicatedContent* FilledRequest) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMModdingAdmin">();
	}
	static class UFMModdingAdmin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMModdingAdmin>();
	}
};
static_assert(alignof(UFMModdingAdmin) == 0x000008, "Wrong alignment on UFMModdingAdmin");
static_assert(sizeof(UFMModdingAdmin) == 0x000028, "Wrong size on UFMModdingAdmin");

// Class FMModdingPlugin.FMModdingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UFMModdingFunctionLibrary final : public UObject
{
public:
	static struct FLuaValue BlueprintLuaCall(class UObject* WorldContextObject, const struct FLuaValue& ScriptTable, const class FString& FunctionName, const class FString& Filename);
	static struct FLuaValue BlueprintLuaCallWithArgs(class UObject* WorldContextObject, const struct FLuaValue& ScriptTable, const class FString& FunctionName, const class FString& Filename, const TArray<struct FLuaValue>& InArgs);
	static class FString CondenseModReferencesInFileName(const class UObject* WorldContextObject, const class FString& InFilename, bool bRemoveDotExt, bool bRemoveGame);
	static class UFMModdingModDetailsQuery* CreateModDetailsQueryRef(class UObject* WorldContextObject);
	static class UModKitCreateWorkshopItem* CreateModKitCreateWorkshopItemRef(class UObject* WorldContextObject);
	static class UModKitUploadWorkshopItem* CreateModKitUploadWorkshopItemRef(class UObject* WorldContextObject);
	static struct FModMetadata CreateModMetadata(const struct FUInt64& WorkshopID, const class FString& Title, const class FString& Description, const class FString& CreatedBy, const EModType ModType);
	static void CreateNonAssetFoldersForMod(const class UObject* WorldContextObject, const struct FUInt64& ModID);
	static class UFMModdingServerPlayersQuery* CreateServerPlayersQueryRef(class UObject* WorldContextObject);
	static class UFMModdingTitleQuery* CreateTitleQueryRef(class UObject* WorldContextObject);
	static class UFMModdingUserModsQuery* CreateUserModsQueryRef(class UObject* WorldContextObject);
	static void DeleteStagedModFolder();
	static bool DoesHostAllowAsset(const class UObject* WorldContextObject, const struct FPrimaryAssetId& AssetId);
	static class FString ExpandModReferencesInFileName(const class UObject* WorldContextObject, const class FString& InFilename, const class FString& DotExt, bool bAddProjectDir, bool bMakeRelativeToProjectContentDir);
	static TArray<class FString> GenerateCallSignsFromPlayerName(const class FString& PlayerName);
	static TArray<class FName> GetAllWorkshopTags();
	static bool GetAssetsByPathIncludingMods(const class UObject* WorldContextObject, EGBResourceType GBResourceType, TArray<struct FAssetData>* OutAssetData, bool bRecursive, const class FString& PartialFilePathOverride, bool bIncludeOnlyOnDiskAssets, bool bExcludeMods);
	static class FString GetBaseGameOrModFileNameFromPartial(const class FString& InPartialFilePath, const class FString& LeafName, const class FString& FileExtension, const bool bRelativePath, const struct FUInt64& ModID, const class UObject* WorldContextObject);
	static struct FUInt64 GetCurrentPlayerSteamID();
	static bool GetDirectoryFromWorkshopID(class FString* DirectoryPath, const struct FUInt64& WorkshopID, const class UObject* WorldContextObject);
	static class FString GetFileExtensionForGBResourceType(EGBResourceType InGBResourceType);
	static bool GetFileList(const class FString& FilePath, const class FString& Extension, bool bTrimPathAndExt, TArray<class FString>* FileList);
	static bool GetFileListIncludingModIDList(const class UObject* WorldContextObject, EGBResourceType GBResourceType, bool bTrimmed, TArray<class FString>* FileList, const TArray<struct FUInt64>& ModIDList, const class FString& PartialFilePathOverride);
	static bool GetFileListIncludingMods(const class UObject* WorldContextObject, EGBResourceType GBResourceType, bool bTrimmed, TArray<class FString>* FileList, const class FString& PartialFilePathOverride);
	static bool GetFolderList(const class FString& FilePath, TArray<class FString>* FolderList, bool RecurseIntoFolders);
	static bool GetFolderListIncludingModIDList(const class UObject* WorldContextObject, EGBResourceType GBResourceType, TArray<class FString>* FolderList, const TArray<struct FUInt64>& ModIDList, const class FString& PartialFilePathOverride, bool RecurseIntoFolders);
	static bool GetFolderListIncludingMods(const class UObject* WorldContextObject, EGBResourceType GBResourceType, TArray<class FString>* FolderList, const class FString& PartialFilePathOverride, bool RecurseIntoFolders);
	static class FString GetFullFilePathFromPartial(const class FString& InPartialFilePath, const bool bRelativePath, const struct FUInt64& ModID, const class UObject* WorldContextObject);
	static bool GetIsUsingServerMods(const class UObject* WorldContextObject);
	static struct FUInt64 GetModIDForAssetData(const struct FAssetData& AssetData, const class UObject* WorldContextObject);
	static struct FUInt64 GetModIDForPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId, const class UObject* WorldContextObject);
	static struct FUInt64 GetModIDFromFileName(const class UObject* WorldContextObject, const class FString& InFilename, bool bIsCondensed);
	static struct FUInt64 GetModIDFromStringTableName(const class FName& InStringTableName);
	static struct FGBModBasicInfo GetModInfoFromModList(const struct FUInt64& ModID, const TArray<struct FGBModBasicInfo>& ModList, const bool bMustBeActive);
	static bool GetModIsActiveInModList(const struct FUInt64& ModID, const TArray<struct FGBModBasicInfo>& ModList);
	static bool GetModIsEnabled(const struct FUInt64& ModID, const bool bServer);
	static class UModKitSubsystem* GetModKitSubsystem(const class UObject* WorldContextObject);
	static class FString GetModNameFromModID(const struct FUInt64& ModID);
	static class FString GetModPath(const class UObject* WorldContextObject, const struct FUInt64& ModID, bool bMakePathRelativeToContentDir);
	static int32 GetModPriority(const struct FUInt64& ModID);
	static class FString GetModsPath(const class UObject* WorldContextObject, const struct FUInt64& ModID, bool bMakePathRelativeToContentDir);
	static TArray<struct FGBResourceList> GetNonAssetResourcesForMod(const class UObject* WorldContextObject, const struct FUInt64& ModID, bool bTrimmed);
	static class FString GetPartialFilePathForGBResourceType(EGBResourceType InGBResourceType);
	static class FString GetStringNameSpaceFromModID(const class FString& InStringNameSpace, const struct FUInt64& ModID);
	static class FName GetStringTableNameFromModID(const class FName InStringTableId, const struct FUInt64& ModID);
	static struct FUInt64 GetWorkshopIDForPluginName(const class FString& PluginName, const class UObject* WorldContextObject);
	static class FName GetWorkshopTagForResourceType(const EGBResourceType GBResourceType);
	static void MakeSteamStrings(const TArray<class FString>& StringsToEncode, TArray<class FString>* OutLabels, TArray<class FString>* OutStrings, const class FString& StringPrefix, const EGBSteamBufferType SteamBufferType);
	static void MakeSteamStringsFromUInt64(const TArray<struct FUInt64>& IDsToEncode, TArray<class FString>* OutLabels, TArray<class FString>* OutStrings, const class FString& StringPrefix, const EGBSteamBufferType SteamBufferType);
	static bool ModListContainsMod(const struct FUInt64& ModID, const TArray<struct FGBModBasicInfo>& ModList, const bool bMustBeActive);
	static bool ReadLobbyDataStrings(TArray<class FString>* OutDecodedStrings, const class FString& StringPrefix, const struct FUInt64& LobbyID);
	static bool ReadLobbyDataStringsIntoUInt64(TArray<struct FUInt64>* OutDecodedIDs, const class FString& StringPrefix, const struct FUInt64& LobbyID);
	static void RemoveModFromModList(const struct FUInt64& ModID, TArray<struct FGBModBasicInfo>& ModList);
	static class FName RemoveModIDFromStringTableName(const class FName InStringTableName);
	static struct FLuaValue RunLuaFileInEnvironment(class UObject* WorldContextObject, const class FString& Filename, const TSubclassOf<class ULuaState> LuaStateClass);
	static void SetModIsActiveInModList(const struct FUInt64& ModID, TArray<struct FGBModBasicInfo>& ModList, const bool bSetActive);
	static void SetModIsEnabled(const struct FUInt64& ModID, const bool bIsEnabled, const bool bServer);
	static void SetModPriority(const struct FUInt64& ModID, const int32 NewModPriority);
	static bool UInt64ListContainsMod(const struct FUInt64& ModID, const TArray<struct FUInt64>& ModList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMModdingFunctionLibrary">();
	}
	static class UFMModdingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMModdingFunctionLibrary>();
	}
};
static_assert(alignof(UFMModdingFunctionLibrary) == 0x000008, "Wrong alignment on UFMModdingFunctionLibrary");
static_assert(sizeof(UFMModdingFunctionLibrary) == 0x000028, "Wrong size on UFMModdingFunctionLibrary");

// Class FMModdingPlugin.FMModdingManager
// 0x0158 (0x0180 - 0x0028)
class UFMModdingManager final : public UObject
{
public:
	class ULuaState*                              ModdingLuaState;                                   // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUInt64                                CurrentExecutingModID;                             // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLuaScriptInfo>                 ActiveLuaMutators;                                 // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FUInt64>                        CachedSubscribedModIDList;                         // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FUInt64>                        CachedInstalledModIDList;                          // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FUInt64>                        CachedActiveModIDList;                             // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FUInt64>                        ServerModListForClient;                            // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<uint64, struct FUGCFileInfo>             CachedModDetails;                                  // 0x0088(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMModdingModListRetriever*             ModListRetriever;                                  // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TDelegate<void(const TArray<struct FUInt64>& ModList, bool bSuccess)> ModListRetrieverDelegate;  // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<class UFMModdingModDetailsQuery*>      ModDetailRetrievers;                               // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x50];                                     // 0x0110(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BasePackagePath;                                   // 0x0160(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 BasePackagePathNoMod;                              // 0x0170(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void Config_AddToArray(const class FString& Filename, const class FString& Section, const class FString& Key, const class FString& Value);
	static void Config_DeleteArray(const class FString& Filename, const class FString& Section, const class FString& Key);
	static TArray<class FString> Config_GetArray(const class FString& Filename, const class FString& Section, const class FString& Key, bool* bValid, bool bRawFilename);
	static int32 Config_GetInt(const class FString& Filename, const class FString& Section, const class FString& Key, bool* bValid);
	static void Config_RemoveFromArray(const class FString& Filename, const class FString& Section, const class FString& Key, const class FString& Value);
	static void Config_Save(const class FString& Filename, bool bRawFilename);
	static void Config_SetArray(const class FString& Filename, const class FString& Section, const class FString& Key, const TArray<class FString>& Values, bool bRawFilename);
	static void Config_SetInt(const class FString& Filename, const class FString& Section, const class FString& Key, const int32& Value);
	static class UFMModdingManager* Get();
	static class FString GetConfigFilename(const class FString& ConfigFile);

	struct FLuaValue AttemptToCallGameModeFunction(const struct FLuaScriptInfo& GameModeScriptInfo, const class FString& FunctionName, const TArray<struct FLuaValue>& InArgs);
	void AttemptToCallGameModeFunctionAndMutators(const struct FLuaScriptInfo& GameModeScriptInfo, const class FString& FunctionName, const TArray<struct FLuaValue>& InArgs);
	struct FLuaValue AttemptToCallGameModeFunctionAndMutatorsAbortOnAnyBool(const struct FLuaScriptInfo& GameModeScriptInfo, const class FString& FunctionName, const TArray<struct FLuaValue>& InArgs);
	struct FLuaValue AttemptToCallGameModeFunctionAndMutatorsAbortOnAnyInteger(const struct FLuaScriptInfo& GameModeScriptInfo, const class FString& FunctionName, const TArray<struct FLuaValue>& InArgs);
	struct FLuaValue AttemptToCallGameModeFunctionAndMutatorsAbortOnAnyString(const struct FLuaScriptInfo& GameModeScriptInfo, const class FString& FunctionName, const TArray<struct FLuaValue>& InArgs);
	bool AttemptToCallGameModeFunctionAndMutatorsCanIntercept(const struct FLuaScriptInfo& GameModeScriptInfo, const class FString& FunctionName, const TArray<struct FLuaValue>& InArgs);
	void AttemptToCallGameModeFunctionAndMutatorsReversed(const struct FLuaScriptInfo& GameModeScriptInfo, const class FString& FunctionName, const TArray<struct FLuaValue>& InArgs);
	struct FLuaValue AttemptToCallLuaFunction(const struct FLuaScriptInfo& LuaScriptInfo, const class FString& FunctionName, const TArray<struct FLuaValue>& InArgs);
	struct FLuaValue AttemptToCallMutatorFunctionInMod(const class FString& FunctionName, const TArray<struct FLuaValue>& InArgs, const struct FUInt64& ModID);
	void AttemptToCallMutatorFunctions(const class FString& FunctionName, const TArray<struct FLuaValue>& InArgs);
	struct FLuaValue AttemptToCallMutatorFunctionsAbortOnAnyInteger(const class FString& FunctionName, const TArray<struct FLuaValue>& InArgs);
	struct FLuaValue AttemptToCallMutatorFunctionsAbortOnAnyString(const class FString& FunctionName, const TArray<struct FLuaValue>& InArgs);
	struct FLuaValue AttemptToCallMutatorFunctionsAbortOnAnyTable(const class FString& FunctionName, const TArray<struct FLuaValue>& InArgs);
	bool AttemptToCallMutatorFunctionsCanIntercept(const class FString& FunctionName, const TArray<struct FLuaValue>& InArgs);
	void AttemptToCallMutatorFunctionsReversed(const class FString& FunctionName, const TArray<struct FLuaValue>& InArgs);
	struct FLuaValue CreateInstanceOfScript(class UObject* WorldContextObject, const TSubclassOf<class ULuaState> LuaStateClass, const class FString& ScriptFilename);
	bool FindLuaMutator(struct FLuaScriptInfo* OutLuaScriptInfo, const struct FUInt64& ModID, const class FString& MutatorName);
	void GenerateInstalledModList(const class UObject* WorldContextObject);
	TArray<struct FLuaScriptInfo> GetActiveLuaMutators();
	bool GetCachedFileListIncludingModIDList(EGBResourceType GBResourceType, bool bTrimmed, TArray<class FString>* FileList, const TArray<struct FUInt64>& ModIDList, const class UObject* WorldContextObject);
	bool GetCachedFileListIncludingMods(EGBResourceType GBResourceType, bool bTrimmed, TArray<class FString>* FileList, const class UObject* WorldContextObject);
	struct FUInt64 GetCurrentExecutingModID();
	struct FLuaScriptInfo GetLuaScriptInfoForMutatorFileName(const class FString& Filename);
	void GetModDetails(const struct FUInt64& ModID, TDelegate<void(const struct FUGCFileInfo& ModDetails, bool bSuccess)> Delegate);
	void GetModListForServer(const struct FSteamServerDetails& SteamServerDetails, TDelegate<void(const TArray<struct FUInt64>& ModList, bool bSuccess)> Delegate);
	struct FLuaScriptOption GetMutatorOption(struct FLuaScriptInfo& ScriptInfo, const class FName OptionName, bool bUseConfig);
	struct FLuaScriptOption GetMutatorOptionByFilename(const class FString& Filename, const class FName OptionName, bool bUseConfig);
	TArray<struct FLuaScriptOption> GetMutatorOptions(struct FLuaScriptInfo& ScriptInfo, bool bUseConfig);
	TArray<struct FLuaScriptOption> GetMutatorOptionsByFilename(const class FString& Filename, bool bUseConfig);
	void PrepAllLuaMutators(const class UObject* WorldContextObject);
	void PrepLuaMutatorsForMod(const struct FUInt64& ModID, const class UObject* WorldContextObject);
	struct FLuaValue RunLuaFileInEnvironment(class UObject* WorldContextObject, const TSubclassOf<class ULuaState> LuaStateClass, struct FLuaScriptInfo* LuaScriptInfo);
	void SetActiveLuaMutators(const TArray<struct FLuaScriptInfo>& UpdatedActiveLuaMutators);
	void SetCurrentExecutingModID(const struct FUInt64& ModID);
	void SetModDisabled(const struct FUInt64& ModID, const bool bDisabled);
	void SetMutatorOptionsFromMissionSettings(const class FString& Params_0);
	bool SetMutatorOptionValue(struct FLuaScriptInfo& ScriptInfo, class FName OptionName, int32 NewValue, bool bSetConfig);
	bool SetMutatorOptionValueByFilename(const class FString& Filename, class FName OptionName, int32 NewValue, bool bSetConfig);
	void SetServerAuthoritative(struct FLuaScriptInfo& ScriptInfo, bool bNewServerAuthoritative);
	void SetServerModListForClient(const TArray<struct FUInt64>& InServerModListForClient);
	void SetupPackagePath();
	void SubscribeToMod(const struct FUInt64& ModID);
	void UnloadAllLuaMutators();
	void UnloadLuaMutatorsForMod(const struct FUInt64& ModID);
	void UnsubscribeFromMod(const struct FUInt64& ModID);
	void UpdateCachedFileList(EGBResourceType GBResourceType, const class UObject* WorldContextObject);

	TArray<struct FUInt64> GetActiveModList() const;
	TArray<struct FUInt64> GetInstalledModList() const;
	TArray<struct FUInt64> GetSubscribedModList() const;
	bool IsModActive(const struct FUInt64& ModID, const bool bServer) const;
	bool IsModDisabled(const struct FUInt64& ModID, const bool bServer) const;
	bool IsModInstalled(const struct FUInt64& ModID) const;
	bool IsModSubscribed(const struct FUInt64& ModID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMModdingManager">();
	}
	static class UFMModdingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMModdingManager>();
	}
};
static_assert(alignof(UFMModdingManager) == 0x000008, "Wrong alignment on UFMModdingManager");
static_assert(sizeof(UFMModdingManager) == 0x000180, "Wrong size on UFMModdingManager");
static_assert(offsetof(UFMModdingManager, ModdingLuaState) == 0x000028, "Member 'UFMModdingManager::ModdingLuaState' has a wrong offset!");
static_assert(offsetof(UFMModdingManager, CurrentExecutingModID) == 0x000030, "Member 'UFMModdingManager::CurrentExecutingModID' has a wrong offset!");
static_assert(offsetof(UFMModdingManager, ActiveLuaMutators) == 0x000038, "Member 'UFMModdingManager::ActiveLuaMutators' has a wrong offset!");
static_assert(offsetof(UFMModdingManager, CachedSubscribedModIDList) == 0x000048, "Member 'UFMModdingManager::CachedSubscribedModIDList' has a wrong offset!");
static_assert(offsetof(UFMModdingManager, CachedInstalledModIDList) == 0x000058, "Member 'UFMModdingManager::CachedInstalledModIDList' has a wrong offset!");
static_assert(offsetof(UFMModdingManager, CachedActiveModIDList) == 0x000068, "Member 'UFMModdingManager::CachedActiveModIDList' has a wrong offset!");
static_assert(offsetof(UFMModdingManager, ServerModListForClient) == 0x000078, "Member 'UFMModdingManager::ServerModListForClient' has a wrong offset!");
static_assert(offsetof(UFMModdingManager, CachedModDetails) == 0x000088, "Member 'UFMModdingManager::CachedModDetails' has a wrong offset!");
static_assert(offsetof(UFMModdingManager, ModListRetriever) == 0x0000E8, "Member 'UFMModdingManager::ModListRetriever' has a wrong offset!");
static_assert(offsetof(UFMModdingManager, ModListRetrieverDelegate) == 0x0000F0, "Member 'UFMModdingManager::ModListRetrieverDelegate' has a wrong offset!");
static_assert(offsetof(UFMModdingManager, ModDetailRetrievers) == 0x000100, "Member 'UFMModdingManager::ModDetailRetrievers' has a wrong offset!");
static_assert(offsetof(UFMModdingManager, BasePackagePath) == 0x000160, "Member 'UFMModdingManager::BasePackagePath' has a wrong offset!");
static_assert(offsetof(UFMModdingManager, BasePackagePathNoMod) == 0x000170, "Member 'UFMModdingManager::BasePackagePathNoMod' has a wrong offset!");

// Class FMModdingPlugin.FMModdingModDetailsQuery
// 0x00D8 (0x0100 - 0x0028)
class UFMModdingModDetailsQuery final : public UObject
{
public:
	TMulticastInlineDelegate<void(const struct FUGCFileInfo& UGCFileInfo, bool bSuccess)> OnFinishRetrieveModDetailsEvent; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUInt64                                ID;                                                // 0x0088(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasSucceeded;                                     // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasFinished;                                      // 0x0091(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasFinished_UGCDetails;                           // 0x0092(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasFinished_Metadata;                             // 0x0093(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUGCFileInfo                           UGCFileInfo;                                       // 0x0098(0x0058)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelQuery();
	void RequestModDetails(const struct FUInt64& InID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMModdingModDetailsQuery">();
	}
	static class UFMModdingModDetailsQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMModdingModDetailsQuery>();
	}
};
static_assert(alignof(UFMModdingModDetailsQuery) == 0x000008, "Wrong alignment on UFMModdingModDetailsQuery");
static_assert(sizeof(UFMModdingModDetailsQuery) == 0x000100, "Wrong size on UFMModdingModDetailsQuery");
static_assert(offsetof(UFMModdingModDetailsQuery, OnFinishRetrieveModDetailsEvent) == 0x000028, "Member 'UFMModdingModDetailsQuery::OnFinishRetrieveModDetailsEvent' has a wrong offset!");
static_assert(offsetof(UFMModdingModDetailsQuery, ID) == 0x000088, "Member 'UFMModdingModDetailsQuery::ID' has a wrong offset!");
static_assert(offsetof(UFMModdingModDetailsQuery, bHasSucceeded) == 0x000090, "Member 'UFMModdingModDetailsQuery::bHasSucceeded' has a wrong offset!");
static_assert(offsetof(UFMModdingModDetailsQuery, bHasFinished) == 0x000091, "Member 'UFMModdingModDetailsQuery::bHasFinished' has a wrong offset!");
static_assert(offsetof(UFMModdingModDetailsQuery, bHasFinished_UGCDetails) == 0x000092, "Member 'UFMModdingModDetailsQuery::bHasFinished_UGCDetails' has a wrong offset!");
static_assert(offsetof(UFMModdingModDetailsQuery, bHasFinished_Metadata) == 0x000093, "Member 'UFMModdingModDetailsQuery::bHasFinished_Metadata' has a wrong offset!");
static_assert(offsetof(UFMModdingModDetailsQuery, UGCFileInfo) == 0x000098, "Member 'UFMModdingModDetailsQuery::UGCFileInfo' has a wrong offset!");

// Class FMModdingPlugin.FMModdingModListRetriever
// 0x0038 (0x0060 - 0x0028)
class UFMModdingModListRetriever final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ServerIP;                                          // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint16                                        ServerQueryPort;                                   // 0x0034(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUInt64>                        ModList;                                           // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bHasFinished;                                      // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWasSuccessful;                                    // 0x0049(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A[0x16];                                      // 0x004A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMModdingModListRetriever">();
	}
	static class UFMModdingModListRetriever* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMModdingModListRetriever>();
	}
};
static_assert(alignof(UFMModdingModListRetriever) == 0x000008, "Wrong alignment on UFMModdingModListRetriever");
static_assert(sizeof(UFMModdingModListRetriever) == 0x000060, "Wrong size on UFMModdingModListRetriever");
static_assert(offsetof(UFMModdingModListRetriever, ServerIP) == 0x000030, "Member 'UFMModdingModListRetriever::ServerIP' has a wrong offset!");
static_assert(offsetof(UFMModdingModListRetriever, ServerQueryPort) == 0x000034, "Member 'UFMModdingModListRetriever::ServerQueryPort' has a wrong offset!");
static_assert(offsetof(UFMModdingModListRetriever, ModList) == 0x000038, "Member 'UFMModdingModListRetriever::ModList' has a wrong offset!");
static_assert(offsetof(UFMModdingModListRetriever, bHasFinished) == 0x000048, "Member 'UFMModdingModListRetriever::bHasFinished' has a wrong offset!");
static_assert(offsetof(UFMModdingModListRetriever, bWasSuccessful) == 0x000049, "Member 'UFMModdingModListRetriever::bWasSuccessful' has a wrong offset!");

// Class FMModdingPlugin.FMModdingModSync
// 0x00A8 (0x02C8 - 0x0220)
class AFMModdingModSync : public AActor
{
public:
	TMulticastInlineDelegate<void(bool bSuccess)> OnFinishModSyncEventMC;                            // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TimerHandle_UnmountInactiveMods;                   // 0x0230(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TimerHandle_MountActiveMods;                       // 0x0238(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FUInt64>                        ModsToUnmount;                                     // 0x0240(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         TotalModsToUnmount;                                // 0x0250(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUInt64>                        ModsToMount;                                       // 0x0258(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         TotalModsToMount;                                  // 0x0268(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFMModInfo>                     ModList;                                           // 0x0270(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         ModSyncIndex;                                      // 0x0280(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFMModdingModDetailsQuery*>      Retrievers;                                        // 0x0288(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasFinished;                                      // 0x0298(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWasSuccessful;                                    // 0x0299(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bModsNeedSync;                                     // 0x029A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bModDetailsAreLoaded;                              // 0x029B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUInt64>                        RawModList;                                        // 0x02A0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EFMSyncStatus                                 GlobalSyncStatus;                                  // 0x02B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x17];                                     // 0x02B1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdvanceSyncStatus();
	void BypassSync();
	void CancelSync();
	void HideUI();
	void Initialize(const TArray<struct FUInt64>& InModList, const bool bInUseUI);
	void OnModGlobalSyncStatusUpdatedEvent(const EFMSyncStatus NewSyncStatus);
	void OnModSyncEvent(const struct FUInt64& ModID, const bool bWasSyncSuccessful);
	void OnModSyncFinishedEvent(const bool bWasSyncSuccessful);
	void OnModSyncMountUnmountEvent(const int32 NumModsRemaining, const int32 TotalModsToMountOrUnmount, const bool bMounting);
	void SetGlobalSyncStatus(const EFMSyncStatus NewSyncStatus);
	void ShowUI();
	void StartSync();

	bool AreModDetailsLoaded() const;
	EFMSyncStatus GetGlobalSyncStatus() const;
	bool IsAnySyncRequired() const;
	bool IsModSyncRequired() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMModdingModSync">();
	}
	static class AFMModdingModSync* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFMModdingModSync>();
	}
};
static_assert(alignof(AFMModdingModSync) == 0x000008, "Wrong alignment on AFMModdingModSync");
static_assert(sizeof(AFMModdingModSync) == 0x0002C8, "Wrong size on AFMModdingModSync");
static_assert(offsetof(AFMModdingModSync, OnFinishModSyncEventMC) == 0x000220, "Member 'AFMModdingModSync::OnFinishModSyncEventMC' has a wrong offset!");
static_assert(offsetof(AFMModdingModSync, TimerHandle_UnmountInactiveMods) == 0x000230, "Member 'AFMModdingModSync::TimerHandle_UnmountInactiveMods' has a wrong offset!");
static_assert(offsetof(AFMModdingModSync, TimerHandle_MountActiveMods) == 0x000238, "Member 'AFMModdingModSync::TimerHandle_MountActiveMods' has a wrong offset!");
static_assert(offsetof(AFMModdingModSync, ModsToUnmount) == 0x000240, "Member 'AFMModdingModSync::ModsToUnmount' has a wrong offset!");
static_assert(offsetof(AFMModdingModSync, TotalModsToUnmount) == 0x000250, "Member 'AFMModdingModSync::TotalModsToUnmount' has a wrong offset!");
static_assert(offsetof(AFMModdingModSync, ModsToMount) == 0x000258, "Member 'AFMModdingModSync::ModsToMount' has a wrong offset!");
static_assert(offsetof(AFMModdingModSync, TotalModsToMount) == 0x000268, "Member 'AFMModdingModSync::TotalModsToMount' has a wrong offset!");
static_assert(offsetof(AFMModdingModSync, ModList) == 0x000270, "Member 'AFMModdingModSync::ModList' has a wrong offset!");
static_assert(offsetof(AFMModdingModSync, ModSyncIndex) == 0x000280, "Member 'AFMModdingModSync::ModSyncIndex' has a wrong offset!");
static_assert(offsetof(AFMModdingModSync, Retrievers) == 0x000288, "Member 'AFMModdingModSync::Retrievers' has a wrong offset!");
static_assert(offsetof(AFMModdingModSync, bHasFinished) == 0x000298, "Member 'AFMModdingModSync::bHasFinished' has a wrong offset!");
static_assert(offsetof(AFMModdingModSync, bWasSuccessful) == 0x000299, "Member 'AFMModdingModSync::bWasSuccessful' has a wrong offset!");
static_assert(offsetof(AFMModdingModSync, bModsNeedSync) == 0x00029A, "Member 'AFMModdingModSync::bModsNeedSync' has a wrong offset!");
static_assert(offsetof(AFMModdingModSync, bModDetailsAreLoaded) == 0x00029B, "Member 'AFMModdingModSync::bModDetailsAreLoaded' has a wrong offset!");
static_assert(offsetof(AFMModdingModSync, RawModList) == 0x0002A0, "Member 'AFMModdingModSync::RawModList' has a wrong offset!");
static_assert(offsetof(AFMModdingModSync, GlobalSyncStatus) == 0x0002B0, "Member 'AFMModdingModSync::GlobalSyncStatus' has a wrong offset!");

// Class FMModdingPlugin.FMModdingServerPlayersQuery
// 0x0040 (0x0068 - 0x0028)
class UFMModdingServerPlayersQuery final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         QueuedPlayerNames;                                 // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelRequestPlayersList();
	void RequestPlayersList(const struct FSteamServerDetails& SteamServerDetails, TDelegate<void(const TArray<class FString>& PlayerNameList, bool bSuccess)> Delegate);
	void ReturnPlayersList(const bool bSuccess);

	bool IsRefreshing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMModdingServerPlayersQuery">();
	}
	static class UFMModdingServerPlayersQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMModdingServerPlayersQuery>();
	}
};
static_assert(alignof(UFMModdingServerPlayersQuery) == 0x000008, "Wrong alignment on UFMModdingServerPlayersQuery");
static_assert(sizeof(UFMModdingServerPlayersQuery) == 0x000068, "Wrong size on UFMModdingServerPlayersQuery");
static_assert(offsetof(UFMModdingServerPlayersQuery, QueuedPlayerNames) == 0x000038, "Member 'UFMModdingServerPlayersQuery::QueuedPlayerNames' has a wrong offset!");

// Class FMModdingPlugin.FMModdingSettings
// 0x0120 (0x0148 - 0x0028)
class UFMModdingSettings final : public UObject
{
public:
	struct FSoftClassPath                         ModdingLuaStateClass;                              // 0x0028(0x0018)(ZeroConstructor, Config, GlobalConfig, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ConfigPath;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ModPath;                                           // 0x0060(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GroundBranchSteamAppID;                            // 0x0070(0x0004)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GroundBranchSDKAppID;                              // 0x0074(0x0004)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGBPatchVisibility                            PatchVisibility;                                   // 0x0078(0x0001)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             CensoredPatches;                                   // 0x0080(0x0050)(Edit, Config, GlobalConfig, Protected, NativeAccessSpecifierProtected)
	TMap<struct FUInt64, int32>                   ModPriorities;                                     // 0x00D0(0x0050)(Edit, Config, GlobalConfig, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseLocalModListForServer;                         // 0x0120(0x0001)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGBModBasicInfo>                ServerMods;                                        // 0x0128(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FString                                 ModPathDevBuild;                                   // 0x0138(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UFMModdingSettings* Get();

	void AddCensoredPatch(const class FString& PatchFilename);
	void ClearAllCensoredPatches();
	void LoadConfigClient();
	void LoadConfigServer();
	void RemoveCensoredPatch(const class FString& PatchFilename);
	void SaveConfigClient();
	void SaveConfigServer();

	bool GetAreAnyPatchesCensored() const;
	TArray<struct FUInt64> GetDisabledMods() const;
	bool GetIsPatchCensored(const class FString& PatchFilename) const;
	bool GetModIsDisabled(const struct FUInt64& ModID) const;
	EGBPatchVisibility GetPatchVisibility() const;
	TArray<struct FGBModBasicInfo> GetServerMods() const;
	bool GetUseLocalModListForServer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMModdingSettings">();
	}
	static class UFMModdingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMModdingSettings>();
	}
};
static_assert(alignof(UFMModdingSettings) == 0x000008, "Wrong alignment on UFMModdingSettings");
static_assert(sizeof(UFMModdingSettings) == 0x000148, "Wrong size on UFMModdingSettings");
static_assert(offsetof(UFMModdingSettings, ModdingLuaStateClass) == 0x000028, "Member 'UFMModdingSettings::ModdingLuaStateClass' has a wrong offset!");
static_assert(offsetof(UFMModdingSettings, ConfigPath) == 0x000050, "Member 'UFMModdingSettings::ConfigPath' has a wrong offset!");
static_assert(offsetof(UFMModdingSettings, ModPath) == 0x000060, "Member 'UFMModdingSettings::ModPath' has a wrong offset!");
static_assert(offsetof(UFMModdingSettings, GroundBranchSteamAppID) == 0x000070, "Member 'UFMModdingSettings::GroundBranchSteamAppID' has a wrong offset!");
static_assert(offsetof(UFMModdingSettings, GroundBranchSDKAppID) == 0x000074, "Member 'UFMModdingSettings::GroundBranchSDKAppID' has a wrong offset!");
static_assert(offsetof(UFMModdingSettings, PatchVisibility) == 0x000078, "Member 'UFMModdingSettings::PatchVisibility' has a wrong offset!");
static_assert(offsetof(UFMModdingSettings, CensoredPatches) == 0x000080, "Member 'UFMModdingSettings::CensoredPatches' has a wrong offset!");
static_assert(offsetof(UFMModdingSettings, ModPriorities) == 0x0000D0, "Member 'UFMModdingSettings::ModPriorities' has a wrong offset!");
static_assert(offsetof(UFMModdingSettings, bUseLocalModListForServer) == 0x000120, "Member 'UFMModdingSettings::bUseLocalModListForServer' has a wrong offset!");
static_assert(offsetof(UFMModdingSettings, ServerMods) == 0x000128, "Member 'UFMModdingSettings::ServerMods' has a wrong offset!");
static_assert(offsetof(UFMModdingSettings, ModPathDevBuild) == 0x000138, "Member 'UFMModdingSettings::ModPathDevBuild' has a wrong offset!");

// Class FMModdingPlugin.FMModdingTitleQuery
// 0x0080 (0x00A8 - 0x0028)
class UFMModdingTitleQuery final : public UObject
{
public:
	TMulticastInlineDelegate<void(const TArray<struct FUInt64>& ModList, bool bSuccess)> OnFinishRetrieveModsEvent; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SearchText;                                        // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WorkshopTag;                                       // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFilterUsingTag;                                   // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasSucceeded;                                     // 0x0079(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasFinished;                                      // 0x007A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7B[0x5];                                       // 0x007B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUInt64>                        ModList;                                           // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestModList(const class FString& InSearchText, const class FName InWorkshopTag, const bool bOnlyCurrentGameVersion);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMModdingTitleQuery">();
	}
	static class UFMModdingTitleQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMModdingTitleQuery>();
	}
};
static_assert(alignof(UFMModdingTitleQuery) == 0x000008, "Wrong alignment on UFMModdingTitleQuery");
static_assert(sizeof(UFMModdingTitleQuery) == 0x0000A8, "Wrong size on UFMModdingTitleQuery");
static_assert(offsetof(UFMModdingTitleQuery, OnFinishRetrieveModsEvent) == 0x000028, "Member 'UFMModdingTitleQuery::OnFinishRetrieveModsEvent' has a wrong offset!");
static_assert(offsetof(UFMModdingTitleQuery, SearchText) == 0x000060, "Member 'UFMModdingTitleQuery::SearchText' has a wrong offset!");
static_assert(offsetof(UFMModdingTitleQuery, WorkshopTag) == 0x000070, "Member 'UFMModdingTitleQuery::WorkshopTag' has a wrong offset!");
static_assert(offsetof(UFMModdingTitleQuery, bFilterUsingTag) == 0x000078, "Member 'UFMModdingTitleQuery::bFilterUsingTag' has a wrong offset!");
static_assert(offsetof(UFMModdingTitleQuery, bHasSucceeded) == 0x000079, "Member 'UFMModdingTitleQuery::bHasSucceeded' has a wrong offset!");
static_assert(offsetof(UFMModdingTitleQuery, bHasFinished) == 0x00007A, "Member 'UFMModdingTitleQuery::bHasFinished' has a wrong offset!");
static_assert(offsetof(UFMModdingTitleQuery, ModList) == 0x000080, "Member 'UFMModdingTitleQuery::ModList' has a wrong offset!");

// Class FMModdingPlugin.FMModdingUserModsQuery
// 0x0070 (0x0098 - 0x0028)
class UFMModdingUserModsQuery final : public UObject
{
public:
	TMulticastInlineDelegate<void(const TArray<struct FUInt64>& ModList, bool bSuccess)> OnFinishRetrieveUserModsEvent; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUInt64                                SteamUserID;                                       // 0x0060(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasSucceeded;                                     // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasFinished;                                      // 0x0069(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUInt64>                        ModList;                                           // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x18];                                      // 0x0080(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestUserModList(const struct FUInt64& InSteamUserID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMModdingUserModsQuery">();
	}
	static class UFMModdingUserModsQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMModdingUserModsQuery>();
	}
};
static_assert(alignof(UFMModdingUserModsQuery) == 0x000008, "Wrong alignment on UFMModdingUserModsQuery");
static_assert(sizeof(UFMModdingUserModsQuery) == 0x000098, "Wrong size on UFMModdingUserModsQuery");
static_assert(offsetof(UFMModdingUserModsQuery, OnFinishRetrieveUserModsEvent) == 0x000028, "Member 'UFMModdingUserModsQuery::OnFinishRetrieveUserModsEvent' has a wrong offset!");
static_assert(offsetof(UFMModdingUserModsQuery, SteamUserID) == 0x000060, "Member 'UFMModdingUserModsQuery::SteamUserID' has a wrong offset!");
static_assert(offsetof(UFMModdingUserModsQuery, bHasSucceeded) == 0x000068, "Member 'UFMModdingUserModsQuery::bHasSucceeded' has a wrong offset!");
static_assert(offsetof(UFMModdingUserModsQuery, bHasFinished) == 0x000069, "Member 'UFMModdingUserModsQuery::bHasFinished' has a wrong offset!");
static_assert(offsetof(UFMModdingUserModsQuery, ModList) == 0x000070, "Member 'UFMModdingUserModsQuery::ModList' has a wrong offset!");

}

