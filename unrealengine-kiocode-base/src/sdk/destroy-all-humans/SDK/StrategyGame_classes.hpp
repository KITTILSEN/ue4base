#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: StrategyGame

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "StrategyGame_structs.hpp"


namespace SDK
{

// Class StrategyGame.GameFocus
// 0x0000 (0x0028 - 0x0028)
class UGameFocus final : public UBlueprintFunctionLibrary
{
public:
	static void GetViewportFocus(bool* IsFocused);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFocus">();
	}
	static class UGameFocus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFocus>();
	}
};
static_assert(alignof(UGameFocus) == 0x000008, "Wrong alignment on UGameFocus");
static_assert(sizeof(UGameFocus) == 0x000028, "Wrong size on UGameFocus");

// Class StrategyGame.GridManager
// 0x0030 (0x02C0 - 0x0290)
class AGridManager : public AActor
{
public:
	uint8                                         Pad_1BF8[0x30];                                    // 0x0290(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CellExistsFromIndex(int32 Param_Index);
	bool CellExistsFromWorldPos(const struct FVector& WorldPos);
	bool CellExistsFromXY(int32 X, int32 Y);
	bool CellHasModifier(int32 X, int32 Y, EGridCellModifier Mod);
	TArray<struct FVector> FindFullPath(const struct FVector& Start, const struct FVector& End, bool IgnoreEnemies);
	TArray<struct FVector> GetCellArea(const struct FVector& Center, int32 Radius, bool WithVision, bool IgnoreNotWalkable);
	int32 GetCellDistanceActor(class AActor* Start, class AActor* End);
	int32 GetCellDistanceVec(const struct FVector& Start, const struct FVector& End);
	EGridCellModifier GetCellModifierFromIndex(int32 Param_Index);
	EGridCellModifier GetCellModifierFromWorlPos(const struct FVector& Pos);
	EGridCellModifier GetCellModifierFromXY(int32 X, int32 Y);
	int32 GetCellSize();
	struct FVector GetCellXYFromWorldPos(const struct FVector& WorldPos);
	TArray<class AActor*> GetEntitiesAroundWordPos(const struct FVector& Pos, int32 Range);
	class AActor* GetEntityFromWorldPos(const struct FVector& WorldPos);
	class AActor* GetEntityFromXY(const struct FVector& Cell);
	int32 GetIdxFromCell(const struct FVector& Cell);
	int32 GetIdxFromXY(int32 X, int32 Y);
	struct FVector GetMapSize();
	TArray<struct FVector> GetOccupiedCells();
	struct FVector GetWorldPosFromCellXY(const struct FVector& CellXY);
	bool IsCellWalkableFromGridXY(int32 X, int32 Y);
	bool IsCellWalkableFromIndex(int32 Param_Index);
	bool IsCellWalkableFromWorldPos(const struct FVector& Pos);
	bool IsClearPath(int32 X0, int32 Y0, int32 X1, int32 Y1);
	bool IsEmpty(const struct FVector& WorldPos);
	bool IsEmptyFromXy(const struct FVector& Cell);
	void MoveEntityFromWorldPos(const struct FVector& Start, const struct FVector& Dest, class AActor* Entity);
	void SetCellModifierFromXY(int32 X, int32 Y, EGridCellModifier Modifier);
	void SetCellSize(int32 Size);
	void SetCellWalkableFromGridXY(int32 X, int32 Y, bool Walkable);
	void SetEntityFromWorldPos(class AActor* Entity, bool Walkable);
	void SetEntityNullFromWorldPos(const struct FVector& Pos);
	void SetMapSize(int32 Width, int32 Height);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridManager">();
	}
	static class AGridManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGridManager>();
	}
};
static_assert(alignof(AGridManager) == 0x000008, "Wrong alignment on AGridManager");
static_assert(sizeof(AGridManager) == 0x0002C0, "Wrong size on AGridManager");

// Class StrategyGame.StrategyGameGameModeBase
// 0x0000 (0x0330 - 0x0330)
class AStrategyGameGameModeBase final : public AGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StrategyGameGameModeBase">();
	}
	static class AStrategyGameGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStrategyGameGameModeBase>();
	}
};
static_assert(alignof(AStrategyGameGameModeBase) == 0x000008, "Wrong alignment on AStrategyGameGameModeBase");
static_assert(sizeof(AStrategyGameGameModeBase) == 0x000330, "Wrong size on AStrategyGameGameModeBase");

}

