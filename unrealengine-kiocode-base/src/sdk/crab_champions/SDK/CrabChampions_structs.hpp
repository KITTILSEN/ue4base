#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CrabChampions

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Enum CrabChampions.ECrabBossPhase
// NumValues: 0x0004
enum class ECrabBossPhase : uint8
{
	PhaseOne                                 = 0,
	PhaseTwo                                 = 1,
	PhaseThree                               = 2,
	ECrabBossPhase_MAX                       = 3,
};

// Enum CrabChampions.ECrabDamageAreaType
// NumValues: 0x0007
enum class ECrabDamageAreaType : uint8
{
	None                                     = 0,
	Damage                                   = 1,
	Health                                   = 2,
	MaxHealth                                = 3,
	EnergyRing                               = 4,
	BlackHole                                = 5,
	ECrabDamageAreaType_MAX                  = 6,
};

// Enum CrabChampions.ECrabEQCType
// NumValues: 0x0005
enum class ECrabEQCType : uint8
{
	None                                     = 0,
	BestEnemyC                               = 1,
	BestEnemyCoreLoc                         = 2,
	BestFriendlyC                            = 3,
	ECrabEQCType_MAX                         = 4,
};

// Enum CrabChampions.ECrabConfirmationPromptType
// NumValues: 0x0005
enum class ECrabConfirmationPromptType : uint8
{
	None                                     = 0,
	QuitToLobby                              = 1,
	BringPartyMembersToLobby                 = 2,
	QuitToDesktop                            = 3,
	ECrabConfirmationPromptType_MAX          = 4,
};

// Enum CrabChampions.ECrabInputDir
// NumValues: 0x0006
enum class ECrabInputDir : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Backward                                 = 2,
	Right                                    = 3,
	Left                                     = 4,
	ECrabInputDir_MAX                        = 5,
};

// Enum CrabChampions.ECrabBlockingHitState
// NumValues: 0x0003
enum class ECrabBlockingHitState : uint8
{
	Deflected                                = 0,
	Aborted                                  = 1,
	ECrabBlockingHitState_MAX                = 2,
};

// Enum CrabChampions.ECrabProjectileState
// NumValues: 0x0005
enum class ECrabProjectileState : uint8
{
	None                                     = 0,
	Pooled                                   = 1,
	Active                                   = 2,
	Exploded                                 = 3,
	ECrabProjectileState_MAX                 = 4,
};

// Enum CrabChampions.ECrabTurretType
// NumValues: 0x0007
enum class ECrabTurretType : uint8
{
	None                                     = 0,
	Sentry                                   = 1,
	Sniper                                   = 2,
	Fire                                     = 3,
	Poison                                   = 4,
	Mortar                                   = 5,
	ECrabTurretType_MAX                      = 6,
};

// Enum CrabChampions.ECrabTargetType
// NumValues: 0x0005
enum class ECrabTargetType : uint8
{
	None                                     = 0,
	CurrentLoc                               = 1,
	PredictedLoc                             = 2,
	TelegraphedLoc                           = 3,
	ECrabTargetType_MAX                      = 4,
};

// Enum CrabChampions.ECrabEnemyBuff
// NumValues: 0x0008
enum class ECrabEnemyBuff : uint8
{
	None                                     = 0,
	Angered                                  = 1,
	Frenzied                                 = 2,
	Healthy                                  = 3,
	Speedy                                   = 4,
	Shielded                                 = 5,
	Last                                     = 6,
	ECrabEnemyBuff_MAX                       = 7,
};

// Enum CrabChampions.ECrabEnemyMovementType
// NumValues: 0x0005
enum class ECrabEnemyMovementType : uint8
{
	None                                     = 0,
	MoveDirectlyToEnemy                      = 1,
	MoveToPredictedEnemyLoc                  = 2,
	MoveToRangedActionLoc                    = 3,
	ECrabEnemyMovementType_MAX               = 4,
};

// Enum CrabChampions.ECrabEnemyCategory
// NumValues: 0x0007
enum class ECrabEnemyCategory : uint8
{
	None                                     = 0,
	Easy                                     = 1,
	Medium                                   = 2,
	Hard                                     = 3,
	Elite                                    = 4,
	Boss                                     = 5,
	ECrabEnemyCategory_MAX                   = 6,
};

// Enum CrabChampions.ECrabBlessing
// NumValues: 0x0005
enum class ECrabBlessing : uint8
{
	None                                     = 0,
	Flawless                                 = 1,
	Rush                                     = 2,
	Last                                     = 3,
	ECrabBlessing_MAX                        = 4,
};

// Enum CrabChampions.ECrabChallengeModifier
// NumValues: 0x0013
enum class ECrabChallengeModifier : uint8
{
	None                                     = 0,
	OneHit                                   = 1,
	MirroredProjectiles                      = 2,
	Shrapnel                                 = 3,
	HomingThorns                             = 4,
	HomingBarrels                            = 5,
	ElementalExplosions                      = 6,
	EnergyRings                              = 7,
	SpikeStrikes                             = 8,
	TwinnedEnemies                           = 9,
	ArmoredEnemies                           = 10,
	HealingEnemies                           = 11,
	SpeedyEnemies                            = 12,
	IcyEnemies                               = 13,
	ExplosiveEnemies                         = 14,
	BarrelRain                               = 15,
	LandmineRain                             = 16,
	Last                                     = 17,
	ECrabChallengeModifier_MAX               = 18,
};

// Enum CrabChampions.ECrabContractType
// NumValues: 0x000A
enum class ECrabContractType : uint8
{
	None                                     = 0,
	TimeTrial                                = 1,
	NoHeals                                  = 2,
	Pacifist                                 = 3,
	ShieldedElite                            = 4,
	Zombies                                  = 5,
	Clones                                   = 6,
	Chaos                                    = 7,
	Last                                     = 8,
	ECrabContractType_MAX                    = 9,
};

// Enum CrabChampions.ECrabIslandType
// NumValues: 0x0014
enum class ECrabIslandType : uint8
{
	None                                     = 0,
	Lobby                                    = 1,
	NewRun                                   = 2,
	ContinueRun                              = 3,
	Arena                                    = 4,
	Horde                                    = 5,
	Waves                                    = 6,
	Harvest                                  = 7,
	Demolition                               = 8,
	Parkour                                  = 9,
	Shop                                     = 10,
	Elite                                    = 11,
	Boss                                     = 12,
	Biome                                    = 13,
	CrabIsland                               = 14,
	Loop                                     = 15,
	Arcade                                   = 16,
	Holdout                                  = 17,
	Duel                                     = 18,
	ECrabIslandType_MAX                      = 19,
};

// Enum CrabChampions.ECrabRank
// NumValues: 0x0009
enum class ECrabRank : uint8
{
	None                                     = 0,
	Bronze                                   = 1,
	Silver                                   = 2,
	Gold                                     = 3,
	Sapphire                                 = 4,
	Emerald                                  = 5,
	Ruby                                     = 6,
	Diamond                                  = 7,
	ECrabRank_MAX                            = 8,
};

// Enum CrabChampions.ECrabDifficultyModifier
// NumValues: 0x000D
enum class ECrabDifficultyModifier : uint8
{
	RegeneratingEnemies                      = 0,
	LockedSlots                              = 1,
	BuffedEnemies                            = 2,
	ResurrectingEnemies                      = 3,
	ExpensiveShops                           = 4,
	DoubleChallenge                          = 5,
	EvolvedEnemies                           = 6,
	LimitedHeals                             = 7,
	EternalPunishment                        = 8,
	UnfairBosses                             = 9,
	NoSafetyNet                              = 10,
	Last                                     = 11,
	ECrabDifficultyModifier_MAX              = 12,
};

// Enum CrabChampions.ECrabDifficulty
// NumValues: 0x0005
enum class ECrabDifficulty : uint8
{
	Easy                                     = 0,
	Normal                                   = 1,
	Nightmare                                = 2,
	UltraChaos                               = 3,
	ECrabDifficulty_MAX                      = 4,
};

// Enum CrabChampions.ECrabTotemType
// NumValues: 0x0014
enum class ECrabTotemType : uint8
{
	None                                     = 0,
	Cosmetics                                = 1,
	Difficulty                               = 2,
	Key                                      = 3,
	Multiplayer                              = 4,
	Health                                   = 5,
	Crystal                                  = 6,
	Loot                                     = 7,
	Gold                                     = 8,
	Glass                                    = 9,
	Fuse                                     = 10,
	Greed                                    = 11,
	Chance                                   = 12,
	Gamble                                   = 13,
	Random                                   = 14,
	Contract                                 = 15,
	XL                                       = 16,
	Reroll                                   = 17,
	Enhancement                              = 18,
	ECrabTotemType_MAX                       = 19,
};

// Enum CrabChampions.ECrabConsumableType
// NumValues: 0x0007
enum class ECrabConsumableType : uint8
{
	None                                     = 0,
	Armor                                    = 1,
	Health                                   = 2,
	MaxHealth                                = 3,
	Crystal                                  = 4,
	Key                                      = 5,
	ECrabConsumableType_MAX                  = 6,
};

// Enum CrabChampions.ECrabRelicType
// NumValues: 0x0036
enum class ECrabRelicType : uint8
{
	None                                     = 0,
	RingOfHealing                            = 1,
	RingOfArmor                              = 2,
	RingOfParrying                           = 3,
	RingOfHealthyTurrets                     = 4,
	RingOfFury                               = 5,
	RingOfWisdom                             = 6,
	AdrenalineAmulet                         = 7,
	RingOfDestruction                        = 8,
	AncientBlade                             = 9,
	PortalRing                               = 10,
	RingOfRevolution                         = 11,
	TurboRing                                = 12,
	RingOfReloading                          = 13,
	CoralAmulet                              = 14,
	RubyDice                                 = 15,
	TonysRing                                = 16,
	ComboRing                                = 17,
	TonysAmulet                              = 18,
	RingOfValue                              = 19,
	EtherealArmor                            = 20,
	RingOfReinforcement                      = 21,
	RingOfDefense                            = 22,
	RingOfDeflection                         = 23,
	RingOfRepulsion                          = 24,
	RingOfPower                              = 25,
	RingOfPrecision                          = 26,
	IceRing                                  = 27,
	FireRing                                 = 28,
	LightningRing                            = 29,
	PoisonRing                               = 30,
	ChaoticRing                              = 31,
	ElementalRing                            = 32,
	AmmoRing                                 = 33,
	RingOfRocketJumping                      = 34,
	SkillRing                                = 35,
	DuplicationRing                          = 36,
	RingOfDividends                          = 37,
	RingOfRegeneratingArmor                  = 38,
	RingOfProtection                         = 39,
	RingOfSwiftness                          = 40,
	RingOfGravity                            = 41,
	RingOfLuck                               = 42,
	RecursiveRing                            = 43,
	GoldenArc                                = 44,
	PortalAmulet                             = 45,
	AbilityRing                              = 46,
	GoldRing                                 = 47,
	TonysCrown                               = 48,
	TwinRing                                 = 49,
	RingOfTankiness                          = 50,
	CursedRing                               = 51,
	RushedRing                               = 52,
	ECrabRelicType_MAX                       = 53,
};

// Enum CrabChampions.ECrabPerkType
// NumValues: 0x007E
enum class ECrabPerkType : uint8
{
	None                                     = 0,
	Fortitude                                = 1,
	ValuedCustomer                           = 2,
	PersonalSpace                            = 3,
	Bullseye                                 = 4,
	BigHearts                                = 5,
	Endurance                                = 6,
	Regenerator                              = 7,
	AmberResin                               = 8,
	HardTarget                               = 9,
	Scavenger                                = 10,
	Vitality                                 = 11,
	SecondWind                               = 12,
	DamageCombo                              = 13,
	SilverLining                             = 14,
	FMJ                                      = 15,
	ElementalExpert                          = 16,
	Sharpshooter                             = 17,
	HotShot                                  = 18,
	PowerPunch                               = 19,
	CriticalThinking                         = 20,
	CriticalArrow                            = 21,
	ChainReaction                            = 22,
	Efficiency                               = 23,
	Autoloader                               = 24,
	SonicBoom                                = 25,
	SpecialDelivery                          = 26,
	TonysBlackCard                           = 27,
	DangerClose                              = 28,
	EagleEye                                 = 29,
	PowerArmor                               = 30,
	Equalizer                                = 31,
	SpeedDemon                               = 32,
	Stamina                                  = 33,
	Slugger                                  = 34,
	ExplosiveArmor                           = 35,
	FlammableArmor                           = 36,
	PoisonousArmor                           = 37,
	Icebreaker                               = 38,
	HotSteam                                 = 39,
	LingeringFumes                           = 40,
	Frostbite                                = 41,
	BubblingAcid                             = 42,
	IceCold                                  = 43,
	Firestarter                              = 44,
	HighVoltage                              = 45,
	Toxic                                    = 46,
	PotentMagic                              = 47,
	CrystalCombo                             = 48,
	Snatcher                                 = 49,
	GoldCoating                              = 50,
	Paycheck                                 = 51,
	CrystalFertilizer                        = 52,
	Driller                                  = 53,
	EnhancedTurrets                          = 54,
	TurboTurrets                             = 55,
	TurretFriendship                         = 56,
	DamageAura                               = 57,
	IceAura                                  = 58,
	FireAura                                 = 59,
	LightningAura                            = 60,
	PoisonAura                               = 61,
	OrbitingScythes                          = 62,
	CrimsonHaze                              = 63,
	Shockwave                                = 64,
	GrimReaper                               = 65,
	GraveDodger                              = 66,
	Bulletproof                              = 67,
	TastyOrange                              = 68,
	Checklist                                = 69,
	Assassin                                 = 70,
	Gemstone                                 = 71,
	Collector                                = 72,
	MoneyIsPower                             = 73,
	HealthIsPower                            = 74,
	SpeedIsPower                             = 75,
	MegaCrit                                 = 76,
	CriticalBlast                            = 77,
	AllYouCanEat                             = 78,
	StreamerLoot                             = 79,
	BigChests                                = 80,
	PerformanceBonus                         = 81,
	DoubleVision                             = 82,
	SturdyTotems                             = 83,
	BonusCrystals                            = 84,
	RareTreasure                             = 85,
	ExplodingEnemies                         = 86,
	FreezingEnemies                          = 87,
	FlammableEnemies                         = 88,
	ElectricEnemies                          = 89,
	PoisonousEnemies                         = 90,
	GoldDice                                 = 91,
	FaultyChests                             = 92,
	CrystalAsteroids                         = 93,
	BonusChests                              = 94,
	CarePackage                              = 95,
	LevelUp                                  = 96,
	DivineBlessing                           = 97,
	CriticalLightning                        = 98,
	IceDash                                  = 99,
	LightningDash                            = 100,
	DaggerDash                               = 101,
	Powerslide                               = 102,
	StormCloud                               = 103,
	LeapOfFaith                              = 104,
	Bribe                                    = 105,
	DoubleTrouble                            = 106,
	Juggernaut                               = 107,
	BigBones                                 = 108,
	GlassCannon                              = 109,
	DamageSeeker                             = 110,
	BruteForce                               = 111,
	ThinkFast                                = 112,
	MetalClaw                                = 113,
	UpTheAnte                                = 114,
	Untouchable                              = 115,
	CursedLottery                            = 116,
	SlipperySlope                            = 117,
	DoubleEdgedSword                         = 118,
	Workaholic                               = 119,
	RisingStar                               = 120,
	LimitedLoot                              = 121,
	FlashSale                                = 122,
	HighRoller                               = 123,
	Hoarder                                  = 124,
	ECrabPerkType_MAX                        = 125,
};

// Enum CrabChampions.ECrabMeleeModType
// NumValues: 0x000C
enum class ECrabMeleeModType : uint8
{
	None                                     = 0,
	Vampire                                  = 1,
	BigClaws                                 = 2,
	SharpClaws                               = 3,
	IronClaws                                = 4,
	Blender                                  = 5,
	IceClaws                                 = 6,
	FireClaws                                = 7,
	LightningClaws                           = 8,
	PoisonClaws                              = 9,
	Brawler                                  = 10,
	ECrabMeleeModType_MAX                    = 11,
};

// Enum CrabChampions.ECrabAbilityModType
// NumValues: 0x003E
enum class ECrabAbilityModType : uint8
{
	None                                     = 0,
	LightExplosion                           = 1,
	GlueExplosion                            = 2,
	ChaoticExplosion                         = 3,
	BigAbility                               = 4,
	ImplodingExplosion                       = 5,
	IronExplosion                            = 6,
	TimeExplosion                            = 7,
	BiggerBoom                               = 8,
	WeakExplosion                            = 9,
	SlowExplosion                            = 10,
	HeatSink                                 = 11,
	BouncingExplosion                        = 12,
	DamageExplosion                          = 13,
	ImpactExplosion                          = 14,
	TripleAbility                            = 15,
	LayeredExplosion                         = 16,
	SplitExplosion                           = 17,
	ScatterExplosion                         = 18,
	AuraExplosion                            = 19,
	BubbleBlast                              = 20,
	DaggerBlast                              = 21,
	FireworkExplosion                        = 22,
	ThornExplosion                           = 23,
	SparkExplosion                           = 24,
	ShrapnelExplosion                        = 25,
	BarrelExplosion                          = 26,
	LandmineExplosion                        = 27,
	ElementalExplosion                       = 28,
	PopcornExplosion                         = 29,
	GiantDrill                               = 30,
	LightningBeam                            = 31,
	PoisonVines                              = 32,
	ToxicCloud                               = 33,
	ArcaneRift                               = 34,
	ArtilleryStrike                          = 35,
	TurretExplosion                          = 36,
	SentryTurret                             = 37,
	SniperTurret                             = 38,
	Grenadier                                = 39,
	DamagingCast                             = 40,
	HealingCast                              = 41,
	CloneExplosion                           = 42,
	BombExplosion                            = 43,
	SpinningBlade                            = 44,
	SporeExplosion                           = 45,
	UltraMushroom                            = 46,
	ScytheVortex                             = 47,
	CrystalBarrage                           = 48,
	EnergyRing                               = 49,
	MOAB                                     = 50,
	StarfishExplosion                        = 51,
	IceExplosion                             = 52,
	FireExplosion                            = 53,
	LightningExplosion                       = 54,
	PoisonExplosion                          = 55,
	SpikeStrike                              = 56,
	CrystalStrike                            = 57,
	FireTurret                               = 58,
	PoisonTurret                             = 59,
	MortarTurret                             = 60,
	ECrabAbilityModType_MAX                  = 61,
};

// Enum CrabChampions.ECrabWeaponModType
// NumValues: 0x005A
enum class ECrabWeaponModType : uint8
{
	None                                     = 0,
	BouncingShot                             = 1,
	AcceleratingShot                         = 2,
	ZigZagShot                               = 3,
	SpiralShot                               = 4,
	SnakeShot                                = 5,
	ChaoticShot                              = 6,
	BoomerangShot                            = 7,
	OrbitingShot                             = 8,
	RecoilShot                               = 9,
	FastShot                                 = 10,
	HealthShot                               = 11,
	BigMag                                   = 12,
	HighCaliber                              = 13,
	WindUp                                   = 14,
	SteadyShot                               = 15,
	TrickShot                                = 16,
	AerialShot                               = 17,
	GripTape                                 = 18,
	BlindFire                                = 19,
	MoneyShot                                = 20,
	TimeShot                                 = 21,
	TimeBolt                                 = 22,
	UltraShot                                = 23,
	SharpShot                                = 24,
	GlueShot                                 = 25,
	BigShot                                  = 26,
	StreakShot                               = 27,
	MagShot                                  = 28,
	Uppercut                                 = 29,
	HeavyShot                                = 30,
	HeavyHitter                              = 31,
	RapidFire                                = 32,
	LightShot                                = 33,
	EscalatingShot                           = 34,
	IceShot                                  = 35,
	FireShot                                 = 36,
	LightningShot                            = 37,
	PoisonShot                               = 38,
	ArcaneShot                               = 39,
	RandomShot                               = 40,
	ReloadArc                                = 41,
	TripleShot                               = 42,
	ArcShot                                  = 43,
	SplitShot                                = 44,
	ScatterShot                              = 45,
	TargetingShot                            = 46,
	LinkShot                                 = 47,
	DrillShot                                = 48,
	DamageShot                               = 49,
	Supercharged                             = 50,
	Juiced                                   = 51,
	AuraShot                                 = 52,
	PiercingShot                             = 53,
	BubbleShot                               = 54,
	PopcornShot                              = 55,
	PumpkinShot                              = 56,
	DaggerArc                                = 57,
	PiercingWave                             = 58,
	ArcaneBlast                              = 59,
	ShotgunBlast                             = 60,
	MaceShot                                 = 61,
	FireworkShot                             = 62,
	ThornShot                                = 63,
	SparkShot                                = 64,
	Firepower                                = 65,
	XShot                                    = 66,
	SquareShot                               = 67,
	HomingShot                               = 68,
	DoubleTap                                = 69,
	SplashDamage                             = 70,
	ProximityBarrage                         = 71,
	HomingBlades                             = 72,
	BombShot                                 = 73,
	LandmineShot                             = 74,
	TorpedoShot                              = 75,
	FireballShot                             = 76,
	SharpenedAxe                             = 77,
	TriangleShot                             = 78,
	SporeShot                                = 79,
	IceStorm                                 = 80,
	FireStorm                                = 81,
	LightningStorm                           = 82,
	PoisonStorm                              = 83,
	IceStrike                                = 84,
	FireStrike                               = 85,
	LightningStrike                          = 86,
	PoisonStrike                             = 87,
	SpikeStrike                              = 88,
	ECrabWeaponModType_MAX                   = 89,
};

// Enum CrabChampions.ECrabCurrencyType
// NumValues: 0x0004
enum class ECrabCurrencyType : uint8
{
	Crystal                                  = 0,
	Key                                      = 1,
	Health                                   = 2,
	ECrabCurrencyType_MAX                    = 3,
};

// Enum CrabChampions.ECrabEnhancementType
// NumValues: 0x000F
enum class ECrabEnhancementType : uint8
{
	None                                     = 0,
	Snaking                                  = 1,
	Sticky                                   = 2,
	Freezing                                 = 3,
	Flaming                                  = 4,
	Electrifying                             = 5,
	Toxifying                                = 6,
	Arcanifying                              = 7,
	Damaging                                 = 8,
	Targeting                                = 9,
	Splitting                                = 10,
	Scattering                               = 11,
	Homing                                   = 12,
	Last                                     = 13,
	ECrabEnhancementType_MAX                 = 14,
};

// Enum CrabChampions.ECrabEnhanceableType
// NumValues: 0x0005
enum class ECrabEnhanceableType : uint8
{
	NotEnhanceable                           = 0,
	Enhanceable                              = 1,
	EnhanceableNonElemental                  = 2,
	EnhanceableNonHoming                     = 3,
	ECrabEnhanceableType_MAX                 = 4,
};

// Enum CrabChampions.ECrabPickupTag
// NumValues: 0x000A
enum class ECrabPickupTag : uint8
{
	None                                     = 0,
	Critical                                 = 1,
	Bounce                                   = 2,
	Ice                                      = 3,
	Fire                                     = 4,
	Lightning                                = 5,
	Poison                                   = 6,
	Arcane                                   = 7,
	Turret                                   = 8,
	ECrabPickupTag_MAX                       = 9,
};

// Enum CrabChampions.ECrabRarity
// NumValues: 0x0006
enum class ECrabRarity : uint8
{
	None                                     = 0,
	Rare                                     = 1,
	Epic                                     = 2,
	Legendary                                = 3,
	Greed                                    = 4,
	ECrabRarity_MAX                          = 5,
};

// Enum CrabChampions.ECrabLootPool
// NumValues: 0x0015
enum class ECrabLootPool : uint8
{
	None                                     = 0,
	Damage                                   = 1,
	Critical                                 = 2,
	Elemental                                = 3,
	Speed                                    = 4,
	Luck                                     = 5,
	Health                                   = 6,
	Economy                                  = 7,
	Skill                                    = 8,
	Greed                                    = 9,
	Upgrade                                  = 10,
	Random                                   = 11,
	RelicChest                               = 12,
	SpikedChest                              = 13,
	EpicChest                                = 14,
	LegendaryChest                           = 15,
	HealingChest                             = 16,
	KeyChest                                 = 17,
	Lesser                                   = 18,
	NoRelicsOrConsumables                    = 19,
	ECrabLootPool_MAX                        = 20,
};

// Enum CrabChampions.ECrabPickupType
// NumValues: 0x000C
enum class ECrabPickupType : uint8
{
	None                                     = 0,
	Weapon                                   = 1,
	Ability                                  = 2,
	Melee                                    = 3,
	WeaponMod                                = 4,
	AbilityMod                               = 5,
	MeleeMod                                 = 6,
	Perk                                     = 7,
	Relic                                    = 8,
	Consumable                               = 9,
	Random                                   = 10,
	ECrabPickupType_MAX                      = 11,
};

// Enum CrabChampions.ECrabLesserProjectileType
// NumValues: 0x0024
enum class ECrabLesserProjectileType : uint8
{
	None                                     = 0,
	Duplicate                                = 1,
	Generic                                  = 2,
	TimeBolt                                 = 3,
	UltraShot                                = 4,
	ReloadArc                                = 5,
	LinkShot                                 = 6,
	DrillShot                                = 7,
	BubbleShot                               = 8,
	PumpkinShot                              = 9,
	DaggerArc                                = 10,
	PiercingWave                             = 11,
	ArcaneBlast                              = 12,
	ShotgunBlast                             = 13,
	MaceShot                                 = 14,
	FireworkShot                             = 15,
	ThornShot                                = 16,
	SparkShot                                = 17,
	ProximityBarrage                         = 18,
	HomingBlade                              = 19,
	BombShot                                 = 20,
	TorpedoShot                              = 21,
	FireballShot                             = 22,
	SharpenedAxe                             = 23,
	TriangleShot                             = 24,
	BubbleBlast                              = 25,
	DaggerBlast                              = 26,
	FireworkExplosion                        = 27,
	ThornExplosion                           = 28,
	SparkExplosion                           = 29,
	CloneExplosion                           = 30,
	BombExplosion                            = 31,
	SpinningBlade                            = 32,
	OrbitingScythe                           = 33,
	DaggerDash                               = 34,
	ECrabLesserProjectileType_MAX            = 35,
};

// Enum CrabChampions.ECrabFormationType
// NumValues: 0x0019
enum class ECrabFormationType : uint8
{
	Single                                   = 0,
	Double                                   = 1,
	Triple                                   = 2,
	Quad                                     = 3,
	SmallCluster                             = 4,
	MediumCluster                            = 5,
	LargeCluster                             = 6,
	SmallArc                                 = 7,
	LargeArc                                 = 8,
	LargeArcTightSpread                      = 9,
	TripleArc                                = 10,
	Box                                      = 11,
	Triangle                                 = 12,
	X                                        = 13,
	Square                                   = 14,
	LargeSquare                              = 15,
	Circle                                   = 16,
	LargeCircle                              = 17,
	Line                                     = 18,
	Cross                                    = 19,
	Ring                                     = 20,
	MediumRing                               = 21,
	LargeRing                                = 22,
	Random                                   = 23,
	ECrabFormationType_MAX                   = 24,
};

// Enum CrabChampions.ECrabHitmarkerType
// NumValues: 0x0004
enum class ECrabHitmarkerType : uint8
{
	Quiet                                    = 0,
	Normal                                   = 1,
	Loud                                     = 2,
	ECrabHitmarkerType_MAX                   = 3,
};

// Enum CrabChampions.ECrabCrosshairType
// NumValues: 0x0006
enum class ECrabCrosshairType : uint8
{
	None                                     = 0,
	Cross                                    = 1,
	HalfCross                                = 2,
	Circle                                   = 3,
	SniperScope                              = 4,
	ECrabCrosshairType_MAX                   = 5,
};

// Enum CrabChampions.ECrabDamageHitType
// NumValues: 0x0007
enum class ECrabDamageHitType : uint8
{
	None                                     = 0,
	Armor                                    = 1,
	ArmorBreak                               = 2,
	Health                                   = 3,
	Crit                                     = 4,
	Elimination                              = 5,
	ECrabDamageHitType_MAX                   = 6,
};

// Enum CrabChampions.ECrabDebuffType
// NumValues: 0x0008
enum class ECrabDebuffType : uint8
{
	None                                     = 0,
	Ice                                      = 1,
	Fire                                     = 2,
	Lightning                                = 3,
	Poison                                   = 4,
	Arcane                                   = 5,
	Last                                     = 6,
	ECrabDebuffType_MAX                      = 7,
};

// Enum CrabChampions.ECrabDamageType
// NumValues: 0x000E
enum class ECrabDamageType : uint8
{
	None                                     = 0,
	Radial                                   = 1,
	Ability                                  = 2,
	Melee                                    = 3,
	Lesser                                   = 4,
	Knockback                                = 5,
	DOT                                      = 6,
	Ice                                      = 7,
	Fire                                     = 8,
	Lightning                                = 9,
	Arcane                                   = 10,
	Hazard                                   = 11,
	Unblockable                              = 12,
	ECrabDamageType_MAX                      = 13,
};

// Enum CrabChampions.ECrabSpawnPointType
// NumValues: 0x0009
enum class ECrabSpawnPointType : uint8
{
	Player                                   = 0,
	Destructible                             = 1,
	Totem                                    = 2,
	Secret                                   = 3,
	Enemy                                    = 4,
	Reward                                   = 5,
	Portal                                   = 6,
	Shop                                     = 7,
	ECrabSpawnPointType_MAX                  = 8,
};

// Enum CrabChampions.ECrabBiome
// NumValues: 0x0006
enum class ECrabBiome : uint8
{
	None                                     = 0,
	Tropical                                 = 1,
	Arctic                                   = 2,
	Desert                                   = 3,
	Volcanic                                 = 4,
	ECrabBiome_MAX                           = 5,
};

// Enum CrabChampions.ECrabMatchState
// NumValues: 0x0009
enum class ECrabMatchState : uint8
{
	None                                     = 0,
	WaitingToStart                           = 1,
	PortalCountdown                          = 2,
	StartedIsland                            = 3,
	ClearedIsland                            = 4,
	AllPlayersEliminated                     = 5,
	GameOver                                 = 6,
	Restarting                               = 7,
	ECrabMatchState_MAX                      = 8,
};

// Enum CrabChampions.ECrabCosmeticType
// NumValues: 0x0003
enum class ECrabCosmeticType : uint8
{
	CrabSkin                                 = 0,
	WeaponSkin                               = 1,
	ECrabCosmeticType_MAX                    = 2,
};

// Enum CrabChampions.ECrabShotSpawnType
// NumValues: 0x0003
enum class ECrabShotSpawnType : uint8
{
	Muzzle                                   = 0,
	AboveCrosshair                           = 1,
	ECrabShotSpawnType_MAX                   = 2,
};

// Enum CrabChampions.ECrabFireMode
// NumValues: 0x0003
enum class ECrabFireMode : uint8
{
	Automatic                                = 0,
	Burst                                    = 1,
	ECrabFireMode_MAX                        = 2,
};

// ScriptStruct CrabChampions.CrabCosmetic
// 0x0028 (0x0028 - 0x0000)
struct FCrabCosmetic final
{
public:
	ECrabCosmeticType                             CosmeticType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C2[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CosmeticName;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             CosmeticIcon;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                CosmeticObject;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabCosmetic) == 0x000008, "Wrong alignment on FCrabCosmetic");
static_assert(sizeof(FCrabCosmetic) == 0x000028, "Wrong size on FCrabCosmetic");
static_assert(offsetof(FCrabCosmetic, CosmeticType) == 0x000000, "Member 'FCrabCosmetic::CosmeticType' has a wrong offset!");
static_assert(offsetof(FCrabCosmetic, CosmeticName) == 0x000008, "Member 'FCrabCosmetic::CosmeticName' has a wrong offset!");
static_assert(offsetof(FCrabCosmetic, CosmeticIcon) == 0x000018, "Member 'FCrabCosmetic::CosmeticIcon' has a wrong offset!");
static_assert(offsetof(FCrabCosmetic, CosmeticObject) == 0x000020, "Member 'FCrabCosmetic::CosmeticObject' has a wrong offset!");

// ScriptStruct CrabChampions.CrabChallenge
// 0x0050 (0x0050 - 0x0000)
struct FCrabChallenge final
{
public:
	class FName                                   ChallengeID;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChallengeDescription;                              // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengeProgress;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengeGoal;                                     // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChallengeCompleted;                               // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C3[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabCosmetic                          CosmeticReward;                                    // 0x0028(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabChallenge) == 0x000008, "Wrong alignment on FCrabChallenge");
static_assert(sizeof(FCrabChallenge) == 0x000050, "Wrong size on FCrabChallenge");
static_assert(offsetof(FCrabChallenge, ChallengeID) == 0x000000, "Member 'FCrabChallenge::ChallengeID' has a wrong offset!");
static_assert(offsetof(FCrabChallenge, ChallengeDescription) == 0x000008, "Member 'FCrabChallenge::ChallengeDescription' has a wrong offset!");
static_assert(offsetof(FCrabChallenge, ChallengeProgress) == 0x000018, "Member 'FCrabChallenge::ChallengeProgress' has a wrong offset!");
static_assert(offsetof(FCrabChallenge, ChallengeGoal) == 0x00001C, "Member 'FCrabChallenge::ChallengeGoal' has a wrong offset!");
static_assert(offsetof(FCrabChallenge, bChallengeCompleted) == 0x000020, "Member 'FCrabChallenge::bChallengeCompleted' has a wrong offset!");
static_assert(offsetof(FCrabChallenge, CosmeticReward) == 0x000028, "Member 'FCrabChallenge::CosmeticReward' has a wrong offset!");

// ScriptStruct CrabChampions.CrabPickupsSpawnInfo
// 0x0020 (0x0020 - 0x0000)
struct FCrabPickupsSpawnInfo final
{
public:
	TArray<class UCrabPickupDA*>                  PickupsToSpawn;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        SpawnLocs;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabPickupsSpawnInfo) == 0x000008, "Wrong alignment on FCrabPickupsSpawnInfo");
static_assert(sizeof(FCrabPickupsSpawnInfo) == 0x000020, "Wrong size on FCrabPickupsSpawnInfo");
static_assert(offsetof(FCrabPickupsSpawnInfo, PickupsToSpawn) == 0x000000, "Member 'FCrabPickupsSpawnInfo::PickupsToSpawn' has a wrong offset!");
static_assert(offsetof(FCrabPickupsSpawnInfo, SpawnLocs) == 0x000010, "Member 'FCrabPickupsSpawnInfo::SpawnLocs' has a wrong offset!");

// ScriptStruct CrabChampions.ClientAuthoritativeMoveData
// 0x0050 (0x0050 - 0x0000)
struct FClientAuthoritativeMoveData final
{
public:
	struct FVector_NetQuantize10                  Location;                                          // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  Velocity;                                          // 0x0018(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ControlRotation;                                   // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         MovementMode;                                      // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C4[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    BasedMovementBase;                                 // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BasedMovementBaseBoneName;                         // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBasedHasRelativeRotation;                         // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C5[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientAuthoritativeMoveData) == 0x000008, "Wrong alignment on FClientAuthoritativeMoveData");
static_assert(sizeof(FClientAuthoritativeMoveData) == 0x000050, "Wrong size on FClientAuthoritativeMoveData");
static_assert(offsetof(FClientAuthoritativeMoveData, Location) == 0x000000, "Member 'FClientAuthoritativeMoveData::Location' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, Rotation) == 0x00000C, "Member 'FClientAuthoritativeMoveData::Rotation' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, Velocity) == 0x000018, "Member 'FClientAuthoritativeMoveData::Velocity' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, ControlRotation) == 0x000024, "Member 'FClientAuthoritativeMoveData::ControlRotation' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, MovementMode) == 0x000030, "Member 'FClientAuthoritativeMoveData::MovementMode' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, BasedMovementBase) == 0x000038, "Member 'FClientAuthoritativeMoveData::BasedMovementBase' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, BasedMovementBaseBoneName) == 0x000040, "Member 'FClientAuthoritativeMoveData::BasedMovementBaseBoneName' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, bBasedHasRelativeRotation) == 0x000048, "Member 'FClientAuthoritativeMoveData::bBasedHasRelativeRotation' has a wrong offset!");

// ScriptStruct CrabChampions.CrabEnemySpawnSettings
// 0x0028 (0x0028 - 0x0000)
struct FCrabEnemySpawnSettings final
{
public:
	int32                                         IslandToStartSpawningAt;                           // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlySpawnIfLooping;                               // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C6[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabIslandType>                       BannedIslandTypes;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsEvolvedEnemy;                                   // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExplosiveEnemy;                                 // 0x0019(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C7[0x2];                                     // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnCost;                                         // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnWeight;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnLimit;                                        // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabEnemySpawnSettings) == 0x000008, "Wrong alignment on FCrabEnemySpawnSettings");
static_assert(sizeof(FCrabEnemySpawnSettings) == 0x000028, "Wrong size on FCrabEnemySpawnSettings");
static_assert(offsetof(FCrabEnemySpawnSettings, IslandToStartSpawningAt) == 0x000000, "Member 'FCrabEnemySpawnSettings::IslandToStartSpawningAt' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, bOnlySpawnIfLooping) == 0x000004, "Member 'FCrabEnemySpawnSettings::bOnlySpawnIfLooping' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, BannedIslandTypes) == 0x000008, "Member 'FCrabEnemySpawnSettings::BannedIslandTypes' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, bIsEvolvedEnemy) == 0x000018, "Member 'FCrabEnemySpawnSettings::bIsEvolvedEnemy' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, bIsExplosiveEnemy) == 0x000019, "Member 'FCrabEnemySpawnSettings::bIsExplosiveEnemy' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, SpawnCost) == 0x00001C, "Member 'FCrabEnemySpawnSettings::SpawnCost' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, SpawnWeight) == 0x000020, "Member 'FCrabEnemySpawnSettings::SpawnWeight' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, SpawnLimit) == 0x000024, "Member 'FCrabEnemySpawnSettings::SpawnLimit' has a wrong offset!");

// ScriptStruct CrabChampions.CrabLightingPreset
// 0x00A0 (0x00A0 - 0x0000)
struct FCrabLightingPreset final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C8[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     SkydomeMI;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkydomeRotation;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DLHeight;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DLRotation;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DLIntensity;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DLTint;                                            // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SLIntensity;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SLTint;                                            // 0x0034(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SLHemisphereTint;                                  // 0x0044(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SLMinOcclusion;                                    // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 SLOcclusionTint;                                   // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PPTemperature;                                     // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HFDensity;                                         // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HFHeightFalloff;                                   // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HFTint;                                            // 0x0068(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HFStartDistance;                                   // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C9[0x4];                                     // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     OceanMI;                                           // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           UnderwaterPPTint;                                  // 0x0088(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabBiomeDA*                           BiomeDA;                                           // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabLightingPreset) == 0x000008, "Wrong alignment on FCrabLightingPreset");
static_assert(sizeof(FCrabLightingPreset) == 0x0000A0, "Wrong size on FCrabLightingPreset");
static_assert(offsetof(FCrabLightingPreset, Weight) == 0x000000, "Member 'FCrabLightingPreset::Weight' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SkydomeMI) == 0x000008, "Member 'FCrabLightingPreset::SkydomeMI' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SkydomeRotation) == 0x000010, "Member 'FCrabLightingPreset::SkydomeRotation' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, DLHeight) == 0x000014, "Member 'FCrabLightingPreset::DLHeight' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, DLRotation) == 0x000018, "Member 'FCrabLightingPreset::DLRotation' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, DLIntensity) == 0x00001C, "Member 'FCrabLightingPreset::DLIntensity' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, DLTint) == 0x000020, "Member 'FCrabLightingPreset::DLTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SLIntensity) == 0x000030, "Member 'FCrabLightingPreset::SLIntensity' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SLTint) == 0x000034, "Member 'FCrabLightingPreset::SLTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SLHemisphereTint) == 0x000044, "Member 'FCrabLightingPreset::SLHemisphereTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SLMinOcclusion) == 0x000054, "Member 'FCrabLightingPreset::SLMinOcclusion' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SLOcclusionTint) == 0x000058, "Member 'FCrabLightingPreset::SLOcclusionTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, PPTemperature) == 0x00005C, "Member 'FCrabLightingPreset::PPTemperature' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, HFDensity) == 0x000060, "Member 'FCrabLightingPreset::HFDensity' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, HFHeightFalloff) == 0x000064, "Member 'FCrabLightingPreset::HFHeightFalloff' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, HFTint) == 0x000068, "Member 'FCrabLightingPreset::HFTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, HFStartDistance) == 0x000078, "Member 'FCrabLightingPreset::HFStartDistance' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, OceanMI) == 0x000080, "Member 'FCrabLightingPreset::OceanMI' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, UnderwaterPPTint) == 0x000088, "Member 'FCrabLightingPreset::UnderwaterPPTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, BiomeDA) == 0x000098, "Member 'FCrabLightingPreset::BiomeDA' has a wrong offset!");

// ScriptStruct CrabChampions.CrabProjectileModInfo
// 0x0028 (0x0028 - 0x0000)
struct FCrabProjectileModInfo final
{
public:
	float                                         DamageMultiplier;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlatDamageBonus;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusMultiplier;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifetimeMultiplier;                                // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SizeMultiplier;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMultiplier;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationBonus;                                 // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityMultiplier;                                 // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingMultiplier;                                  // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBounces;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabProjectileModInfo) == 0x000004, "Wrong alignment on FCrabProjectileModInfo");
static_assert(sizeof(FCrabProjectileModInfo) == 0x000028, "Wrong size on FCrabProjectileModInfo");
static_assert(offsetof(FCrabProjectileModInfo, DamageMultiplier) == 0x000000, "Member 'FCrabProjectileModInfo::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, FlatDamageBonus) == 0x000004, "Member 'FCrabProjectileModInfo::FlatDamageBonus' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, RadiusMultiplier) == 0x000008, "Member 'FCrabProjectileModInfo::RadiusMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, LifetimeMultiplier) == 0x00000C, "Member 'FCrabProjectileModInfo::LifetimeMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, SizeMultiplier) == 0x000010, "Member 'FCrabProjectileModInfo::SizeMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, SpeedMultiplier) == 0x000014, "Member 'FCrabProjectileModInfo::SpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, AccelerationBonus) == 0x000018, "Member 'FCrabProjectileModInfo::AccelerationBonus' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, GravityMultiplier) == 0x00001C, "Member 'FCrabProjectileModInfo::GravityMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, HomingMultiplier) == 0x000020, "Member 'FCrabProjectileModInfo::HomingMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, NumBounces) == 0x000024, "Member 'FCrabProjectileModInfo::NumBounces' has a wrong offset!");

// ScriptStruct CrabChampions.CrabLobbyStats
// 0x0058 (0x0058 - 0x0000)
struct FCrabLobbyStats final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Difficulty;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HighScore;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attempts;                                          // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Wins;                                              // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WinStreak;                                         // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HighestIslandReached;                              // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCompletedChallenges;                            // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedWeapons;                                // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedAbilities;                              // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedMeleeWeapons;                           // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedWeaponMods;                             // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedAbilityMods;                            // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedMeleeMods;                              // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedPerks;                                  // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedRelics;                                 // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabLobbyStats) == 0x000008, "Wrong alignment on FCrabLobbyStats");
static_assert(sizeof(FCrabLobbyStats) == 0x000058, "Wrong size on FCrabLobbyStats");
static_assert(offsetof(FCrabLobbyStats, PlayerName) == 0x000000, "Member 'FCrabLobbyStats::PlayerName' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, Difficulty) == 0x000010, "Member 'FCrabLobbyStats::Difficulty' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, HighScore) == 0x000020, "Member 'FCrabLobbyStats::HighScore' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, Attempts) == 0x000024, "Member 'FCrabLobbyStats::Attempts' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, Wins) == 0x000028, "Member 'FCrabLobbyStats::Wins' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, WinStreak) == 0x00002C, "Member 'FCrabLobbyStats::WinStreak' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, HighestIslandReached) == 0x000030, "Member 'FCrabLobbyStats::HighestIslandReached' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumCompletedChallenges) == 0x000034, "Member 'FCrabLobbyStats::NumCompletedChallenges' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedWeapons) == 0x000038, "Member 'FCrabLobbyStats::NumUnlockedWeapons' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedAbilities) == 0x00003C, "Member 'FCrabLobbyStats::NumUnlockedAbilities' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedMeleeWeapons) == 0x000040, "Member 'FCrabLobbyStats::NumUnlockedMeleeWeapons' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedWeaponMods) == 0x000044, "Member 'FCrabLobbyStats::NumUnlockedWeaponMods' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedAbilityMods) == 0x000048, "Member 'FCrabLobbyStats::NumUnlockedAbilityMods' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedMeleeMods) == 0x00004C, "Member 'FCrabLobbyStats::NumUnlockedMeleeMods' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedPerks) == 0x000050, "Member 'FCrabLobbyStats::NumUnlockedPerks' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedRelics) == 0x000054, "Member 'FCrabLobbyStats::NumUnlockedRelics' has a wrong offset!");

// ScriptStruct CrabChampions.CrabInventoryInfo
// 0x0020 (0x0020 - 0x0000)
struct FCrabInventoryInfo final
{
public:
	uint8                                         Level;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13CA[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabEnhancementType>                  Enhancements;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AccumulatedBuff;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13CB[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabInventoryInfo) == 0x000008, "Wrong alignment on FCrabInventoryInfo");
static_assert(sizeof(FCrabInventoryInfo) == 0x000020, "Wrong size on FCrabInventoryInfo");
static_assert(offsetof(FCrabInventoryInfo, Level) == 0x000000, "Member 'FCrabInventoryInfo::Level' has a wrong offset!");
static_assert(offsetof(FCrabInventoryInfo, Enhancements) == 0x000008, "Member 'FCrabInventoryInfo::Enhancements' has a wrong offset!");
static_assert(offsetof(FCrabInventoryInfo, AccumulatedBuff) == 0x000018, "Member 'FCrabInventoryInfo::AccumulatedBuff' has a wrong offset!");

// ScriptStruct CrabChampions.CrabMeleeMod
// 0x0028 (0x0028 - 0x0000)
struct FCrabMeleeMod final
{
public:
	class UCrabMeleeModDA*                        MeleeModDA;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0008(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabMeleeMod) == 0x000008, "Wrong alignment on FCrabMeleeMod");
static_assert(sizeof(FCrabMeleeMod) == 0x000028, "Wrong size on FCrabMeleeMod");
static_assert(offsetof(FCrabMeleeMod, MeleeModDA) == 0x000000, "Member 'FCrabMeleeMod::MeleeModDA' has a wrong offset!");
static_assert(offsetof(FCrabMeleeMod, InventoryInfo) == 0x000008, "Member 'FCrabMeleeMod::InventoryInfo' has a wrong offset!");

// ScriptStruct CrabChampions.CrabHealthInfo
// 0x001C (0x001C - 0x0000)
struct FCrabHealthInfo final
{
public:
	int32                                         CurrentArmorPlates;                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentArmorPlateHealth;                           // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousArmorPlateHealth;                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHealth;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentMaxHealth;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousHealth;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousMaxHealth;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabHealthInfo) == 0x000004, "Wrong alignment on FCrabHealthInfo");
static_assert(sizeof(FCrabHealthInfo) == 0x00001C, "Wrong size on FCrabHealthInfo");
static_assert(offsetof(FCrabHealthInfo, CurrentArmorPlates) == 0x000000, "Member 'FCrabHealthInfo::CurrentArmorPlates' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, CurrentArmorPlateHealth) == 0x000004, "Member 'FCrabHealthInfo::CurrentArmorPlateHealth' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, PreviousArmorPlateHealth) == 0x000008, "Member 'FCrabHealthInfo::PreviousArmorPlateHealth' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, CurrentHealth) == 0x00000C, "Member 'FCrabHealthInfo::CurrentHealth' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, CurrentMaxHealth) == 0x000010, "Member 'FCrabHealthInfo::CurrentMaxHealth' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, PreviousHealth) == 0x000014, "Member 'FCrabHealthInfo::PreviousHealth' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, PreviousMaxHealth) == 0x000018, "Member 'FCrabHealthInfo::PreviousMaxHealth' has a wrong offset!");

// ScriptStruct CrabChampions.CrabNextIslandInfo
// 0x0030 (0x0030 - 0x0000)
struct FCrabNextIslandInfo final
{
public:
	ECrabBiome                                    Biome;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13CC[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentIsland;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IslandName;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabIslandType                               IslandType;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13CD[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabChallengeModifier>                ChallengeModifiers;                                // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ECrabBlessing                                 Blessing;                                          // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabLootPool                                 RewardLootPool;                                    // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13CE[0x6];                                     // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabNextIslandInfo) == 0x000008, "Wrong alignment on FCrabNextIslandInfo");
static_assert(sizeof(FCrabNextIslandInfo) == 0x000030, "Wrong size on FCrabNextIslandInfo");
static_assert(offsetof(FCrabNextIslandInfo, Biome) == 0x000000, "Member 'FCrabNextIslandInfo::Biome' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, CurrentIsland) == 0x000004, "Member 'FCrabNextIslandInfo::CurrentIsland' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, IslandName) == 0x000008, "Member 'FCrabNextIslandInfo::IslandName' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, IslandType) == 0x000010, "Member 'FCrabNextIslandInfo::IslandType' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, ChallengeModifiers) == 0x000018, "Member 'FCrabNextIslandInfo::ChallengeModifiers' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, Blessing) == 0x000028, "Member 'FCrabNextIslandInfo::Blessing' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, RewardLootPool) == 0x000029, "Member 'FCrabNextIslandInfo::RewardLootPool' has a wrong offset!");

// ScriptStruct CrabChampions.CrabWeaponMod
// 0x0028 (0x0028 - 0x0000)
struct FCrabWeaponMod final
{
public:
	class UCrabWeaponModDA*                       WeaponModDA;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0008(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabWeaponMod) == 0x000008, "Wrong alignment on FCrabWeaponMod");
static_assert(sizeof(FCrabWeaponMod) == 0x000028, "Wrong size on FCrabWeaponMod");
static_assert(offsetof(FCrabWeaponMod, WeaponModDA) == 0x000000, "Member 'FCrabWeaponMod::WeaponModDA' has a wrong offset!");
static_assert(offsetof(FCrabWeaponMod, InventoryInfo) == 0x000008, "Member 'FCrabWeaponMod::InventoryInfo' has a wrong offset!");

// ScriptStruct CrabChampions.CrabAbilityMod
// 0x0028 (0x0028 - 0x0000)
struct FCrabAbilityMod final
{
public:
	class UCrabAbilityModDA*                      AbilityModDA;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0008(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabAbilityMod) == 0x000008, "Wrong alignment on FCrabAbilityMod");
static_assert(sizeof(FCrabAbilityMod) == 0x000028, "Wrong size on FCrabAbilityMod");
static_assert(offsetof(FCrabAbilityMod, AbilityModDA) == 0x000000, "Member 'FCrabAbilityMod::AbilityModDA' has a wrong offset!");
static_assert(offsetof(FCrabAbilityMod, InventoryInfo) == 0x000008, "Member 'FCrabAbilityMod::InventoryInfo' has a wrong offset!");

// ScriptStruct CrabChampions.CrabPerk
// 0x0028 (0x0028 - 0x0000)
struct FCrabPerk final
{
public:
	class UCrabPerkDA*                            PerkDA;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0008(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabPerk) == 0x000008, "Wrong alignment on FCrabPerk");
static_assert(sizeof(FCrabPerk) == 0x000028, "Wrong size on FCrabPerk");
static_assert(offsetof(FCrabPerk, PerkDA) == 0x000000, "Member 'FCrabPerk::PerkDA' has a wrong offset!");
static_assert(offsetof(FCrabPerk, InventoryInfo) == 0x000008, "Member 'FCrabPerk::InventoryInfo' has a wrong offset!");

// ScriptStruct CrabChampions.CrabRelic
// 0x0028 (0x0028 - 0x0000)
struct FCrabRelic final
{
public:
	class UCrabRelicDA*                           RelicDA;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0008(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabRelic) == 0x000008, "Wrong alignment on FCrabRelic");
static_assert(sizeof(FCrabRelic) == 0x000028, "Wrong size on FCrabRelic");
static_assert(offsetof(FCrabRelic, RelicDA) == 0x000000, "Member 'FCrabRelic::RelicDA' has a wrong offset!");
static_assert(offsetof(FCrabRelic, InventoryInfo) == 0x000008, "Member 'FCrabRelic::InventoryInfo' has a wrong offset!");

// ScriptStruct CrabChampions.CrabAutoSave
// 0x0148 (0x0148 - 0x0000)
struct FCrabAutoSave final
{
public:
	int32                                         CurrentTime;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabDifficulty                               Difficulty;                                        // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13CF[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabDifficultyModifier>               DifficultyModifiers;                               // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCrabNextIslandInfo                    NextIslandInfo;                                    // 0x0018(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         Points;                                            // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ComboCounter;                                      // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Combo;                                             // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Eliminations;                                      // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShotsFired;                                        // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        DamageDealt;                                       // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        HighestDamageDealt;                                // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageTaken;                                       // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumFlawlessIslands;                                // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabHealthInfo                        HealthInfo;                                        // 0x006C(0x001C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxHealthMultiplier;                               // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMultiplier;                                  // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMultiplier;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D0[0x4];                                     // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabWeaponDA*                          WeaponDA;                                          // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabAbilityDA*                         AbilityDA;                                         // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabMeleeDA*                           MeleeDA;                                           // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumWeaponModSlots;                                 // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D1[0x7];                                     // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabWeaponMod>                 WeaponMods;                                        // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         NumAbilityModSlots;                                // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D2[0x7];                                     // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabAbilityMod>                AbilityMods;                                       // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         NumMeleeModSlots;                                  // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D3[0x7];                                     // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabMeleeMod>                  MeleeMods;                                         // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         NumPerkSlots;                                      // 0x00F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D4[0x7];                                     // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabPerk>                      Perks;                                             // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCrabRelic>                     Relics;                                            // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         NumTimesSalvaged;                                  // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumShopPurchases;                                  // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumShopRerolls;                                    // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTotemsDestroyed;                                // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Crystals;                                          // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalTimeTaken;                                    // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCrabChallenge>                 CompletedChallenges;                               // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabAutoSave) == 0x000008, "Wrong alignment on FCrabAutoSave");
static_assert(sizeof(FCrabAutoSave) == 0x000148, "Wrong size on FCrabAutoSave");
static_assert(offsetof(FCrabAutoSave, CurrentTime) == 0x000000, "Member 'FCrabAutoSave::CurrentTime' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Difficulty) == 0x000004, "Member 'FCrabAutoSave::Difficulty' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, DifficultyModifiers) == 0x000008, "Member 'FCrabAutoSave::DifficultyModifiers' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NextIslandInfo) == 0x000018, "Member 'FCrabAutoSave::NextIslandInfo' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Points) == 0x000048, "Member 'FCrabAutoSave::Points' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, ComboCounter) == 0x00004C, "Member 'FCrabAutoSave::ComboCounter' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Combo) == 0x000050, "Member 'FCrabAutoSave::Combo' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Eliminations) == 0x000054, "Member 'FCrabAutoSave::Eliminations' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, ShotsFired) == 0x000058, "Member 'FCrabAutoSave::ShotsFired' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, DamageDealt) == 0x00005C, "Member 'FCrabAutoSave::DamageDealt' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, HighestDamageDealt) == 0x000060, "Member 'FCrabAutoSave::HighestDamageDealt' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, DamageTaken) == 0x000064, "Member 'FCrabAutoSave::DamageTaken' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumFlawlessIslands) == 0x000068, "Member 'FCrabAutoSave::NumFlawlessIslands' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, HealthInfo) == 0x00006C, "Member 'FCrabAutoSave::HealthInfo' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, MaxHealthMultiplier) == 0x000088, "Member 'FCrabAutoSave::MaxHealthMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, DamageMultiplier) == 0x00008C, "Member 'FCrabAutoSave::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, ScaleMultiplier) == 0x000090, "Member 'FCrabAutoSave::ScaleMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, WeaponDA) == 0x000098, "Member 'FCrabAutoSave::WeaponDA' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, AbilityDA) == 0x0000A0, "Member 'FCrabAutoSave::AbilityDA' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, MeleeDA) == 0x0000A8, "Member 'FCrabAutoSave::MeleeDA' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumWeaponModSlots) == 0x0000B0, "Member 'FCrabAutoSave::NumWeaponModSlots' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, WeaponMods) == 0x0000B8, "Member 'FCrabAutoSave::WeaponMods' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumAbilityModSlots) == 0x0000C8, "Member 'FCrabAutoSave::NumAbilityModSlots' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, AbilityMods) == 0x0000D0, "Member 'FCrabAutoSave::AbilityMods' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumMeleeModSlots) == 0x0000E0, "Member 'FCrabAutoSave::NumMeleeModSlots' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, MeleeMods) == 0x0000E8, "Member 'FCrabAutoSave::MeleeMods' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumPerkSlots) == 0x0000F8, "Member 'FCrabAutoSave::NumPerkSlots' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Perks) == 0x000100, "Member 'FCrabAutoSave::Perks' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Relics) == 0x000110, "Member 'FCrabAutoSave::Relics' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumTimesSalvaged) == 0x000120, "Member 'FCrabAutoSave::NumTimesSalvaged' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumShopPurchases) == 0x000124, "Member 'FCrabAutoSave::NumShopPurchases' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumShopRerolls) == 0x000128, "Member 'FCrabAutoSave::NumShopRerolls' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumTotemsDestroyed) == 0x00012C, "Member 'FCrabAutoSave::NumTotemsDestroyed' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Crystals) == 0x000130, "Member 'FCrabAutoSave::Crystals' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, TotalTimeTaken) == 0x000134, "Member 'FCrabAutoSave::TotalTimeTaken' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, CompletedChallenges) == 0x000138, "Member 'FCrabAutoSave::CompletedChallenges' has a wrong offset!");

// ScriptStruct CrabChampions.CrabEnemyStats
// 0x0010 (0x0010 - 0x0000)
struct FCrabEnemyStats final
{
public:
	float                                         HealthMultiplier;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeedMultiplier;                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionSpeedMultiplier;                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMultiplier;                                  // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabEnemyStats) == 0x000004, "Wrong alignment on FCrabEnemyStats");
static_assert(sizeof(FCrabEnemyStats) == 0x000010, "Wrong size on FCrabEnemyStats");
static_assert(offsetof(FCrabEnemyStats, HealthMultiplier) == 0x000000, "Member 'FCrabEnemyStats::HealthMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabEnemyStats, MovementSpeedMultiplier) == 0x000004, "Member 'FCrabEnemyStats::MovementSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabEnemyStats, ActionSpeedMultiplier) == 0x000008, "Member 'FCrabEnemyStats::ActionSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabEnemyStats, DamageMultiplier) == 0x00000C, "Member 'FCrabEnemyStats::DamageMultiplier' has a wrong offset!");

// ScriptStruct CrabChampions.CrabAISettings
// 0x0028 (0x0028 - 0x0000)
struct FCrabAISettings final
{
public:
	ECrabEnemyMovementType                        MovementType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D5[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBetweenMoves;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpProbability;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashProbability;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenActionsMin;                             // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenActionsMax;                             // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UEnvQuery*>                      RangedActionEnvQueries;                            // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabAISettings) == 0x000008, "Wrong alignment on FCrabAISettings");
static_assert(sizeof(FCrabAISettings) == 0x000028, "Wrong size on FCrabAISettings");
static_assert(offsetof(FCrabAISettings, MovementType) == 0x000000, "Member 'FCrabAISettings::MovementType' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, TimeBetweenMoves) == 0x000004, "Member 'FCrabAISettings::TimeBetweenMoves' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, JumpProbability) == 0x000008, "Member 'FCrabAISettings::JumpProbability' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, DashProbability) == 0x00000C, "Member 'FCrabAISettings::DashProbability' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, TimeBetweenActionsMin) == 0x000010, "Member 'FCrabAISettings::TimeBetweenActionsMin' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, TimeBetweenActionsMax) == 0x000014, "Member 'FCrabAISettings::TimeBetweenActionsMax' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, RangedActionEnvQueries) == 0x000018, "Member 'FCrabAISettings::RangedActionEnvQueries' has a wrong offset!");

// ScriptStruct CrabChampions.CrabPortalInfo
// 0x0020 (0x0020 - 0x0000)
struct FCrabPortalInfo final
{
public:
	bool                                          bIsInited;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D6[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabChallengeModifier>                ChallengeModifiers;                                // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	ECrabBlessing                                 Blessing;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabLootPool                                 RewardLootPool;                                    // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D7[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabPortalInfo) == 0x000008, "Wrong alignment on FCrabPortalInfo");
static_assert(sizeof(FCrabPortalInfo) == 0x000020, "Wrong size on FCrabPortalInfo");
static_assert(offsetof(FCrabPortalInfo, bIsInited) == 0x000000, "Member 'FCrabPortalInfo::bIsInited' has a wrong offset!");
static_assert(offsetof(FCrabPortalInfo, ChallengeModifiers) == 0x000008, "Member 'FCrabPortalInfo::ChallengeModifiers' has a wrong offset!");
static_assert(offsetof(FCrabPortalInfo, Blessing) == 0x000018, "Member 'FCrabPortalInfo::Blessing' has a wrong offset!");
static_assert(offsetof(FCrabPortalInfo, RewardLootPool) == 0x000019, "Member 'FCrabPortalInfo::RewardLootPool' has a wrong offset!");

// ScriptStruct CrabChampions.CrabContract
// 0x000C (0x000C - 0x0000)
struct FCrabContract final
{
public:
	ECrabContractType                             ContractType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D8[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Progress;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Goal;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabContract) == 0x000004, "Wrong alignment on FCrabContract");
static_assert(sizeof(FCrabContract) == 0x00000C, "Wrong size on FCrabContract");
static_assert(offsetof(FCrabContract, ContractType) == 0x000000, "Member 'FCrabContract::ContractType' has a wrong offset!");
static_assert(offsetof(FCrabContract, Progress) == 0x000004, "Member 'FCrabContract::Progress' has a wrong offset!");
static_assert(offsetof(FCrabContract, Goal) == 0x000008, "Member 'FCrabContract::Goal' has a wrong offset!");

// ScriptStruct CrabChampions.CrabIsland
// 0x000C (0x000C - 0x0000)
struct FCrabIsland final
{
public:
	class FName                                   IslandName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnWeight;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabIsland) == 0x000004, "Wrong alignment on FCrabIsland");
static_assert(sizeof(FCrabIsland) == 0x00000C, "Wrong size on FCrabIsland");
static_assert(offsetof(FCrabIsland, IslandName) == 0x000000, "Member 'FCrabIsland::IslandName' has a wrong offset!");
static_assert(offsetof(FCrabIsland, SpawnWeight) == 0x000008, "Member 'FCrabIsland::SpawnWeight' has a wrong offset!");

// ScriptStruct CrabChampions.CrabRankedWeapon
// 0x0010 (0x0010 - 0x0000)
struct FCrabRankedWeapon final
{
public:
	class UCrabPickupDA*                          Weapon;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabRank                                     Rank;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D9[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabRankedWeapon) == 0x000008, "Wrong alignment on FCrabRankedWeapon");
static_assert(sizeof(FCrabRankedWeapon) == 0x000010, "Wrong size on FCrabRankedWeapon");
static_assert(offsetof(FCrabRankedWeapon, Weapon) == 0x000000, "Member 'FCrabRankedWeapon::Weapon' has a wrong offset!");
static_assert(offsetof(FCrabRankedWeapon, Rank) == 0x000008, "Member 'FCrabRankedWeapon::Rank' has a wrong offset!");

// ScriptStruct CrabChampions.CrabInventoryCooldown
// 0x0010 (0x0010 - 0x0000)
struct FCrabInventoryCooldown final
{
public:
	class UCrabInventoryDA*                       InventoryDA;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CurrentCooldown;                                   // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DA[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabInventoryCooldown) == 0x000008, "Wrong alignment on FCrabInventoryCooldown");
static_assert(sizeof(FCrabInventoryCooldown) == 0x000010, "Wrong size on FCrabInventoryCooldown");
static_assert(offsetof(FCrabInventoryCooldown, InventoryDA) == 0x000000, "Member 'FCrabInventoryCooldown::InventoryDA' has a wrong offset!");
static_assert(offsetof(FCrabInventoryCooldown, CurrentCooldown) == 0x000008, "Member 'FCrabInventoryCooldown::CurrentCooldown' has a wrong offset!");

// ScriptStruct CrabChampions.CrabPedestalInfo
// 0x000C (0x000C - 0x0000)
struct FCrabPedestalInfo final
{
public:
	ECrabCurrencyType                             CurrencyType;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DB[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cost;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiscountPercentage;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabPedestalInfo) == 0x000004, "Wrong alignment on FCrabPedestalInfo");
static_assert(sizeof(FCrabPedestalInfo) == 0x00000C, "Wrong size on FCrabPedestalInfo");
static_assert(offsetof(FCrabPedestalInfo, CurrencyType) == 0x000000, "Member 'FCrabPedestalInfo::CurrencyType' has a wrong offset!");
static_assert(offsetof(FCrabPedestalInfo, Cost) == 0x000004, "Member 'FCrabPedestalInfo::Cost' has a wrong offset!");
static_assert(offsetof(FCrabPedestalInfo, DiscountPercentage) == 0x000008, "Member 'FCrabPedestalInfo::DiscountPercentage' has a wrong offset!");

// ScriptStruct CrabChampions.CrabPickupInfo
// 0x0058 (0x0058 - 0x0000)
struct FCrabPickupInfo final
{
public:
	struct FVector_NetQuantize                    CosmeticSpawnLoc;                                  // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DC[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabPickupDA*                          PickupDA;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0018(0x0020)(Edit, NativeAccessSpecifierPublic)
	uint8                                         MaxPickups;                                        // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabCurrencyType                             CurrencyType;                                      // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DD[0x2];                                     // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cost;                                              // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SalvageReward;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DE[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabPS*                                OwningPS;                                          // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLocationUI;                                   // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutoLootPickup;                                 // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DF[0x6];                                     // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabPickupInfo) == 0x000008, "Wrong alignment on FCrabPickupInfo");
static_assert(sizeof(FCrabPickupInfo) == 0x000058, "Wrong size on FCrabPickupInfo");
static_assert(offsetof(FCrabPickupInfo, CosmeticSpawnLoc) == 0x000000, "Member 'FCrabPickupInfo::CosmeticSpawnLoc' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, PickupDA) == 0x000010, "Member 'FCrabPickupInfo::PickupDA' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, InventoryInfo) == 0x000018, "Member 'FCrabPickupInfo::InventoryInfo' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, MaxPickups) == 0x000038, "Member 'FCrabPickupInfo::MaxPickups' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, CurrencyType) == 0x000039, "Member 'FCrabPickupInfo::CurrencyType' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, Cost) == 0x00003C, "Member 'FCrabPickupInfo::Cost' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, SalvageReward) == 0x000040, "Member 'FCrabPickupInfo::SalvageReward' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, OwningPS) == 0x000048, "Member 'FCrabPickupInfo::OwningPS' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, bShowLocationUI) == 0x000050, "Member 'FCrabPickupInfo::bShowLocationUI' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, bIsAutoLootPickup) == 0x000051, "Member 'FCrabPickupInfo::bIsAutoLootPickup' has a wrong offset!");

// ScriptStruct CrabChampions.CrabProjectileInfo
// 0x0030 (0x0030 - 0x0000)
struct FCrabProjectileInfo final
{
public:
	class UCrabProjectileDA*                      ProjectileDA;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 Dir;                                               // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E0[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 OwningC;                                           // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabLesserProjectileType                     LesserProjectileType;                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E1[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ActorToMoveIgnore;                                 // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabProjectileInfo) == 0x000008, "Wrong alignment on FCrabProjectileInfo");
static_assert(sizeof(FCrabProjectileInfo) == 0x000030, "Wrong size on FCrabProjectileInfo");
static_assert(offsetof(FCrabProjectileInfo, ProjectileDA) == 0x000000, "Member 'FCrabProjectileInfo::ProjectileDA' has a wrong offset!");
static_assert(offsetof(FCrabProjectileInfo, Dir) == 0x000008, "Member 'FCrabProjectileInfo::Dir' has a wrong offset!");
static_assert(offsetof(FCrabProjectileInfo, OwningC) == 0x000018, "Member 'FCrabProjectileInfo::OwningC' has a wrong offset!");
static_assert(offsetof(FCrabProjectileInfo, LesserProjectileType) == 0x000020, "Member 'FCrabProjectileInfo::LesserProjectileType' has a wrong offset!");
static_assert(offsetof(FCrabProjectileInfo, ActorToMoveIgnore) == 0x000028, "Member 'FCrabProjectileInfo::ActorToMoveIgnore' has a wrong offset!");

// ScriptStruct CrabChampions.CrabDebuffState
// 0x0014 (0x0014 - 0x0000)
struct FCrabDebuffState final
{
public:
	int32                                         IceStack;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireStack;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightningStack;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PoisonStack;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArcaneStack;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabDebuffState) == 0x000004, "Wrong alignment on FCrabDebuffState");
static_assert(sizeof(FCrabDebuffState) == 0x000014, "Wrong size on FCrabDebuffState");
static_assert(offsetof(FCrabDebuffState, IceStack) == 0x000000, "Member 'FCrabDebuffState::IceStack' has a wrong offset!");
static_assert(offsetof(FCrabDebuffState, FireStack) == 0x000004, "Member 'FCrabDebuffState::FireStack' has a wrong offset!");
static_assert(offsetof(FCrabDebuffState, LightningStack) == 0x000008, "Member 'FCrabDebuffState::LightningStack' has a wrong offset!");
static_assert(offsetof(FCrabDebuffState, PoisonStack) == 0x00000C, "Member 'FCrabDebuffState::PoisonStack' has a wrong offset!");
static_assert(offsetof(FCrabDebuffState, ArcaneStack) == 0x000010, "Member 'FCrabDebuffState::ArcaneStack' has a wrong offset!");

// ScriptStruct CrabChampions.CrabDebuff
// 0x0008 (0x0008 - 0x0000)
struct FCrabDebuff final
{
public:
	ECrabDebuffType                               DebuffType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E2[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebuffStack;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabDebuff) == 0x000004, "Wrong alignment on FCrabDebuff");
static_assert(sizeof(FCrabDebuff) == 0x000008, "Wrong size on FCrabDebuff");
static_assert(offsetof(FCrabDebuff, DebuffType) == 0x000000, "Member 'FCrabDebuff::DebuffType' has a wrong offset!");
static_assert(offsetof(FCrabDebuff, DebuffStack) == 0x000004, "Member 'FCrabDebuff::DebuffStack' has a wrong offset!");

// ScriptStruct CrabChampions.CrabDamageInfo
// 0x0038 (0x0038 - 0x0000)
struct FCrabDamageInfo final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrit;                                             // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDOT;                                              // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabDamageType                               CrabDamageType;                                    // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E3[0x1];                                     // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabDebuff>                    Debuffs;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    DamageLoc;                                         // 0x0020(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackStrength;                                 // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACrabC*                                 DamagingC;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabDamageInfo) == 0x000008, "Wrong alignment on FCrabDamageInfo");
static_assert(sizeof(FCrabDamageInfo) == 0x000038, "Wrong size on FCrabDamageInfo");
static_assert(offsetof(FCrabDamageInfo, DamagedActor) == 0x000000, "Member 'FCrabDamageInfo::DamagedActor' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, Damage) == 0x000008, "Member 'FCrabDamageInfo::Damage' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, bCrit) == 0x00000C, "Member 'FCrabDamageInfo::bCrit' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, bDOT) == 0x00000D, "Member 'FCrabDamageInfo::bDOT' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, CrabDamageType) == 0x00000E, "Member 'FCrabDamageInfo::CrabDamageType' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, Debuffs) == 0x000010, "Member 'FCrabDamageInfo::Debuffs' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, DamageLoc) == 0x000020, "Member 'FCrabDamageInfo::DamageLoc' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, KnockbackStrength) == 0x00002C, "Member 'FCrabDamageInfo::KnockbackStrength' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, DamagingC) == 0x000030, "Member 'FCrabDamageInfo::DamagingC' has a wrong offset!");

// ScriptStruct CrabChampions.CrabExplosionFX
// 0x0048 (0x0048 - 0x0000)
struct FCrabExplosionFX final
{
public:
	struct FVector                                Loc;                                               // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactNormal;                                      // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E4[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         FX;                                                // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Tint;                                              // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              Sound;                                             // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           CameraShake;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabExplosionFX) == 0x000008, "Wrong alignment on FCrabExplosionFX");
static_assert(sizeof(FCrabExplosionFX) == 0x000048, "Wrong size on FCrabExplosionFX");
static_assert(offsetof(FCrabExplosionFX, Loc) == 0x000000, "Member 'FCrabExplosionFX::Loc' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, ImpactNormal) == 0x00000C, "Member 'FCrabExplosionFX::ImpactNormal' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, Radius) == 0x000018, "Member 'FCrabExplosionFX::Radius' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, FX) == 0x000020, "Member 'FCrabExplosionFX::FX' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, Tint) == 0x000028, "Member 'FCrabExplosionFX::Tint' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, Sound) == 0x000038, "Member 'FCrabExplosionFX::Sound' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, CameraShake) == 0x000040, "Member 'FCrabExplosionFX::CameraShake' has a wrong offset!");

// ScriptStruct CrabChampions.CrabVideoSettings
// 0x0110 (0x0110 - 0x0000)
struct FCrabVideoSettings final
{
public:
	class FString                                 DisplayMode;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Resolution;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResolutionQuality;                                 // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FPSLimit;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VSync;                                             // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldOfView;                                       // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GraphicsQuality;                                   // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponEffects;                                     // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AntiAliasingType;                                  // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Sharpening;                                        // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MotionBlur;                                        // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CameraShake;                                       // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Hitmarkers;                                        // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DamageNumbers;                                     // 0x00D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextChatVisibility;                                // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShowFPS;                                           // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PauseWhenLosingFocus;                              // 0x0100(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabVideoSettings) == 0x000008, "Wrong alignment on FCrabVideoSettings");
static_assert(sizeof(FCrabVideoSettings) == 0x000110, "Wrong size on FCrabVideoSettings");
static_assert(offsetof(FCrabVideoSettings, DisplayMode) == 0x000000, "Member 'FCrabVideoSettings::DisplayMode' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, Resolution) == 0x000010, "Member 'FCrabVideoSettings::Resolution' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, ResolutionQuality) == 0x000020, "Member 'FCrabVideoSettings::ResolutionQuality' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, FPSLimit) == 0x000030, "Member 'FCrabVideoSettings::FPSLimit' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, VSync) == 0x000040, "Member 'FCrabVideoSettings::VSync' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, FieldOfView) == 0x000050, "Member 'FCrabVideoSettings::FieldOfView' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, GraphicsQuality) == 0x000060, "Member 'FCrabVideoSettings::GraphicsQuality' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, WeaponEffects) == 0x000070, "Member 'FCrabVideoSettings::WeaponEffects' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, AntiAliasingType) == 0x000080, "Member 'FCrabVideoSettings::AntiAliasingType' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, Sharpening) == 0x000090, "Member 'FCrabVideoSettings::Sharpening' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, MotionBlur) == 0x0000A0, "Member 'FCrabVideoSettings::MotionBlur' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, CameraShake) == 0x0000B0, "Member 'FCrabVideoSettings::CameraShake' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, Hitmarkers) == 0x0000C0, "Member 'FCrabVideoSettings::Hitmarkers' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, DamageNumbers) == 0x0000D0, "Member 'FCrabVideoSettings::DamageNumbers' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, TextChatVisibility) == 0x0000E0, "Member 'FCrabVideoSettings::TextChatVisibility' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, ShowFPS) == 0x0000F0, "Member 'FCrabVideoSettings::ShowFPS' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, PauseWhenLosingFocus) == 0x000100, "Member 'FCrabVideoSettings::PauseWhenLosingFocus' has a wrong offset!");

// ScriptStruct CrabChampions.CrabKeyBind
// 0x0070 (0x0070 - 0x0000)
struct FCrabKeyBind final
{
public:
	class FName                                   MappingName;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeyBindTitle;                                      // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAxisMapping;                                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E5[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   KeyboardKey;                                       // 0x0020(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeyboardKeyFriendlyName;                           // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   ControllerKey;                                     // 0x0048(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ControllerIcon;                                    // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeRemapped;                                    // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E6[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabKeyBind) == 0x000008, "Wrong alignment on FCrabKeyBind");
static_assert(sizeof(FCrabKeyBind) == 0x000070, "Wrong size on FCrabKeyBind");
static_assert(offsetof(FCrabKeyBind, MappingName) == 0x000000, "Member 'FCrabKeyBind::MappingName' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, KeyBindTitle) == 0x000008, "Member 'FCrabKeyBind::KeyBindTitle' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, bAxisMapping) == 0x000018, "Member 'FCrabKeyBind::bAxisMapping' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, KeyboardKey) == 0x000020, "Member 'FCrabKeyBind::KeyboardKey' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, KeyboardKeyFriendlyName) == 0x000038, "Member 'FCrabKeyBind::KeyboardKeyFriendlyName' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, ControllerKey) == 0x000048, "Member 'FCrabKeyBind::ControllerKey' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, ControllerIcon) == 0x000060, "Member 'FCrabKeyBind::ControllerIcon' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, bCanBeRemapped) == 0x000068, "Member 'FCrabKeyBind::bCanBeRemapped' has a wrong offset!");

// ScriptStruct CrabChampions.CrabWeaponInfo
// 0x0018 (0x0018 - 0x0000)
struct FCrabWeaponInfo final
{
public:
	class UCrabWeaponDA*                          WeaponDA;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACrabC*                                 OwningC;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDualWieldWeapon;                                // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E7[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabWeaponInfo) == 0x000008, "Wrong alignment on FCrabWeaponInfo");
static_assert(sizeof(FCrabWeaponInfo) == 0x000018, "Wrong size on FCrabWeaponInfo");
static_assert(offsetof(FCrabWeaponInfo, WeaponDA) == 0x000000, "Member 'FCrabWeaponInfo::WeaponDA' has a wrong offset!");
static_assert(offsetof(FCrabWeaponInfo, OwningC) == 0x000008, "Member 'FCrabWeaponInfo::OwningC' has a wrong offset!");
static_assert(offsetof(FCrabWeaponInfo, bIsDualWieldWeapon) == 0x000010, "Member 'FCrabWeaponInfo::bIsDualWieldWeapon' has a wrong offset!");

}

